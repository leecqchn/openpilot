/*
 * File: app.c
 *
 * Code generated for Simulink model 'app'.
 *
 * Model version                  : 1.172
 * Simulink Coder version         : 9.4 (R2020b) 29-Jul-2020
 * C/C++ source code generated on : Thu Feb 24 05:55:06 2022
 *
 * Target selection: ert.tlc
 * Embedded hardware selection: Infineon->TriCore
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */

#include "app.h"
#include "app_private.h"

/* Named constants for Chart: '<S75>/Chart3' */
#define app_IN_NO_ACTIVE_CHILD         ((uint8_T)0U)
#define app_IN_OFF                     ((uint8_T)1U)
#define app_IN_ON                      ((uint8_T)2U)
#define app_IN_UP                      ((uint8_T)1U)
#define app_IN_Zero                    ((uint8_T)2U)

/* Named constants for Chart: '<S97>/Chart' */
#define app_IN_OFF_Count               ((uint8_T)2U)
#define app_IN_OFF_m                   ((uint8_T)1U)
#define app_IN_ON_Count                ((uint8_T)4U)
#define app_IN_ON_f                    ((uint8_T)3U)

/* Named constants for Chart: '<S483>/Chart1' */
#define app_IN_Keep                    ((uint8_T)1U)
#define app_IN_Update                  ((uint8_T)2U)

/* Named constants for Chart: '<S968>/DFIn_TmCntrSF_TRUE' */
#define app_IN_Counter_Satisfy_Condition ((uint8_T)1U)
#define app_IN_Initial_Condition       ((uint8_T)2U)
#define app_IN_Middle_Condition        ((uint8_T)3U)

/* Named constants for Chart: '<S945>/DFIn_TmCntrSF_TRUE1' */
#define app_IN_Counter_Satisfy_Condition_b ((uint8_T)1U)
#define app_IN_Initial_Condition_l     ((uint8_T)2U)
#define app_IN_Middle_Condition_m      ((uint8_T)3U)

/* Named constants for Chart: '<S1003>/ACC_ACCDetObjDistLvl' */
#define app_IN_DetObjDistLvl1          ((uint8_T)1U)
#define app_IN_DetObjDistLvl2          ((uint8_T)2U)
#define app_IN_DetObjDistLvl3          ((uint8_T)3U)

/* Named constants for Chart: '<S1004>/Chart' */
#define app_IN_EgoVeh_Mov              ((uint8_T)1U)
#define app_IN_EgoVeh_Stsl             ((uint8_T)2U)
#define app_IN_NO_ACTIVE_CHILD_e       ((uint8_T)0U)
#define app_IN_Obj_ChgOrDet            ((uint8_T)1U)
#define app_IN_Obj_NotVld              ((uint8_T)1U)
#define app_IN_Obj_Stdy                ((uint8_T)2U)
#define app_IN_Obj_Vld                 ((uint8_T)2U)

/* Named constants for Chart: '<S1054>/DFIn_TmCntrSF_TRUE' */
#define app_IN_Counter_Satisfy_Condition_a ((uint8_T)1U)
#define app_IN_Initial_Condition_i     ((uint8_T)2U)
#define app_IN_Middle_Condition_c      ((uint8_T)3U)

/* Named constants for Chart: '<S1067>/Chart4' */
#define app_IN_OFF_j                   ((uint8_T)1U)
#define app_IN_ON_i                    ((uint8_T)2U)

/* Named constants for Chart: '<S123>/Chart' */
#define app_IN_OFF_Count_o             ((uint8_T)2U)
#define app_IN_OFF_f                   ((uint8_T)1U)
#define app_IN_ON_Count_j              ((uint8_T)4U)
#define app_IN_ON_e                    ((uint8_T)3U)

/* Named constants for Chart: '<S131>/GainForStartStop' */
#define app_IN_Initial                 ((uint8_T)1U)
#define app_IN_Stop                    ((uint8_T)2U)

/* Named constants for Chart: '<S192>/GainForStartStop' */
#define app_IN_CountDown               ((uint8_T)1U)
#define app_IN_CountUp                 ((uint8_T)2U)
#define app_IN_Start                   ((uint8_T)3U)
#define app_IN_Stop_g                  ((uint8_T)4U)

/* Named constants for Chart: '<S906>/SpdDec' */
#define app_IN_HoldSts                 ((uint8_T)1U)
#define app_IN_Initial_Condition1      ((uint8_T)1U)
#define app_IN_Initial_Condition_l0    ((uint8_T)2U)
#define app_IN_Middle_Condition_cz     ((uint8_T)3U)
#define app_IN_PressSts                ((uint8_T)4U)
#define app_IN_Sampling                ((uint8_T)2U)

/* Named constants for Chart: '<S906>/SpdInc' */
#define app_IN_Initial_Condition_m     ((uint8_T)1U)

/* Named constants for Chart: '<S946>/ACCFirstASctvJud' */
#define app_IN_ACC_Actv_Exist          ((uint8_T)1U)
#define app_IN_ACC_Ini                 ((uint8_T)2U)

/* Named constants for Chart: '<S946>/ACCOvrdCntr' */
#define app_IN_ACC_Not_Ovrd            ((uint8_T)1U)
#define app_IN_ACC_Ovrd                ((uint8_T)2U)

/* Named constants for Chart: '<S909>/ACC_SSM' */
#define app_IN_ACC_ACTIVE_Cruise       ((uint8_T)1U)
#define app_IN_ACC_Active              ((uint8_T)1U)
#define app_IN_ACC_Active_Override     ((uint8_T)2U)
#define app_IN_ACC_Approaching         ((uint8_T)1U)
#define app_IN_ACC_BrakeOnly           ((uint8_T)3U)
#define app_IN_ACC_Fault               ((uint8_T)2U)
#define app_IN_ACC_Off                 ((uint8_T)3U)
#define app_IN_ACC_Standby             ((uint8_T)4U)
#define app_IN_Cruise_CCC              ((uint8_T)2U)
#define app_IN_Failure_IRreversible    ((uint8_T)1U)
#define app_IN_Failure_Reversible      ((uint8_T)2U)
#define app_IN_eStandStillActive       ((uint8_T)3U)
#define app_IN_eStandStillWait         ((uint8_T)4U)

/* Named constants for Chart: '<S999>/ACC_Control_Elements' */
#define IN_DISSts_Standby_BrkOnly_StslWait_Fau ((uint8_T)4U)
#define app_IN_DISSts_Active           ((uint8_T)1U)
#define app_IN_DISSts_FirstStandby     ((uint8_T)2U)
#define app_IN_DISSts_OFF              ((uint8_T)3U)
#define app_IN_Initial_ACCSetSpeed     ((uint8_T)1U)
#define app_IN_Large_Increase          ((uint8_T)1U)
#define app_IN_Large_SpeedDecrease     ((uint8_T)1U)
#define app_IN_Light_Increase          ((uint8_T)2U)
#define app_IN_Light_SpeedDecrease     ((uint8_T)2U)
#define app_IN_MemSpdAdjust            ((uint8_T)1U)
#define app_IN_MemSpdGetValue          ((uint8_T)2U)
#define app_IN_MemSpd_FstStdby         ((uint8_T)1U)
#define app_IN_MemSpd_LargeDec         ((uint8_T)1U)
#define app_IN_MemSpd_LargeInc         ((uint8_T)2U)
#define app_IN_MemSpd_LightDec         ((uint8_T)3U)
#define app_IN_MemSpd_LightInc         ((uint8_T)4U)
#define app_IN_MemorySpeed_Set         ((uint8_T)2U)
#define app_IN_ResumeSpeed             ((uint8_T)2U)
#define app_IN_Spd_Dec_Wait            ((uint8_T)3U)
#define app_IN_Spd_Inc_Wait            ((uint8_T)3U)
#define app_IN_Speed_Decrease          ((uint8_T)3U)
#define app_IN_Speed_Increase          ((uint8_T)4U)
#define app_IN_Wait                    ((uint8_T)3U)
#define app_IN_Wait_d                  ((uint8_T)5U)

/* Named constants for Chart: '<S1000>/ACCDistanceSwitch_SM' */
#define IN_Cruise_Distance_Level_Decreased_Sta ((uint8_T)1U)
#define IN_Cruise_Distance_Level_Increased_Sta ((uint8_T)2U)
#define a_IN_Cruise_Distance_Level_Wait_Status ((uint8_T)4U)
#define ap_IN_Cruise_Distance_Level_Ini_Status ((uint8_T)3U)

/* Named constants for Chart: '<S1024>/ACCPtMdJud_IP31' */
#define app_IN_ACCPtMd_ECO             ((uint8_T)1U)
#define app_IN_ACCPtMd_Norm            ((uint8_T)2U)
#define app_IN_ACCPtMd_Norm_NotSupt    ((uint8_T)1U)
#define app_IN_ACCPtMd_Norm_Supt       ((uint8_T)2U)
#define app_IN_ACCPtMd_Sport           ((uint8_T)3U)

/* Named constants for Chart: '<S1030>/Chart' */
#define app_IN_OAF_Sw_Off              ((uint8_T)1U)
#define app_IN_OAF_Sw_On               ((uint8_T)2U)

/* Named constants for Chart: '<S1064>/Chart' */
#define app_IN_ON_a                    ((uint8_T)2U)
#define app_IN_Standby                 ((uint8_T)3U)

/* Named constants for Chart: '<S1119>/Chart1' */
#define app_IN_UP_b                    ((uint8_T)1U)
#define app_IN_Zero_e                  ((uint8_T)2U)

/* Named constants for Chart: '<S1240>/OvrdDely' */
#define app_IN_Delay                   ((uint8_T)1U)
#define app_IN_Norm                    ((uint8_T)2U)

/* Exported block signals */
real32_T longt_out_drvrSetIPKSpdV;     /* '<S1>/Signal Copy4' */
real32_T m_VehCP_T_ChLKARespToq_sg;    /* '<S72>/Data Type Conversion1' */
real32_T m_VehCP_T_DrvrStrgDlvrdToq_sg;/* '<S72>/Data Type Conversion2' */
real32_T m_VehCP_yr_VehDynYawRate_sg;  /* '<S84>/Sum' */
real32_T m_VehCP_angD_StrgWhlAng_sg;   /* '<S81>/Sum' */
real32_T m_VehCP_V_VehSpdAvgDrvn_sg;   /* '<S82>/Sum' */
real32_T m_VehCP_W_StrgWhlAngGrd_sg;   /* '<S85>/Sum' */
real32_T longt_out_desAccelCtrlCmd;    /* '<S90>/Add1' */
real32_T YRC_angD_ReqStrgWhlAng_sg;    /* '<S1294>/Switch' */
real32_T mpc_plan_desCurve;            /* '<S1065>/Divide' */
real32_T m_dst_target;                 /* '<S181>/Switch' */
real32_T m_dst_red;                    /* '<S137>/Signal Copy1' */
real32_T m_dst_desire;                 /* '<S137>/Subtract1' */
eRPL_RePlanLevel m_TRP_Replan_Level_Dis;/* '<S140>/Signal Copy' */
eRPL_RePlanLevel m_TRP_Replan_Level_Spd;/* '<S141>/Signal Copy' */
E_ACCReqSts_t m_FSM_sts_ACCSMRSts_en;  /* '<S909>/ACC_SSM' */
uint8_T longt_out_drvrSetTmDistLvl;    /* '<S1>/Data Type Conversion' */
uint8_T m_VehCP_LeftBSD_Warnning_u8;   /* '<S73>/Data Type Conversion' */
uint8_T m_VehCP_RightBSD_Warnning_u8;  /* '<S73>/Data Type Conversion1' */
uint8_T m_VehCP_n_ChLKACtrlSts_u8;     /* '<S72>/Data Type Conversion' */
uint8_T m_VehCP_n_StrgCustSetngDspCmd_u8;/* '<S72>/Data Type Conversion3' */
uint8_T FVCM_EPS_Frame[8];             /* '<S1070>/Signal Copy' */
uint8_T FVCM_HMI_Frame[8];             /* '<S1069>/Signal Copy' */
uint8_T m_Followed_Traj;               /* '<S139>/Switch13' */
boolean_T long_out_isLeadVehDtct;      /* '<S1019>/Compare' */
boolean_T m_ACC_is_FSMEnbl01_bl;       /* '<S942>/Logical Operator5' */
boolean_T m_ACC_is_FSMEnbl02_bl;       /* '<S942>/Logical Operator7' */
boolean_T m_ACC_is_FSMEnbl03_bl;       /* '<S942>/Logical Operator17' */
boolean_T m_ACC_is_VehSdslSts_bl;      /* '<S934>/Relational Operator' */
boolean_T m_ACC_is_SafyBltFstn_bl;     /* '<S945>/Logical Operator5' */
boolean_T m_ACC_is_FSMEnbl04_bl;       /* '<S942>/Logical Operator22' */
boolean_T m_ACC_is_FSMEnbl05_bl;       /* '<S942>/Logical Operator26' */
boolean_T m_ACC_is_FSMEnbl06_bl;       /* '<S942>/Logical Operator32' */
boolean_T m_ACC_is_FSMEnbl07_bl;       /* '<S942>/Logical Operator23' */
boolean_T m_ACC_is_ACCFSMEnbl_bl;      /* '<S942>/Logical Operator39' */
boolean_T m_ACC_is_SSMEnbl01_bl;       /* '<S975>/Logical Operator3'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_ACCSSMEnbl_bl;      /* '<S975>/Logical Operator8' */
boolean_T m_ACC_is_FSMDsbl01_bl;       /* '<S939>/Logical Operator4'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_ACCActvGeneral_bl;  /* '<S928>/Logical Operator24' */
boolean_T m_ACC_is_ACCOvrrdReq_bl;     /* '<S932>/Logical Operator5' */
boolean_T m_ACC_is_FSMDsbl02_bl;       /* '<S939>/Logical Operator12'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_FSMDsbl03_bl;       /* '<S939>/Logical Operator16'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_FSMDsbl04_bl;       /* '<S939>/Logical Operator13'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_FSMDsbl05_bl;       /* '<S939>/Logical Operator25'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_FSMDsbl06_bl;       /* '<S939>/Logical Operator21'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_FSMDsbl07_bl;       /* '<S939>/Logical Operator32'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_ACCFSMDsbl_bl;      /* '<S939>/Logical Operator40' */
boolean_T m_ACC_is_SSMDsbl01_bl;       /* '<S974>/Logical Operator2'
                                        * Indicate the left prevention trigger status in ITM.

                                        */
boolean_T m_ACC_is_ACCSSMDsbl_bl;      /* '<S974>/Logical Operator7' */
boolean_T m_ACC_is_ACCReqDsbl_bl;      /* '<S930>/Logical Operator4' */
boolean_T m_ACC_is_ACCReqEnbl_bl;      /* '<S930>/Logical Operator5' */
boolean_T m_ACC_is_BrkOnlyEnbl_bl;     /* '<S936>/Logical Operator3' */
boolean_T m_ACC_is_BrkOnlyExit_bl;     /* '<S937>/Logical Operator3' */
boolean_T m_VehCP_is_LftStrgLmpOn_bl;  /* '<S75>/Signal Copy18' */
boolean_T m_VehCP_is_RghtStrgLmpOn_bl; /* '<S75>/Signal Copy22' */
boolean_T longt_out_isCtrlEngage;      /* '<S94>/Switch' */
boolean_T m_ACC_is_AEBActvEver_bl;     /* '<S951>/Logical Operator10' */
boolean_T Arb_is_LatCtrlActv_bl;       /* '<S1064>/Signal Copy' */
boolean_T m_is_ACC_FaultBitlhbt_bl;    /* '<S93>/Constant5'
                                        * Indicate the left prevention trigger status in ITM.

                                        */

/* Exported block parameters */
real_T P_DFIn_cntr_DelayCntr_d = 30.0; /* Variable: P_DFIn_cntr_DelayCntr_d
                                        * Referenced by: '<S1042>/P_VDC_FSCAccelCmftUpRt_sg'
                                        * The delay number for the Estimated acceleration filter modular.
                                        */
real_T P_DFIn_cntr_VIDPEgoSpdAvgFltr_d = 10.0;
                                    /* Variable: P_DFIn_cntr_VIDPEgoSpdAvgFltr_d
                                     * Referenced by: '<S1060>/P_VDC_FSCAccelCmftUpRt_sg'
                                     */
real32_T ACC_v_VIDPEgoSpdMax_sg = 70.0F;/* Variable: ACC_v_VIDPEgoSpdMax_sg
                                         * Referenced by: '<S1062>/Saturation'
                                         * Vehicle Roll Back Judge Threshold Ego Vehicle Speed

                                         */
real32_T ACC_v_VIDPEgoSpdMin_sg = 0.0F;/* Variable: ACC_v_VIDPEgoSpdMin_sg
                                        * Referenced by: '<S1062>/Saturation'
                                        * Vehicle Roll Back Judge Threshold Ego Vehicle Speed

                                        */
real32_T C_ACC_Gx_HMIActuSpdToIPKSpd_sg = 1.05F;
                                     /* Variable: C_ACC_Gx_HMIActuSpdToIPKSpd_sg
                                      * Referenced by: '<S998>/Constant5'
                                      */
real32_T C_ACC_HMIZero_sg = 0.0F;      /* Variable: C_ACC_HMIZero_sg
                                        * Referenced by: '<S998>/2 wheels2'
                                        */
real32_T C_ACC_SMR_System_step = 0.02F;/* Variable: C_ACC_SMR_System_step
                                        * Referenced by:
                                        *   '<S909>/C_system_step_2'
                                        *   '<S993>/Constant3'
                                        *   '<S994>/Constant3'
                                        *   '<S995>/Constant1'
                                        */
real32_T C_ADS_A_VehAirArea_sg = 2.25F;/* Variable: C_ADS_A_VehAirArea_sg
                                        * Referenced by: '<S120>/Air_Area'
                                        */
real32_T C_ADS_Gx_ActuSpdToIPKSpd_sg = 1.05F;/* Variable: C_ADS_Gx_ActuSpdToIPKSpd_sg
                                              * Referenced by: '<S1061>/Constant4'
                                              */
real32_T C_ADS_Gx_AirResistRatio_sg = 0.35F;/* Variable: C_ADS_Gx_AirResistRatio_sg
                                             * Referenced by: '<S120>/Air_Resistance_Ratio1'
                                             */
real32_T C_ADS_Gx_VehRollResistCmp_sg = 0.000142F;/* Variable: C_ADS_Gx_VehRollResistCmp_sg
                                                   * Referenced by: '<S120>/Rolling_Resistance1'
                                                   */
real32_T C_ADS_M_VehMass_sg = 1435.0F; /* Variable: C_ADS_M_VehMass_sg
                                        * Referenced by:
                                        *   '<S117>/Mass_AS22_20T1'
                                        *   '<S120>/Mass_AS22_20T1'
                                        *   '<S120>/Mass_AS22_20T6'
                                        */
real32_T C_ARB_ro_AirDensity_sg = 1.2258F;/* Variable: C_ARB_ro_AirDensity_sg
                                           * Referenced by: '<S120>/Air_Density'
                                           */
real32_T C_DFIn_t_AccelDelyFilt_sg = 0.6F;/* Variable: C_DFIn_t_AccelDelyFilt_sg
                                           * Referenced by:
                                           *   '<S1041>/2 wheels'
                                           *   '<S1041>/2 wheels3'
                                           *   '<S1041>/2 wheels4'
                                           * Acceleration Calculate Delay Time
                                           */
real32_T P_ACC_Gx_HMIDistLvlLgrCmpCoe_sg = 0.1F;
                                    /* Variable: P_ACC_Gx_HMIDistLvlLgrCmpCoe_sg
                                     * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u2'
                                     */
real32_T P_ACC_Gx_HMIDistLvlSmlCmpCoe_sg = -0.05F;
                                    /* Variable: P_ACC_Gx_HMIDistLvlSmlCmpCoe_sg
                                     * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u4'
                                     */
real32_T P_ACC_Gx_HMIDsrdDistLvl1Mid_sg = 0.8F;
                                     /* Variable: P_ACC_Gx_HMIDsrdDistLvl1Mid_sg
                                      * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u13'
                                      */
real32_T P_ACC_Gx_HMIDsrdDistLvl1Ner_sg = 0.6F;
                                     /* Variable: P_ACC_Gx_HMIDsrdDistLvl1Ner_sg
                                      * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u14'
                                      */
real32_T P_ACC_V_FirstTmActvSpdThrs_sg = 5.0F;
                                      /* Variable: P_ACC_V_FirstTmActvSpdThrs_sg
                                       * Referenced by: '<S909>/P_VDC_ACC_v_MinCrsSpdThrs_u1'
                                       * ACC first Active Speed Thurshold
                                       */
real32_T P_ACC_V_HMIMemSpdHiThrs_sg = 180.0F;/* Variable: P_ACC_V_HMIMemSpdHiThrs_sg
                                              * Referenced by: '<S998>/VLC_VAC_ACCMemSpdRAW_d'
                                              * Memory Speed High Threshold
                                              */
real32_T P_ACC_V_HMIMemSpdLoThrs_sg = 0.0F;/* Variable: P_ACC_V_HMIMemSpdLoThrs_sg
                                            * Referenced by: '<S998>/VLC_VAC_ACCMemSpdRAW_d'
                                            * Memory Speed Low Threshold
                                            */
real32_T P_ACC_d_HMIDistLvlLgrCmp_sg = 0.3F;/* Variable: P_ACC_d_HMIDistLvlLgrCmp_sg
                                             * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u1'
                                             */
real32_T P_ACC_d_HMIDistLvlSmlCmp_sg = -0.15F;/* Variable: P_ACC_d_HMIDistLvlSmlCmp_sg
                                               * Referenced by: '<S1003>/P_ACC_cnt_OAFReActvThrs_u3'
                                               */
real32_T P_ACC_d_HMIObjDetMovObjDist_sg = 30.0F;
                                     /* Variable: P_ACC_d_HMIObjDetMovObjDist_sg
                                      * Referenced by: '<S1004>/Constant2'
                                      */
real32_T P_ACC_d_HMIObjDetStnObjDist_sg = 50.0F;
                                     /* Variable: P_ACC_d_HMIObjDetStnObjDist_sg
                                      * Referenced by: '<S1004>/Constant1'
                                      */
real32_T P_ACC_perc_HMIGoGasPdlThrs_sg = 1.0F;
                                      /* Variable: P_ACC_perc_HMIGoGasPdlThrs_sg
                                       * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg'
                                       * When the acutal gas pedal position is larger than this value, the driver intention
                                         is considered as part of Go request.
                                       */
real32_T P_ACC_perc_MinAccelPdlPos_sg = 1.0F;/* Variable: P_ACC_perc_MinAccelPdlPos_sg
                                              * Referenced by: '<S909>/ACC_SSM'
                                              * The value denotes the minimum value for acceleration gas pedal.
                                                Only when the gas pedal position is larger than this value, is the gas pedal
                                                considered as pressed.
                                              */
real32_T P_ACC_perc_SMRAccelPdlOvrrdExit_sg = 99.0F;
                                 /* Variable: P_ACC_perc_SMRAccelPdlOvrrdExit_sg
                                  * Referenced by:
                                  *   '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg'
                                  *   '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg1'
                                  */
real32_T P_ACC_t_AccelPdlOverrideExit_sg = 5.0F;
                                    /* Variable: P_ACC_t_AccelPdlOverrideExit_sg
                                     * Referenced by: '<S909>/P_ACC_cnt_OAFReActvThrs_u2'
                                     */
real32_T P_ACC_t_BrkOnlyTmThrs_sg = 5.0F;/* Variable: P_ACC_t_BrkOnlyTmThrs_sg
                                          * Referenced by: '<S909>/P_VDC_ACC_BrkOnlyTmThrs_u8'
                                          * Para_the maximum Time threshold and after this the brake only mode will exit;
                                          */
real32_T P_ACC_t_FTCAutoGoTm_sg = 5.0F;/* Variable: P_ACC_t_FTCAutoGoTm_sg
                                        * Referenced by: '<S909>/P_VDC_ACC_t_VehStdstlTmThrs_u8'
                                        * Para_when the time length is larger than the para, the ACC will going into StdStl wait status; during wait status the driver operations are needed when the driver wants to drive off automatically;
                                        */
real32_T P_ACC_t_HMIObjDetMovObjTmCfm_sg = 5.0F;
                                    /* Variable: P_ACC_t_HMIObjDetMovObjTmCfm_sg
                                     * Referenced by: '<S1004>/Constant5'
                                     */
real32_T P_ACC_t_HMIObjDetStnObjTmCfm_sg = 0.1F;
                                    /* Variable: P_ACC_t_HMIObjDetStnObjTmCfm_sg
                                     * Referenced by: '<S1004>/Constant4'
                                     */
real32_T P_ACC_t_OvrrdExitTm_sg = 900.0F;/* Variable: P_ACC_t_OvrrdExitTm_sg
                                          * Referenced by: '<S909>/P_VDC_ACC_OvrrdExitTmThrs_u8'
                                          * P_time threshold; when larger than the value, the ACC will exit to standby.
                                            20191119 change from 30 to 900 based on CRD1.8
                                          */
real32_T P_ACC_v_HMIMaxCrsSpdThrsLatActv_sg = 36.2F;
                                 /* Variable: P_ACC_v_HMIMaxCrsSpdThrsLatActv_sg
                                  * Referenced by:
                                  *   '<S999>/P_ACC_v_MaxCrsSpdThrs_u1'
                                  *   '<S999>/P_ACC_v_MaxCrsSpdThrs_u4'
                                  * Set speed High Threshold
                                  */
real32_T P_ACC_v_HMIMaxCrsSpdThrs_sg = 41.67F;/* Variable: P_ACC_v_HMIMaxCrsSpdThrs_sg
                                               * Referenced by: '<S999>/P_ACC_v_MaxCrsSpdThrs_u2'
                                               * The Maximum allowed Set Speed. When driver drives vehicle with a speed higher
                                                 thanthis value, and then press the Set Button, the speed will be set as this parameter value.
                                                 20191022 Change the value from 40 to 41.67,to match 150kph ACC Exit
                                               */
real32_T P_ACC_v_HMIObjDetMovObjSpd_sg = 1.0F;
                                      /* Variable: P_ACC_v_HMIObjDetMovObjSpd_sg
                                       * Referenced by: '<S1004>/Constant3'
                                       */
real32_T P_ACC_v_HMIObjDetStnObjSpd_sg = 0.3F;
                                      /* Variable: P_ACC_v_HMIObjDetStnObjSpd_sg
                                       * Referenced by: '<S1004>/Constant25'
                                       */
real32_T P_ACC_v_HMISetSpdHiThrs_sg = 50.0F;/* Variable: P_ACC_v_HMISetSpdHiThrs_sg
                                             * Referenced by: '<S998>/VLC_VAC_ACCSetSpdRAW_d'
                                             * Set speed High Threshold
                                             */
real32_T P_ACC_v_HMISetSpdLoThrs_sg = 0.0F;/* Variable: P_ACC_v_HMISetSpdLoThrs_sg
                                            * Referenced by: '<S998>/VLC_VAC_ACCSetSpdRAW_d'
                                            * Set speed Low Threshold
                                            */
real32_T P_ACC_v_SMRMaxCrsSpdThrs_sg = 41.67F;/* Variable: P_ACC_v_SMRMaxCrsSpdThrs_sg
                                               * Referenced by: '<S909>/P_ACC_v_MaxCrsSpdThrs_u1'
                                               */
real32_T P_DFIn_a_EstdLogAccTrtLoThrs_sg = 0.08F;
                                    /* Variable: P_DFIn_a_EstdLogAccTrtLoThrs_sg
                                     * Referenced by: '<S1039>/2 wheels5'
                                     * m/s2, Estimated Longitudinal Acceleration Trust Value Low Threshold
                                       if < the value, use the Acceleration from sensor
                                     */
real32_T P_DFIn_perc_AclActuPosOvrdHi_sg = 8.0F;
                                    /* Variable: P_DFIn_perc_AclActuPosOvrdHi_sg
                                     * Referenced by: '<S932>/1'
                                     */
real32_T P_DFIn_perc_AclActuPosOvrdLo_sg = 3.0F;
                                    /* Variable: P_DFIn_perc_AclActuPosOvrdLo_sg
                                     * Referenced by: '<S932>/ '
                                     */
real32_T P_DFIn_t_ABSActv_sg = 0.6F;   /* Variable: P_DFIn_t_ABSActv_sg
                                        * Referenced by: '<S976>/P_ACC_cnt_OAFReActvThrs_u2'
                                        * /+When the signal satisfies the entry condition, a counter-func will be triggered.
                                          E.g. It may be more proper to trust the ABS_Active=1 only if the counter about  ABS_Active=1 is larger than 15,
                                          and the time length is 15*t_sample.+/
                                        */
real32_T P_DFIn_t_ACCSpdDecHldCmdFrq_sg = 0.18F;
                                     /* Variable: P_DFIn_t_ACCSpdDecHldCmdFrq_sg
                                      * Referenced by: '<S906>/P_DFIn_t_VSELongtAccelFilter3'
                                      * 20191121 based on CRD1.8
                                      */
real32_T P_DFIn_t_ACCSpdDecHldThrs_sg = 0.49F;/* Variable: P_DFIn_t_ACCSpdDecHldThrs_sg
                                               * Referenced by: '<S906>/P_DFIn_t_VSELongtAccelFilter2'
                                               * 20191121 based on CRD1.8 changed to 0.2 - by Chencong
                                                 20191202 based on CRD1.9 changed to 0.5 - by WANGBIN

                                               */
real32_T P_DFIn_t_ACCSpdIncHldCmdFrq_sg = 0.18F;
                                     /* Variable: P_DFIn_t_ACCSpdIncHldCmdFrq_sg
                                      * Referenced by: '<S906>/P_DFIn_t_VSELongtAccelFilter1'
                                      * 20191121 based on CRD1.8
                                      */
real32_T P_DFIn_t_ACCSpdIncHldThrs_sg = 0.49F;/* Variable: P_DFIn_t_ACCSpdIncHldThrs_sg
                                               * Referenced by: '<S906>/P_DFIn_t_VSELongtAccelFilter'
                                               * 20191121 based on CRD1.8 changed to 0.2 - by Chencong
                                                 20191202 based on CRD1.9 changed to 0.5 - by WANGBIN

                                               */
real32_T P_DFIn_t_ACCToqReqRespNoReqHys_sg = 0.8F;
                                  /* Variable: P_DFIn_t_ACCToqReqRespNoReqHys_sg
                                   * Referenced by:
                                   *   '<S949>/P_ACC_cnt_OAFReActvThrs_u1'
                                   *   '<S949>/P_ACC_cnt_OAFReActvThrs_u2'
                                   * ACC_DP Parameter
                                     ECM Responce time hysteresis
                                   */
real32_T P_DFIn_t_CCFMAEBActvEver_sg = 3.0F;/* Variable: P_DFIn_t_CCFMAEBActvEver_sg
                                             * Referenced by: '<S951>/character7'
                                             */
real32_T P_DFIn_t_ChACCAccReqRespLosArb_sg = 0.6F;
                                  /* Variable: P_DFIn_t_ChACCAccReqRespLosArb_sg
                                   * Referenced by: '<S950>/P_ACC_cnt_OAFReActvThrs_u4'
                                   */
real32_T P_DFIn_t_ChACCAccReqRespNoReqHys_sg = 0.8F;
                                /* Variable: P_DFIn_t_ChACCAccReqRespNoReqHys_sg
                                 * Referenced by: '<S950>/P_ACC_cnt_OAFReActvThrs_u2'
                                 * ACC_DP Parameter
                                   ESP Responce time hysteresis
                                 */
real32_T P_DFIn_t_DrvrSbltAtcHys_sg = 1.5F;/* Variable: P_DFIn_t_DrvrSbltAtcHys_sg
                                            * Referenced by:
                                            *   '<S945>/P_ACC_cnt_OAFReActvThrs_u1'
                                            *   '<S945>/P_ACC_cnt_OAFReActvThrs_u2'
                                            */
real32_T P_DFIn_t_ESPActv_sg = 0.6F;   /* Variable: P_DFIn_t_ESPActv_sg
                                        * Referenced by:
                                        *   '<S976>/P_ACC_cnt_OAFReActvThrs_u16'
                                        *   '<S976>/P_ACC_cnt_OAFReActvThrs_u4'
                                        */
real32_T P_DFIn_t_HDCActv_sg = 0.6F;   /* Variable: P_DFIn_t_HDCActv_sg
                                        * Referenced by: '<S976>/P_ACC_cnt_OAFReActvThrs_u3'
                                        * CALI PARA.
                                          HDC aborton time threshold, when HDC active time length is larger than this para, the system
                                          will not support ACC and TJA.
                                        */
real32_T P_DFIn_t_TCSActv_sg = 0.8F;   /* Variable: P_DFIn_t_TCSActv_sg
                                        * Referenced by: '<S976>/P_ACC_cnt_OAFReActvThrs_u1'
                                        */
real32_T P_DFIn_t_VSELongtAccelFilter_sg = 0.1F;
                                    /* Variable: P_DFIn_t_VSELongtAccelFilter_sg
                                     * Referenced by: '<S1039>/P_DFIn_t_VSELongtAccelFilter'
                                     * VSE Longitudinal Acceleration Confirming Time Threshold
                                     */
real32_T P_DFIn_v_RolBckVehSpdThrs_sg = 1.39F;/* Variable: P_DFIn_v_RolBckVehSpdThrs_sg
                                               * Referenced by: '<S1037>/Constant4'
                                               * Vehicle Roll Back Judge Threshold Ego Vehicle Speed

                                               */
real32_T P_TX_ACC_V_HMIDISSetSpdCmpCnst_sg[5] = { 0.0F, 80.0F, 105.0F, 120.0F,
  160.0F } ;                      /* Variable: P_TX_ACC_V_HMIDISSetSpdCmpCnst_sg
                                   * Referenced by: '<S998>/LookupTable'
                                   */

real32_T P_TX_ACC_v_HMIDetDistLvlCmp_sg[6] = { 0.0F, 1.0F, 2.0F, 3.0F, 5.0F,
  10.0F } ;                          /* Variable: P_TX_ACC_v_HMIDetDistLvlCmp_sg
                                      * Referenced by:
                                      *   '<S1003>/HMI_DetDistLvl12Cmp'
                                      *   '<S1003>/HMI_DetDistLvl23Cmp'
                                      */

real32_T P_TY_ACC_V_HMIDISSetSpdCmpCnst_sg[5] = { -0.4F, 0.6F, 0.4F, 0.0F, 0.0F
} ;                               /* Variable: P_TY_ACC_V_HMIDISSetSpdCmpCnst_sg
                                   * Referenced by: '<S998>/LookupTable'
                                   */

real32_T P_TY_ACC_d_HMIDetDistLvl12Cmp_sg[6] = { 1.2F, 1.0F, 0.8F, 0.5F, 0.2F,
  0.0F } ;                         /* Variable: P_TY_ACC_d_HMIDetDistLvl12Cmp_sg
                                    * Referenced by: '<S1003>/HMI_DetDistLvl12Cmp'
                                    * [1.2 1 0.8 0.5 0.2 0]
                                      [1 0.8 0.6 0.4 0.2 0]
                                    */

real32_T P_TY_ACC_d_HMIDetDistLvl23Cmp_sg[6] = { 0.6F, 0.5F, 0.4F, 0.25F, 0.1F,
  0.0F } ;                         /* Variable: P_TY_ACC_d_HMIDetDistLvl23Cmp_sg
                                    * Referenced by: '<S1003>/HMI_DetDistLvl23Cmp'
                                    * [0.5 0.4 0.3 0.2 0.1 0]
                                      [0.6 0.5 0.4 0.25 0.1 0] update 0807
                                    */

real32_T k_TRPLon_Gx_DesireDistHiSpd_sg = 2.2F;
                                     /* Variable: k_TRPLon_Gx_DesireDistHiSpd_sg
                                      * Referenced by:
                                      *   '<S191>/Constant2'
                                      *   '<S201>/Constant2'
                                      */
real32_T k_TRPLon_Gx_DesireDistLowSpd_sg = 1.7F;
                                    /* Variable: k_TRPLon_Gx_DesireDistLowSpd_sg
                                     * Referenced by:
                                     *   '<S191>/Constant1'
                                     *   '<S201>/Constant1'
                                     */
real32_T k_TRPLon_Gx_PrdctTime_sg = 10.0F;/* Variable: k_TRPLon_Gx_PrdctTime_sg
                                           * Referenced by: '<S226>/Constant3'
                                           */
real32_T k_TRPLon_Gx_TrajKtWght_sg = 3.0F;/* Variable: k_TRPLon_Gx_TrajKtWght_sg
                                           * Referenced by: '<S239>/Constant1'
                                           */
real32_T k_TRPLon_Gx_aStateGain_sg = 1.0F;/* Variable: k_TRPLon_Gx_aStateGain_sg
                                           * Referenced by:
                                           *   '<S139>/Constant'
                                           *   '<S139>/Constant10'
                                           */
real32_T k_TRPLon_TX_v_FTCDsrdDistBrkPnt_sg[14] = { 0.0F, 0.001F, 2.77F, 5.55F,
  8.33F, 11.11F, 13.89F, 16.67F, 19.44F, 22.22F, 25.0F, 27.78F, 33.33F, 41.67F }
;                                /* Variable: k_TRPLon_TX_v_FTCDsrdDistBrkPnt_sg
                                  * Referenced by:
                                  *   '<S179>/FTCDsrdTmLv1'
                                  *   '<S179>/FTCDsrdTmLv2'
                                  *   '<S179>/FTCDsrdTmLv3'
                                  */

real32_T k_TRPLon_TX_v_FTCdDesSpdNorm_sg[14] = { 0.0F, 5.0F, 10.0F, 15.0F, 20.0F,
  25.0F, 30.0F, 35.0F, 40.0F, 50.0F, 60.0F, 70.0F, 80.0F, 90.0F } ;
                                    /* Variable: k_TRPLon_TX_v_FTCdDesSpdNorm_sg
                                     * Referenced by:
                                     *   '<S179>/FTCDsrdTmLv1ORG'
                                     *   '<S179>/FTCDsrdTmLv2ORG'
                                     *   '<S179>/FTCDsrdTmLv3ORG'
                                     */

real32_T k_TRPLon_TY_t_FTCDsrdDistLv1_sg[14] = { 1.0F, 1.0F, 1.2F, 1.25F, 1.25F,
  1.3F, 1.3F, 1.3F, 1.25F, 1.2F, 1.2F, 1.2F, 1.2F, 1.2F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCDsrdDistLv1_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv1'
                                     */

real32_T k_TRPLon_TY_t_FTCDsrdDistLv2_sg[14] = { 1.2F, 1.2F, 1.3F, 1.3F, 1.4F,
  1.45F, 1.45F, 1.5F, 1.5F, 1.5F, 1.5F, 1.5F, 1.4F, 1.4F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCDsrdDistLv2_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv2'
                                     */

real32_T k_TRPLon_TY_t_FTCDsrdDistLv3_sg[14] = { 1.4F, 1.4F, 1.4F, 1.5F, 1.55F,
  1.55F, 1.55F, 1.6F, 1.7F, 1.7F, 1.7F, 1.7F, 1.6F, 1.6F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCDsrdDistLv3_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv3'
                                     */

real32_T k_TRPLon_TY_t_FTCdDesDistLv1_sg[14] = { 1.2F, 1.2F, 1.2F, 1.2F, 1.2F,
  1.2F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F, 1.0F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCdDesDistLv1_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv1ORG'
                                     */

real32_T k_TRPLon_TY_t_FTCdDesDistLv2_sg[14] = { 1.5F, 1.5F, 1.5F, 1.5F, 1.5F,
  1.5F, 1.2F, 1.2F, 1.2F, 1.2F, 1.2F, 1.2F, 1.2F, 1.2F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCdDesDistLv2_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv2ORG'
                                     */

real32_T k_TRPLon_TY_t_FTCdDesDistLv3_sg[14] = { 1.8F, 1.8F, 1.8F, 1.8F, 1.8F,
  1.8F, 1.5F, 1.5F, 1.5F, 1.5F, 1.5F, 1.5F, 1.5F, 1.5F } ;
                                    /* Variable: k_TRPLon_TY_t_FTCdDesDistLv3_sg
                                     * Referenced by: '<S179>/FTCDsrdTmLv3ORG'
                                     */

real32_T k_TRPLon_a_ComfortBrake_sg = 2.5F;/* Variable: k_TRPLon_a_ComfortBrake_sg
                                            * Referenced by:
                                            *   '<S186>/comfort_brake'
                                            *   '<S186>/comfort_brake1'
                                            */
real32_T k_TRPLon_cof_Kt_TblData_sg[11] = { 0.1F, 0.1F, 0.2F, 0.2F, 0.3F, 0.5F,
  0.5F, 0.6F, 0.6F, 0.7F, 0.7F } ;     /* Variable: k_TRPLon_cof_Kt_TblData_sg
                                        * Referenced by: '<S239>/1-D Lookup Table8'
                                        */

real32_T k_TRPLon_cof_TrajJerkWght_sg = 1.0F;/* Variable: k_TRPLon_cof_TrajJerkWght_sg
                                              * Referenced by: '<S239>/Constant'
                                              */
real32_T k_TRPLon_cof_TrajLimVlatnWght_sg = 10.0F;
                                   /* Variable: k_TRPLon_cof_TrajLimVlatnWght_sg
                                    * Referenced by: '<S239>/Constant7'
                                    */
real32_T k_TRPLon_d_DistMinGapFar_sg = 4.5F;/* Variable: k_TRPLon_d_DistMinGapFar_sg
                                             * Referenced by: '<S147>/P_ACC_v_MaxCrsSpdThrs_u6'
                                             */
real32_T k_TRPLon_d_DistMinGapMid_sg = 4.2F;/* Variable: k_TRPLon_d_DistMinGapMid_sg
                                             * Referenced by: '<S147>/P_ACC_v_MaxCrsSpdThrs_u5'
                                             */
real32_T k_TRPLon_d_DistMinGapNear_sg = 3.8F;/* Variable: k_TRPLon_d_DistMinGapNear_sg
                                              * Referenced by: '<S147>/P_ACC_v_MaxCrsSpdThrs_u4'
                                              * changed to 2,8 from2.6m
                                              */
real32_T k_TRPLon_t_DistNrmRePlanTm_sg = 0.2F;
                                      /* Variable: k_TRPLon_t_DistNrmRePlanTm_sg
                                       * Referenced by: '<S483>/Constant3'
                                       */
real32_T k_TRPLon_t_RelDistPrdctTmVx_sg = 3.0F;
                                     /* Variable: k_TRPLon_t_RelDistPrdctTmVx_sg
                                      * Referenced by: '<S187>/Constant2'
                                      */
real32_T k_TRP_t_NrmRplnTm_sg = 2.0F;  /* Variable: k_TRP_t_NrmRplnTm_sg
                                        * Referenced by:
                                        *   '<S501>/Constant2'
                                        *   '<S501>/Constant5'
                                        */
uint16_T P_ACC_cntr_HMISETBtnDecFunc_u16 = 40U;
                                    /* Variable: P_ACC_cntr_HMISETBtnDecFunc_u16
                                     * Referenced by: '<S999>/P_ACC_cntr_SETBtnDecFunc_u16'
                                     */
uint16_T P_DFIn_n_EngRunActvMaxSpd_u16 = 6000U;
                                      /* Variable: P_DFIn_n_EngRunActvMaxSpd_u16
                                       * Referenced by: '<S1031>/Constant5'
                                       * The value indicates a speed value when the engine is in fault mode.
                                       */
uint16_T P_DFIn_n_EngRunActvSpd_u16 = 300U;/* Variable: P_DFIn_n_EngRunActvSpd_u16
                                            * Referenced by: '<S1031>/Constant2'
                                            * /+ Tunable Parameter.
                                              It shall be lower than engine idle speed for every project. +/
                                            */
boolean_T C_ACC_HMISwitch_Off_bl = 0;  /* Variable: C_ACC_HMISwitch_Off_bl
                                        * Referenced by: '<S999>/ACCSwitch_Off2'
                                        */
boolean_T C_ACC_HMISwitch_On_bl = 1;   /* Variable: C_ACC_HMISwitch_On_bl
                                        * Referenced by:
                                        *   '<S999>/ACCSwitch_On2'
                                        *   '<S1000>/C_Switch_On'
                                        */
boolean_T C_ACC_HMIZero_bl = 0;        /* Variable: C_ACC_HMIZero_bl
                                        * Referenced by:
                                        *   '<S1000>/Constant1'
                                        *   '<S1000>/Constant2'
                                        *   '<S1004>/Constant6'
                                        *   '<S1004>/Constant7'
                                        */
boolean_T P_ACC_is_CCFM_ABSActvEnIN_bl = 1;/* Variable: P_ACC_is_CCFM_ABSActvEnIN_bl
                                            * Referenced by: '<S976>/FW_P_ACC_is_CCFM_ABSActvIN_bl_2'
                                            */
boolean_T P_ACC_is_CCFM_ABSActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_ABSActvIN_bl
                                          * Referenced by: '<S976>/FW_P_ACC_is_CCFM_ABSActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_ACCCanclIN_bl = 1;/* Variable: P_ACC_is_CCFM_ACCCanclIN_bl
                                           * Referenced by: '<S977>/FW_P_ACC_is_CCFM_ACCCanclIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_ACCReqFltIN_bl = 1;/* Variable: P_ACC_is_CCFM_ACCReqFltIN_bl
                                            * Referenced by: '<S930>/FW_P_ACC_is_CCFM_ACCReqFltIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ACCReqIN_bl = 1;/* Variable: P_ACC_is_CCFM_ACCReqIN_bl
                                         * Referenced by: '<S930>/FW_P_ACC_is_CCFM_ACCReqIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_ACCTgtLosIN_bl = 1;/* Variable: P_ACC_is_CCFM_ACCTgtLosIN_bl
                                            * Referenced by: '<S978>/FW_P_ACC_is_CCFM_ACCTgtLosIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_AEBPActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_AEBPActvIN_bl
                                           * Referenced by: '<S951>/FW_P_ACC_is_CCFM_AEBPActvIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_AEBVActvExitIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_AEBVActvExitIN_bl
                                     * Referenced by:
                                     *   '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_2'
                                     *   '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_3'
                                     *   '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_4'
                                     */
boolean_T P_ACC_is_CCFM_AEBVActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_AEBVActvIN_bl
                                           * Referenced by: '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_APAActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_APAActvIN_bl
                                          * Referenced by: '<S952>/FW_P_ACC_is_CCFM_APAActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_AccRepLArbEnIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_AccRepLArbEnIN_bl
                                     * Referenced by: '<S950>/FW_P_ACC_is_CCFM_AccRepLArbEnIN_bl_1'
                                     */
boolean_T P_ACC_is_CCFM_AccRepPCndEnIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_AccRepPCndEnIN_bl
                                     * Referenced by: '<S950>/FW_P_ACC_is_CCFM_AccRepPCndEnIN_bl_1'
                                     */
boolean_T P_ACC_is_CCFM_AccRespErrIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_AccRespErrIN_bl
                                       * Referenced by: '<S940>/FW_P_ACC_is_CCFM_AccRespErrIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_AccRespLArbIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_AccRespLArbIN_bl
                                      * Referenced by: '<S950>/FW_P_ACC_is_CCFM_AccRespLArbIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_AccRespNReqIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_AccRespNReqIN_bl
                                      * Referenced by: '<S950>/FW_P_ACC_is_CCFM_AccRespNReqIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_AccRespPCndIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_AccRespPCndIN_bl
                                      * Referenced by: '<S950>/FW_P_ACC_is_CCFM_AccRespPCndIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_AirbagStsIN_bl = 1;/* Variable: P_ACC_is_CCFM_AirbagStsIN_bl
                                            * Referenced by: '<S953>/FW_P_ACC_is_CCFM_AirbagStsIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_BntStsIN_bl = 1;/* Variable: P_ACC_is_CCFM_BntStsIN_bl
                                         * Referenced by: '<S945>/FW_P_ACC_is_CCFM_BntStsIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_BrkDicTemHIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_BrkDicTemHIN_bl
                                       * Referenced by: '<S954>/FW_P_ACC_is_CCFM_BrkDicTemHIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_BrkPdlBkOyIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_BrkPdlBkOyIN_bl
                                       * Referenced by: '<S935>/FW_P_ACC_is_CCFM_BrkPdlAppIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_CCSDataIngIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_CCSDataIngIN_bl
                                       * Referenced by: '<S940>/FW_P_ACC_is_CCFM_CCSDataIngIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_DrvDoorIN_bl = 1;/* Variable: P_ACC_is_CCFM_DrvDoorIN_bl
                                          * Referenced by: '<S945>/FW_P_ACC_is_CCFM_DrvDoorIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_DrvngMdNoSuptIN_bl = 1;
                                   /* Variable: P_ACC_is_CCFM_DrvngMdNoSuptIN_bl
                                    * Referenced by: '<S955>/FW_P_ACC_is_CCFM_AEBPActvIN_bl_1'
                                    */
boolean_T P_ACC_is_CCFM_DspdSpdIN_bl = 1;/* Variable: P_ACC_is_CCFM_DspdSpdIN_bl
                                          * Referenced by: '<S940>/FW_P_ACC_is_CCFM_DspdSpdIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_EPBAppIN_bl = 1;/* Variable: P_ACC_is_CCFM_EPBAppIN_bl
                                         * Referenced by: '<S956>/FW_P_ACC_is_CCFM_EPBAppIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_EPBCCCanclIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_EPBCCCanclIN_bl
                                       * Referenced by: '<S956>/FW_P_ACC_is_CCFM_EPBCCCanclIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_EPBStsUnkwIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_EPBStsUnkwIN_bl
                                       * Referenced by: '<S940>/FW_P_ACC_is_CCFM_EPBStsUnkwIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_EmsnRltdIN_bl = 0;/* Variable: P_ACC_is_CCFM_EmsnRltdIN_bl
                                           * Referenced by: '<S947>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_2'
                                           */
boolean_T P_ACC_is_CCFM_EnNoActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_EnNoActvIN_bl
                                           * Referenced by: '<S948>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_FVCMBlkIN_bl = 1;/* Variable: P_ACC_is_CCFM_FVCMBlkIN_bl
                                          * Referenced by: '<S940>/FW_P_ACC_is_CCFM_FVCMBlkIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_FaultBitIhbtIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_FaultBitIhbtIN_bl
                                     * Referenced by:
                                     *   '<S907>/FW_P_ACC_is_CCFM_ISOCStfdIN_bl_2'
                                     *   '<S930>/FW_P_ACC_is_CCFM_ISOCStfdIN_bl_2'
                                     */
boolean_T P_ACC_is_CCFM_FrDoorIN_bl = 1;/* Variable: P_ACC_is_CCFM_FrDoorIN_bl
                                         * Referenced by: '<S945>/FW_P_ACC_is_CCFM_FrDoorIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_HDCActvEnIN_bl = 1;/* Variable: P_ACC_is_CCFM_HDCActvEnIN_bl
                                            * Referenced by: '<S976>/FW_P_ACC_is_CCFM_HDCActvIN_bl_2'
                                            */
boolean_T P_ACC_is_CCFM_HDCActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_HDCActvIN_bl
                                          * Referenced by: '<S976>/FW_P_ACC_is_CCFM_HDCActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_ISOCStfdIN_bl = 1;/* Variable: P_ACC_is_CCFM_ISOCStfdIN_bl
                                           * Referenced by: '<S930>/FW_P_ACC_is_CCFM_ISOCStfdIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_LdSpcStsIN_bl = 0;/* Variable: P_ACC_is_CCFM_LdSpcStsIN_bl
                                           * Referenced by: '<S945>/FW_P_ACC_is_CCFM_BntStsIN_bl_2'
                                           */
boolean_T P_ACC_is_CCFM_MSRActvEnIN_bl = 1;/* Variable: P_ACC_is_CCFM_MSRActvEnIN_bl
                                            * Referenced by: '<S976>/FW_P_ACC_is_CCFM_MSRActvIN_bl_2'
                                            */
boolean_T P_ACC_is_CCFM_MSRActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_MSRActvIN_bl
                                          * Referenced by: '<S976>/FW_P_ACC_is_CCFM_MSRActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_NRCDActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_NRCDActvIN_bl
                                           * Referenced by: '<S952>/FW_P_ACC_is_CCFM_NRCDActvIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_NonEmsnRltdIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_NonEmsnRltdIN_bl
                                      * Referenced by: '<S947>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_OvrrdReqIN_bl = 1;/* Variable: P_ACC_is_CCFM_OvrrdReqIN_bl
                                           * Referenced by: '<S935>/FW_P_ACC_is_CCFM_OvrrdReqIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_RLDoorIN_bl = 1;/* Variable: P_ACC_is_CCFM_RLDoorIN_bl
                                         * Referenced by: '<S945>/FW_P_ACC_is_CCFM_RLDoorIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_RRDoorIN_bl = 1;/* Variable: P_ACC_is_CCFM_RRDoorIN_bl
                                         * Referenced by: '<S945>/FW_P_ACC_is_CCFM_RRDoorIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_RolBckIN_bl = 1;/* Variable: P_ACC_is_CCFM_RolBckIN_bl
                                         * Referenced by: '<S948>/FW_P_ACC_is_CCFM_RolBckIN_bl_1'
                                         */
boolean_T P_ACC_is_CCFM_SSOCStfdIN_bl = 1;/* Variable: P_ACC_is_CCFM_SSOCStfdIN_bl
                                           * Referenced by: '<S930>/FW_P_ACC_is_CCFM_SSOCStfdIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_SafyBltStsIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_SafyBltStsIN_bl
                                       * Referenced by: '<S945>/FW_P_ACC_is_CCFM_SafyBltStsIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_ShftPosBtIN_bl = 1;/* Variable: P_ACC_is_CCFM_ShftPosBtIN_bl
                                            * Referenced by: '<S944>/FW_P_ACC_is_CCFM_ShftPosBtIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ShftPosNeIN_bl = 1;/* Variable: P_ACC_is_CCFM_ShftPosNeIN_bl
                                            * Referenced by: '<S944>/FW_P_ACC_is_CCFM_ShftPosNeIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ShftPosPkIN_bl = 1;/* Variable: P_ACC_is_CCFM_ShftPosPkIN_bl
                                            * Referenced by: '<S944>/FW_P_ACC_is_CCFM_ShftPosPkIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ShftPosReIN_bl = 1;/* Variable: P_ACC_is_CCFM_ShftPosReIN_bl
                                            * Referenced by: '<S944>/FW_P_ACC_is_CCFM_ShftPosReIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ShftPosUkIN_bl = 0;/* Variable: P_ACC_is_CCFM_ShftPosUkIN_bl
                                            * Referenced by: '<S944>/FW_P_ACC_is_CCFM_ShftPosUkIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_TCSActvEnIN_bl = 1;/* Variable: P_ACC_is_CCFM_TCSActvEnIN_bl
                                            * Referenced by: '<S976>/FW_P_ACC_is_CCFM_TCSActvIN_bl_2'
                                            */
boolean_T P_ACC_is_CCFM_TCSActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_TCSActvIN_bl
                                          * Referenced by: '<S976>/FW_P_ACC_is_CCFM_TCSActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_TCSOpMdOffIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_TCSOpMdOffIN_bl
                                       * Referenced by: '<S943>/FW_P_ACC_is_CCFM_TCSOpMdOffIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_TCSStsFltIN_bl = 1;/* Variable: P_ACC_is_CCFM_TCSStsFltIN_bl
                                            * Referenced by: '<S940>/FW_P_ACC_is_CCFM_TCSStsFltIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_ToqRepLArbEnIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_ToqRepLArbEnIN_bl
                                     * Referenced by: '<S949>/FW_P_ACC_is_CCFM_ToqRepLArbEnIN_bl_1'
                                     */
boolean_T P_ACC_is_CCFM_ToqRepPCndEnIN_bl = 1;
                                    /* Variable: P_ACC_is_CCFM_ToqRepPCndEnIN_bl
                                     * Referenced by: '<S949>/FW_P_ACC_is_CCFM_ToqRepPCndEnIN_bl_1'
                                     */
boolean_T P_ACC_is_CCFM_ToqRespErrIN_bl = 1;
                                      /* Variable: P_ACC_is_CCFM_ToqRespErrIN_bl
                                       * Referenced by: '<S940>/FW_P_ACC_is_CCFM_ToqRespErrIN_bl_1'
                                       */
boolean_T P_ACC_is_CCFM_ToqRespLArbIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_ToqRespLArbIN_bl
                                      * Referenced by: '<S949>/FW_P_ACC_is_CCFM_ToqRespLArbIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_ToqRespNReqIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_ToqRespNReqIN_bl
                                      * Referenced by: '<S949>/FW_P_ACC_is_CCFM_ToqRespNReqIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_ToqRespPCndIN_bl = 1;
                                     /* Variable: P_ACC_is_CCFM_ToqRespPCndIN_bl
                                      * Referenced by: '<S949>/FW_P_ACC_is_CCFM_ToqRespPCndIN_bl_1'
                                      */
boolean_T P_ACC_is_CCFM_TrCCCanclIN_bl = 1;/* Variable: P_ACC_is_CCFM_TrCCCanclIN_bl
                                            * Referenced by: '<S957>/FW_P_ACC_is_CCFM_TrCCCanclIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_VSEActvEnIN_bl = 1;/* Variable: P_ACC_is_CCFM_VSEActvEnIN_bl
                                            * Referenced by: '<S976>/FW_P_ACC_is_CCFM_VSEActvIN_bl_2'
                                            */
boolean_T P_ACC_is_CCFM_VSEActvIN_bl = 1;/* Variable: P_ACC_is_CCFM_VSEActvIN_bl
                                          * Referenced by: '<S976>/FW_P_ACC_is_CCFM_VSEActvIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_VSEMdOffIN_bl = 1;/* Variable: P_ACC_is_CCFM_VSEMdOffIN_bl
                                           * Referenced by: '<S943>/FW_P_ACC_is_CCFM_VSEMdOffIN_bl_1'
                                           */
boolean_T P_ACC_is_CCFM_VSEStsFltIN_bl = 1;/* Variable: P_ACC_is_CCFM_VSEStsFltIN_bl
                                            * Referenced by: '<S940>/FW_P_ACC_is_CCFM_VSEStsFltIN_bl_1'
                                            */
boolean_T P_ACC_is_CCFM_VehSdslIN_bl = 1;/* Variable: P_ACC_is_CCFM_VehSdslIN_bl
                                          * Referenced by: '<S935>/FW_P_ACC_is_CCFM_VehSdslIN_bl_1'
                                          */
boolean_T P_ACC_is_CCFM_VehSpdOvrIN_bl = 1;/* Variable: P_ACC_is_CCFM_VehSpdOvrIN_bl
                                            * Referenced by: '<S979>/FW_P_ACC_is_CCFM_VehSpdOvrIN_bl_1'
                                            */
boolean_T P_ACC_is_FullGasPdlExitEnbl_bl = 1;
                                     /* Variable: P_ACC_is_FullGasPdlExitEnbl_bl
                                      * Referenced by: '<S909>/P_ACC_t_SetSpdActvThrs_sg7'
                                      * Function configuration parameter
                                        Fuction(Full gas pedal Exit) open or not
                                        0 close 1 open

                                      */
boolean_T P_ACC_is_HMIDISMemSpdChgEnBrkO_bl = 1;
                                  /* Variable: P_ACC_is_HMIDISMemSpdChgEnBrkO_bl
                                   * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg11'
                                   * 1 SET Decerese Speed ON
                                     0 SET Decerese Speed OFF
                                   */
boolean_T P_ACC_is_HMIDISMemSpdChgEnSdby_bl = 0;
                                  /* Variable: P_ACC_is_HMIDISMemSpdChgEnSdby_bl
                                   * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg9'
                                   * 1 SET Decerese Speed ON
                                     0 SET Decerese Speed OFF
                                   */
boolean_T P_ACC_is_HMIDISMemSpdChgEnStslW_bl = 1;
                                 /* Variable: P_ACC_is_HMIDISMemSpdChgEnStslW_bl
                                  * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg12'
                                  * 1 SET Decerese Speed ON
                                    0 SET Decerese Speed OFF
                                  */
boolean_T P_ACC_is_HMIDISSetSpdChgEnOvrd_bl = 1;
                                  /* Variable: P_ACC_is_HMIDISSetSpdChgEnOvrd_bl
                                   * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg5'
                                   * 1 SET Decerese Speed ON
                                     0 SET Decerese Speed OFF
                                   */
boolean_T P_ACC_is_HMIDISSetSpdChgEnStslA_bl = 1;
                                 /* Variable: P_ACC_is_HMIDISSetSpdChgEnStslA_bl
                                  * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg6'
                                  * 1 SET Decerese Speed ON
                                    0 SET Decerese Speed OFF
                                  */
boolean_T P_ACC_is_HMIDISSetSpdSetEnOvrd_bl = 1;
                                  /* Variable: P_ACC_is_HMIDISSetSpdSetEnOvrd_bl
                                   * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg7'
                                   * 1 SET Decerese Speed ON
                                     0 SET Decerese Speed OFF
                                   */
boolean_T P_ACC_is_HMIDISSetSpdSetEnStslA_bl = 0;
                                 /* Variable: P_ACC_is_HMIDISSetSpdSetEnStslA_bl
                                  * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg8'
                                  * 1 SET Decerese Speed ON
                                    0 SET Decerese Speed OFF
                                  */
boolean_T P_ACC_is_HMIRSMActvFstStdByConfig_bl = 0;
                               /* Variable: P_ACC_is_HMIRSMActvFstStdByConfig_bl
                                * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg10'
                                * 0x0  set MemSpd in Standby OFF
                                  0x1  set MemSpd in Standby ON
                                */
boolean_T P_ACC_is_HMIResumeIncSpdConfig_bl = 0;
                                  /* Variable: P_ACC_is_HMIResumeIncSpdConfig_bl
                                   * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1'
                                   * 0x0  Resume speed +1 OFF
                                     0x1  Resume speed +1 ON
                                   */
boolean_T P_ACC_is_HMISETDecSpdConfig_bl = 0;
                                     /* Variable: P_ACC_is_HMISETDecSpdConfig_bl
                                      * Referenced by: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
                                      * 1 SET Decerese Speed ON
                                        0 SET Decerese Speed OFF
                                      */
boolean_T P_ACC_is_HMITJAMaxSpdConfigOpn_bl = 1;
                                  /* Variable: P_ACC_is_HMITJAMaxSpdConfigOpn_bl
                                   * Referenced by:
                                   *   '<S999>/P_ACC_v_MaxCrsSpdThrs_u3'
                                   *   '<S999>/P_ACC_v_MaxCrsSpdThrs_u5'
                                   * 1  Open TJA Speed
                                     0 CLose TJA Speed
                                   */
boolean_T P_ACC_is_SMRTgtLosPrtctWarnOn_bl = 1;
                                   /* Variable: P_ACC_is_SMRTgtLosPrtctWarnOn_bl
                                    * Referenced by: '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg2'
                                    */
boolean_T P_ACC_is_VIDPConfgACCIn_bl = 1;/* Variable: P_ACC_is_VIDPConfgACCIn_bl
                                          * Referenced by: '<S926>/P_DFIn_t_VSELongtAccelFilter4'
                                          */
boolean_T P_ACC_is_VIDPIPKSpdUseEstdVal_bl = 0;
                                   /* Variable: P_ACC_is_VIDPIPKSpdUseEstdVal_bl
                                    * Referenced by: '<S1061>/Constant'
                                    */
boolean_T P_ADS_is_EnASSStaConfig_bl = 0;/* Variable: P_ADS_is_EnASSStaConfig_bl
                                          * Referenced by: '<S1031>/Constant4'
                                          * 0 Engine
                                            1 Electric Motor
                                          */
boolean_T P_ADS_is_EngTypIsMotorConfig_bl = 1;
                                    /* Variable: P_ADS_is_EngTypIsMotorConfig_bl
                                     * Referenced by: '<S1031>/P_DFIn_perc_AccelPosHysDelt_sg2'
                                     * 0 Engine
                                       1 Electric Motor
                                     */
boolean_T P_DFIn_is_CCFM_BntStsStdstlExit_bl = 1;
                                 /* Variable: P_DFIn_is_CCFM_BntStsStdstlExit_bl
                                  * Referenced by: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u11'
                                  */
boolean_T P_DFIn_is_CCFM_FrDoorStdstlExit_bl = 0;
                                 /* Variable: P_DFIn_is_CCFM_FrDoorStdstlExit_bl
                                  * Referenced by: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u6'
                                  */
boolean_T P_DFIn_is_CCFM_LdSpcStsStdstlExit_bl = 1;
                               /* Variable: P_DFIn_is_CCFM_LdSpcStsStdstlExit_bl
                                * Referenced by: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u13'
                                */
boolean_T P_DFIn_is_CCFM_RLDoorStdstlExit_bl = 0;
                                 /* Variable: P_DFIn_is_CCFM_RLDoorStdstlExit_bl
                                  * Referenced by: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u8'
                                  */
boolean_T P_DFIn_is_CCFM_RRDoorStdstlExit_bl = 0;
                                 /* Variable: P_DFIn_is_CCFM_RRDoorStdstlExit_bl
                                  * Referenced by: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u10'
                                  */
boolean_T k_TRPLon_is_FTCBMDsrdDistMdOn_bl = 1;
                                   /* Variable: k_TRPLon_is_FTCBMDsrdDistMdOn_bl
                                    * Referenced by: '<S179>/character3'
                                    */
boolean_T k_TRPLon_is_UsePrdctTime_bl = 0;/* Variable: k_TRPLon_is_UsePrdctTime_bl
                                           * Referenced by: '<S226>/Constant4'
                                           */
boolean_T k_TRPLon_is_Use_dst_target_bl = 1;
                                      /* Variable: k_TRPLon_is_Use_dst_target_bl
                                       * Referenced by: '<S137>/Constant4'
                                       */
boolean_T k_TRPLon_is_UsedDesire0_bl = 0;/* Variable: k_TRPLon_is_UsedDesire0_bl
                                          * Referenced by: '<S148>/Constant3'
                                          */
boolean_T k_TRPLon_is_UsedDesire1_bl = 0;/* Variable: k_TRPLon_is_UsedDesire1_bl
                                          * Referenced by: '<S148>/Constant1'
                                          */
uint8_T P_ACC_V_HMIMinCrsSetSpd_u8 = 30U;/* Variable: P_ACC_V_HMIMinCrsSetSpd_u8
                                          * Referenced by: '<S999>/P_ACC_V_MinCrsSetSpd_sg'
                                          * Set Cruise Speed Minimum Value
                                          */
uint8_T P_ACC_V_HMISETBtnDecMax_u8 = 5U;/* Variable: P_ACC_V_HMISETBtnDecMax_u8
                                         * Referenced by: '<S999>/P_ACC_cntr_SETBtnDecFunc_u8'
                                         * Speed difference Threshold
                                           for Set Button active Decrease Speed function

                                         */
uint8_T P_ACC_V_MaxACCActvSpd_u8 = 160U;/* Variable: P_ACC_V_MaxACCActvSpd_u8
                                         * Referenced by: '<S979>/Constant4'
                                         * The maximum cruise speed, Unit Km/h.
                                           20191022 Change the Parameter name from P_ACC_V_MaxCrsSpd_u8 to P_ACC_V_MaxACCActvSpd_u8
                                           change the value 150->160(Aptiv CRD1.7)
                                         */
uint8_T P_ACC_V_MinCrsSpd_u8 = 0U;     /* Variable: P_ACC_V_MinCrsSpd_u8
                                        * Referenced by: '<S909>/ACC_SSM'
                                        * The minimum Activation Speed; only if larger than this value,
                                          can the system be activated.

                                        */
uint8_T P_ACC_indx_HMIDISSpdSwChgRng_u8 = 5U;
                                    /* Variable: P_ACC_indx_HMIDISSpdSwChgRng_u8
                                     * Referenced by: '<S999>/P_DFIn_t_VSELongtAccelFilter1'
                                     */
uint8_T P_ACC_indx_HMIIniCruzTmDist_u8 = 3U;
                                     /* Variable: P_ACC_indx_HMIIniCruzTmDist_u8
                                      * Referenced by: '<S1000>/P_DFIn_indx_ACCTmDist_u8'
                                      * /+Time Distance_1 means 1sec, 2 means 1.5sec and 3 means 2 secs+/
                                        20191025 change to 3 based on CRD
                                      */
uint8_T P_ACC_v_HMIMinCrsSpdThrs_u8 = 0U;/* Variable: P_ACC_v_HMIMinCrsSpdThrs_u8
                                          * Referenced by: '<S999>/P_VDC_ACC_v_MinCrsSpdThrs_u3'
                                          * The minimum Activation Speed; only if larger than this value,
                                            can the system be activated.
                                          */
uint8_T P_ACC_v_SMRMinCrsSpdThrs_u8 = 0U;/* Variable: P_ACC_v_SMRMinCrsSpdThrs_u8
                                          * Referenced by:
                                          *   '<S909>/ACC_SSM'
                                          *   '<S909>/P_VDC_ACC_v_MinCrsSpdThrs_u8'
                                          */

/* Block signals (default storage) */
B_app_T app_B;

/* Block states (default storage) */
DW_app_T app_DW;

/* Previous zero-crossings (trigger) states */
PrevZCX_app_T app_PrevZCX;

/* Real-time model */
static RT_MODEL_app_T app_M_;
RT_MODEL_app_T *const app_M = &app_M_;

/* Forward declaration for local functions */
static void app_exit_internal_ACC_Active(void);
static void app_ACC_Active(const ePWR_PwrMd *DataTypeConversion19, const
  real32_T *DataTypeConversion28, const eBPL_BrkPdlApl *DataTypeConversion30,
  const boolean_T *DFIn_is_CCFMReversibleFlt_bl, const boolean_T
  *LogicalOperator1, const uint16_T *P_ACC_cntr_FTCAutoGoTm_u16);
static void app_MemSpdInc_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_MemSpdInc_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_MemSpdDec_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_MemSpdDec_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void DISSts_Standby_BrkOnly_StslWait_Fault(const uint16_T
  *DFIn_V_VIDPEstdEgoVehSpdIPK_u16, const real32_T *DataTypeConversion28, const
  boolean_T *ACC_is_DISMemSpdChgEnbl_bl, const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_SpeedInc_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_SpeedInc_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_SpeedDec_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_SpeedDec_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8);
static void app_DISSts_Active(const uint16_T *DFIn_V_VIDPEstdEgoVehSpdIPK_u16,
  const boolean_T *LogicalOperator, const boolean_T *ACC_is_DISSetSpdChgEnbl_bl,
  const boolean_T *ACC_is_DISSetSpdSetEnbl_bl, const uint8_T
  *P_ACC_V_MaxCrsSpdThrs_u8, const boolean_T *ACC_is_TJAOvrSpd_bl);
static void app_enter_internal_ACCPtMd_Norm(const eVLD_ValidSts
  *DataTypeConversion49, const eTRP_TrShftPtrn *DataTypeConversion50, const
  boolean_T *DFIn_is_VIDPTrShftLvrPosEn_bl);
real32_T look1_iflf_binlcpw(real32_T u0, const real32_T bp0[], const real32_T
  table[], uint32_T maxIndex)
{
  real32_T frac;
  real32_T yL_0d0;
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex >> 1U);
    iLeft = 0U;
    iRght = maxIndex;
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex - 1U);
    frac = 1.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'portable wrapping'
   */
  yL_0d0 = table[iLeft];
  return (table[(uint32_T)(iLeft + 1U)] - yL_0d0) * frac + yL_0d0;
}

real_T look2_binlcpw(real_T u0, real_T u1, const real_T bp0[], const real_T bp1[],
                     const real_T table[], const uint32_T maxIndex[], uint32_T
                     stride)
{
  real_T fractions[2];
  real_T frac;
  real_T yL_0d0;
  real_T yL_0d1;
  uint32_T bpIndices[2];
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0;
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex[0U] >> 1U);
    iLeft = 0U;
    iRght = maxIndex[0U];
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex[0U] - 1U);
    frac = 1.0;
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = 0.0;
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex[1U] >> 1U);
    iLeft = 0U;
    iRght = maxIndex[1U];
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u1 - bp1[iLeft]) / (bp1[(uint32_T)(iLeft + 1U)] - bp1[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex[1U] - 1U);
    frac = 1.0;
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'portable wrapping'
   */
  bpIdx = (uint32_T)((uint32_T)(iLeft * stride) + bpIndices[0U]);
  yL_0d0 = table[bpIdx];
  yL_0d0 += (table[(uint32_T)(bpIdx + 1U)] - yL_0d0) * fractions[0U];
  bpIdx += stride;
  yL_0d1 = table[bpIdx];
  return (((table[(uint32_T)(bpIdx + 1U)] - yL_0d1) * fractions[0U] + yL_0d1) -
          yL_0d0) * frac + yL_0d0;
}

real_T look1_binlcpw(real_T u0, const real_T bp0[], const real_T table[],
                     uint32_T maxIndex)
{
  real_T frac;
  real_T yL_0d0;
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex >> 1U);
    iLeft = 0U;
    iRght = maxIndex;
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex - 1U);
    frac = 1.0;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'portable wrapping'
   */
  yL_0d0 = table[iLeft];
  return (table[(uint32_T)(iLeft + 1U)] - yL_0d0) * frac + yL_0d0;
}

real32_T look1_iflf_binlxpw(real32_T u0, const real32_T bp0[], const real32_T
  table[], uint32_T maxIndex)
{
  real32_T frac;
  real32_T yL_0d0;
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Linear'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Linear'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex >> 1U);
    iLeft = 0U;
    iRght = maxIndex;
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex - 1U);
    frac = (u0 - bp0[(uint32_T)(maxIndex - 1U)]) / (bp0[maxIndex] - bp0
      [(uint32_T)(maxIndex - 1U)]);
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'portable wrapping'
   */
  yL_0d0 = table[iLeft];
  return (table[(uint32_T)(iLeft + 1U)] - yL_0d0) * frac + yL_0d0;
}

real32_T look2_iflf_binlxpw(real32_T u0, real32_T u1, const real32_T bp0[],
  const real32_T bp1[], const real32_T table[], const uint32_T maxIndex[],
  uint32_T stride)
{
  real32_T fractions[2];
  real32_T frac;
  real32_T yL_0d0;
  real32_T yL_0d1;
  uint32_T bpIndices[2];
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 2-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Linear'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Linear'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);
  } else if (u0 < bp0[maxIndex[0U]]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex[0U] >> 1U);
    iLeft = 0U;
    iRght = maxIndex[0U];
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex[0U] - 1U);
    frac = (u0 - bp0[(uint32_T)(maxIndex[0U] - 1U)]) / (bp0[maxIndex[0U]] - bp0
      [(uint32_T)(maxIndex[0U] - 1U)]);
  }

  fractions[0U] = frac;
  bpIndices[0U] = iLeft;

  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Linear'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'off'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u1 <= bp1[0U]) {
    iLeft = 0U;
    frac = (u1 - bp1[0U]) / (bp1[1U] - bp1[0U]);
  } else if (u1 < bp1[maxIndex[1U]]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex[1U] >> 1U);
    iLeft = 0U;
    iRght = maxIndex[1U];
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u1 < bp1[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u1 - bp1[iLeft]) / (bp1[(uint32_T)(iLeft + 1U)] - bp1[iLeft]);
  } else {
    iLeft = (uint32_T)(maxIndex[1U] - 1U);
    frac = (u1 - bp1[(uint32_T)(maxIndex[1U] - 1U)]) / (bp1[maxIndex[1U]] - bp1
      [(uint32_T)(maxIndex[1U] - 1U)]);
  }

  /* Column-major Interpolation 2-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'off'
     Overflow mode: 'portable wrapping'
   */
  bpIdx = (uint32_T)((uint32_T)(iLeft * stride) + bpIndices[0U]);
  yL_0d0 = table[bpIdx];
  yL_0d0 += (table[(uint32_T)(bpIdx + 1U)] - yL_0d0) * fractions[0U];
  bpIdx += stride;
  yL_0d1 = table[bpIdx];
  return (((table[(uint32_T)(bpIdx + 1U)] - yL_0d1) * fractions[0U] + yL_0d1) -
          yL_0d0) * frac + yL_0d0;
}

real32_T look1_iflf_binlcapw(real32_T u0, const real32_T bp0[], const real32_T
  table[], uint32_T maxIndex)
{
  real32_T frac;
  real32_T y;
  real32_T yL_0d0;
  uint32_T bpIdx;
  uint32_T iLeft;
  uint32_T iRght;

  /* Column-major Lookup 1-D
     Search method: 'binary'
     Use previous index: 'off'
     Interpolation method: 'Linear point-slope'
     Extrapolation method: 'Clip'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  /* Prelookup - Index and Fraction
     Index Search method: 'binary'
     Extrapolation method: 'Clip'
     Use previous index: 'off'
     Use last breakpoint for index at or above upper limit: 'on'
     Remove protection against out-of-range input in generated code: 'off'
   */
  if (u0 <= bp0[0U]) {
    iLeft = 0U;
    frac = 0.0F;
  } else if (u0 < bp0[maxIndex]) {
    /* Binary Search */
    bpIdx = (uint32_T)(maxIndex >> 1U);
    iLeft = 0U;
    iRght = maxIndex;
    while ((uint32_T)(iRght - iLeft) > 1U) {
      if (u0 < bp0[bpIdx]) {
        iRght = bpIdx;
      } else {
        iLeft = bpIdx;
      }

      bpIdx = (uint32_T)((uint32_T)(iRght + iLeft) >> 1U);
    }

    frac = (u0 - bp0[iLeft]) / (bp0[(uint32_T)(iLeft + 1U)] - bp0[iLeft]);
  } else {
    iLeft = maxIndex;
    frac = 0.0F;
  }

  /* Column-major Interpolation 1-D
     Interpolation method: 'Linear point-slope'
     Use last breakpoint for index at or above upper limit: 'on'
     Overflow mode: 'portable wrapping'
   */
  if (iLeft == maxIndex) {
    y = table[iLeft];
  } else {
    yL_0d0 = table[iLeft];
    y = (table[(uint32_T)(iLeft + 1U)] - yL_0d0) * frac + yL_0d0;
  }

  return y;
}

/*
 * Output and update for atomic system:
 *    '<S75>/Chart3'
 *    '<S75>/Chart4'
 */
void app_Chart3(boolean_T rtu_strLmpSig, boolean_T *rty_is_steerLampOn_bl,
                DW_Chart3_app_T *localDW)
{
  uint32_T tmp;

  /* Chart: '<S75>/Chart3' */
  if ((uint32_T)localDW->is_active_c110_app == 0U) {
    localDW->is_active_c110_app = 1U;
    localDW->is_c110_app = app_IN_OFF;
    *rty_is_steerLampOn_bl = false;
    localDW->is_OFF = app_IN_Zero;
    localDW->local_count = 0U;
  } else if (localDW->is_c110_app == app_IN_OFF) {
    *rty_is_steerLampOn_bl = false;
    if (localDW->is_OFF == app_IN_UP) {
      if ((int32_T)localDW->tm_count > 100) {
        localDW->is_OFF = app_IN_Zero;
        localDW->local_count = 0U;
      } else if ((int32_T)localDW->local_count > 1) {
        localDW->is_OFF = app_IN_NO_ACTIVE_CHILD;
        localDW->is_c110_app = app_IN_ON;
        localDW->local_count = 1U;
        *rty_is_steerLampOn_bl = true;
      } else if (rtu_strLmpSig) {
        tmp = (uint32_T)((uint32_T)localDW->local_count + 1U);
        if ((uint32_T)((uint32_T)localDW->local_count + 1U) > 65535U) {
          tmp = 65535U;
        }

        localDW->local_count = (uint16_T)tmp;
        localDW->tm_count = 0U;
      } else {
        tmp = (uint32_T)((uint32_T)localDW->tm_count + 1U);
        if ((uint32_T)((uint32_T)localDW->tm_count + 1U) > 65535U) {
          tmp = 65535U;
        }

        localDW->tm_count = (uint16_T)tmp;
      }
    } else {
      /* case IN_Zero: */
      if (rtu_strLmpSig) {
        localDW->is_OFF = app_IN_UP;
        localDW->local_count = 1U;
        localDW->tm_count = 0U;
      }
    }
  } else {
    /* case IN_ON: */
    *rty_is_steerLampOn_bl = true;
    if ((!rtu_strLmpSig) && ((int32_T)localDW->local_count > 100)) {
      localDW->is_c110_app = app_IN_OFF;
      *rty_is_steerLampOn_bl = false;
      localDW->is_OFF = app_IN_Zero;
      localDW->local_count = 0U;
    } else if (!rtu_strLmpSig) {
      tmp = (uint32_T)((uint32_T)localDW->local_count + 1U);
      if ((uint32_T)((uint32_T)localDW->local_count + 1U) > 65535U) {
        tmp = 65535U;
      }

      localDW->local_count = (uint16_T)tmp;
    } else {
      localDW->local_count = 0U;
    }
  }

  /* End of Chart: '<S75>/Chart3' */
}

/*
 * Output and update for atomic system:
 *    '<S97>/Chart'
 *    '<S1214>/Chart'
 *    '<S1249>/Chart'
 *    '<S1281>/Chart'
 *    '<S1291>/Chart'
 */
void app_Chart(boolean_T rtu_Arb_is_LatCtrlActv_bl, real32_T *rty_ramp_cof,
               DW_Chart_app_T *localDW)
{
  /* Chart: '<S97>/Chart' */
  if ((uint32_T)localDW->is_active_c45_app == 0U) {
    localDW->is_active_c45_app = 1U;
    localDW->is_c45_app = app_IN_OFF_m;
    *rty_ramp_cof = 0.0F;
  } else {
    switch (localDW->is_c45_app) {
     case app_IN_OFF_m:
      if (rtu_Arb_is_LatCtrlActv_bl) {
        localDW->is_c45_app = app_IN_ON_Count;
        *rty_ramp_cof = 0.0F;
      }
      break;

     case app_IN_OFF_Count:
      if ((!rtu_Arb_is_LatCtrlActv_bl) && (*rty_ramp_cof <= 0.01F)) {
        localDW->is_c45_app = app_IN_OFF_m;
        *rty_ramp_cof = 0.0F;
      } else if (rtu_Arb_is_LatCtrlActv_bl && (*rty_ramp_cof >= 0.99F)) {
        localDW->is_c45_app = app_IN_ON_f;
        *rty_ramp_cof = 1.0F;
      } else if (rtu_Arb_is_LatCtrlActv_bl) {
        *rty_ramp_cof += 0.02F;
      } else {
        *rty_ramp_cof -= 0.05F;
      }
      break;

     case app_IN_ON_f:
      if (!rtu_Arb_is_LatCtrlActv_bl) {
        localDW->is_c45_app = app_IN_OFF_Count;
        *rty_ramp_cof = 1.0F;
      }
      break;

     default:
      /* case IN_ON_Count: */
      if (rtu_Arb_is_LatCtrlActv_bl && (*rty_ramp_cof >= 0.99F)) {
        localDW->is_c45_app = app_IN_ON_f;
        *rty_ramp_cof = 1.0F;
      } else if ((!rtu_Arb_is_LatCtrlActv_bl) && (*rty_ramp_cof <= 0.01F)) {
        localDW->is_c45_app = app_IN_OFF_m;
        *rty_ramp_cof = 0.0F;
      } else if (rtu_Arb_is_LatCtrlActv_bl) {
        *rty_ramp_cof += 0.02F;
      } else {
        *rty_ramp_cof -= 0.05F;
      }
      break;
    }
  }

  /* End of Chart: '<S97>/Chart' */
}

/* System initialize for atomic system: '<S117>/Debounce_Module' */
void app_Debounce_Module_Init(boolean_T *rty_Out)
{
  /* SystemInitialize for Chart: '<S128>/Debounce_Module' */
  *rty_Out = false;
}

/* Output and update for atomic system: '<S117>/Debounce_Module' */
boolean_T app_Debounce_Module(boolean_T rtu_In, real32_T rtu_RiseTimeLmt,
  real32_T rtu_FallTimeLmt, real32_T rtu_MainLoop_Time, DW_Debounce_Module_app_T
  *localDW)
{
  /* Chart: '<S128>/Debounce_Module' */
  if ((int32_T)localDW->InPrev < (int32_T)rtu_In) {
    localDW->fallInternTimeVal = 0.0F;
    if (localDW->riseInternTimeVal < rtu_RiseTimeLmt) {
      localDW->riseInternTimeVal += rtu_MainLoop_Time;
    } else {
      localDW->riseInternTimeVal = 0.0F;
      localDW->InPrev = true;
    }
  } else if ((int32_T)localDW->InPrev > (int32_T)rtu_In) {
    localDW->riseInternTimeVal = 0.0F;
    if (localDW->fallInternTimeVal < rtu_FallTimeLmt) {
      localDW->fallInternTimeVal += rtu_MainLoop_Time;
    } else {
      localDW->fallInternTimeVal = 0.0F;
      localDW->InPrev = false;
    }
  } else {
    localDW->riseInternTimeVal = 0.0F;
    localDW->fallInternTimeVal = 0.0F;
    localDW->InPrev = rtu_In;
  }

  return localDW->InPrev;

  /* End of Chart: '<S128>/Debounce_Module' */
}

/* Output and update for atomic system: '<S102>/Vehicle_LongtResist_Estimate' */
real32_T app_Vehicle_LongtResist_Estimate(real32_T rtu_DFIn_v_EgoAvgVehSpd_sg,
  real32_T rtu_ARB_a_RSEEstdSlopeVal_sg)
{
  /* Sum: '<S120>/Add1' incorporates:
   *  Constant: '<S120>/Air_Area'
   *  Constant: '<S120>/Air_Density'
   *  Constant: '<S120>/Air_Resistance_Ratio1'
   *  Constant: '<S120>/Mass_AS22_20T1'
   *  Constant: '<S120>/Mass_AS22_20T6'
   *  Constant: '<S120>/Rolling_Resistance1'
   *  Constant: '<S120>/Rolling_Resistance2'
   *  Constant: '<S120>/gravity'
   *  Gain: '<S120>/air_resistance_ratio'
   *  Product: '<S120>/Product3'
   *  Product: '<S120>/Product4'
   *  Product: '<S120>/Product6'
   *  Product: '<S120>/Product7'
   *  Product: '<S120>/Square_Speed'
   *  Sum: '<S120>/Add4'
   */
  return ((rtu_DFIn_v_EgoAvgVehSpd_sg * C_ADS_Gx_VehRollResistCmp_sg + 0.02F) *
          (C_ADS_M_VehMass_sg * 9.18F) + C_ADS_M_VehMass_sg *
          rtu_ARB_a_RSEEstdSlopeVal_sg) + C_ADS_Gx_AirResistRatio_sg *
    C_ARB_ro_AirDensity_sg * C_ADS_A_VehAirArea_sg * (rtu_DFIn_v_EgoAvgVehSpd_sg
    * rtu_DFIn_v_EgoAvgVehSpd_sg) * 0.5F;
}

/*
 * Output and update for atomic system: '<S157>/SfD'
 * Block description for: '<S157>/SfD'
 *   Safe Divide
 */
void app_SfD(real32_T rtu_Num_In, real32_T *rty_Divide_Out, const
             ConstB_SfD_app_T *localC, real32_T rtp_Den_In_Min)
{
  /* Switch: '<S160>/Switch' incorporates:
   *  Constant: '<S160>/Constant'
   *  RelationalOperator: '<S160>/Relational Operator'
   */
  if (localC->Abs >= rtp_Den_In_Min) {
    *rty_Divide_Out = localC->Abs;
  } else {
    *rty_Divide_Out = rtp_Den_In_Min;
  }

  /* End of Switch: '<S160>/Switch' */

  /* Product: '<S160>/Multiply' incorporates:
   *  Product: '<S160>/Divide'
   */
  *rty_Divide_Out = rtu_Num_In / *rty_Divide_Out * localC->Sign;
}

/*
 * System initialize for atomic system:
 *    '<S189>/EnDRL1'
 *    '<S190>/EnDRL'
 *    '<S191>/EnDRL'
 */
void app_EnDRL_Init(DW_EnDRL_app_T *localDW)
{
  /* InitializeConditions for Delay: '<S194>/Resettable Delay' */
  localDW->icLoad = 1U;
}

/*
 * Output and update for atomic system:
 *    '<S189>/EnDRL1'
 *    '<S190>/EnDRL'
 *    '<S191>/EnDRL'
 */
void app_EnDRL(real32_T rtu_In, real32_T rtu_IC, boolean_T rtu_Ena, real32_T
               rtu_Up, real32_T rtu_Lo, real32_T *rty_Out, DW_EnDRL_app_T
               *localDW, ZCE_EnDRL_app_T *localZCE, real32_T rtp_MainLoop_Time)
{
  real32_T rtb_Add_by;
  real32_T rtb_Product1_nz;

  /* Delay: '<S194>/Resettable Delay' */
  if (rtu_Ena && (localZCE->ResettableDelay_Reset_ZCE_h != POS_ZCSIG)) {
    localDW->icLoad = 1U;
  }

  localZCE->ResettableDelay_Reset_ZCE_h = (ZCSigState)rtu_Ena;
  if ((int32_T)localDW->icLoad != 0) {
    localDW->ResettableDelay_DSTATE = rtu_IC;
  }

  /* Switch: '<S194>/Switch' incorporates:
   *  Delay: '<S194>/Resettable Delay'
   *  Sum: '<S194>/Add1'
   */
  if (rtu_Ena) {
    /* Sum: '<S194>/Add' incorporates:
     *  Delay: '<S194>/Resettable Delay'
     */
    rtb_Add_by = rtu_In - localDW->ResettableDelay_DSTATE;

    /* Product: '<S194>/Product' incorporates:
     *  Constant: '<S194>/Constant'
     */
    rtb_Product1_nz = rtu_Up * rtp_MainLoop_Time;

    /* Switch: '<S195>/Switch2' incorporates:
     *  RelationalOperator: '<S195>/LowerRelop1'
     */
    if (!(rtb_Add_by > rtb_Product1_nz)) {
      /* Product: '<S194>/Product1' incorporates:
       *  Constant: '<S194>/Constant'
       */
      rtb_Product1_nz = rtp_MainLoop_Time * rtu_Lo;

      /* Switch: '<S195>/Switch' incorporates:
       *  RelationalOperator: '<S195>/UpperRelop'
       */
      if (!(rtb_Add_by < rtb_Product1_nz)) {
        rtb_Product1_nz = rtb_Add_by;
      }

      /* End of Switch: '<S195>/Switch' */
    }

    /* End of Switch: '<S195>/Switch2' */
    *rty_Out = rtb_Product1_nz + localDW->ResettableDelay_DSTATE;
  } else {
    *rty_Out = rtu_In;
  }

  /* End of Switch: '<S194>/Switch' */

  /* Update for Delay: '<S194>/Resettable Delay' */
  localDW->icLoad = 0U;
  localDW->ResettableDelay_DSTATE = *rty_Out;
}

/*
 * System initialize for atomic system:
 *    '<S187>/LowPass_Filter'
 *    '<S187>/LowPass_Filter1'
 *    '<S139>/LowPass_Filter'
 *    '<S497>/LowPass_Filter'
 */
void app_LowPass_Filter_Init(DW_LowPass_Filter_app_T *localDW)
{
  /* InitializeConditions for Delay: '<S214>/Resettable Delay2' */
  localDW->icLoad = 1U;

  /* InitializeConditions for Delay: '<S214>/Resettable Delay1' */
  localDW->icLoad_f = 1U;
}

/*
 * Output and update for atomic system:
 *    '<S187>/LowPass_Filter'
 *    '<S187>/LowPass_Filter1'
 *    '<S139>/LowPass_Filter'
 *    '<S497>/LowPass_Filter'
 */
void app_LowPass_Filter(real32_T rtu_Signal_Input, real32_T *rty_Signal_Output,
  DW_LowPass_Filter_app_T *localDW, real32_T rtp_LPF_CrossoverPoint_Hz, real32_T
  rtp_LPF_SampFrequency_Num)
{
  real32_T rtb_Product2_mo;
  real32_T rtb_ResettableDelay1_n_tmp;

  /* Gain: '<S216>/pi' incorporates:
   *  Constant: '<S216>/fc'
   *  Gain: '<S217>/pi'
   *  Gain: '<S218>/pi1'
   */
  rtb_ResettableDelay1_n_tmp = 3.14159274F * rtp_LPF_CrossoverPoint_Hz;

  /* Product: '<S214>/Product2' incorporates:
   *  Constant: '<S217>/fs'
   *  Product: '<S217>/Divide'
   *  Sum: '<S217>/Add'
   */
  rtb_Product2_mo = rtb_ResettableDelay1_n_tmp / (rtb_ResettableDelay1_n_tmp +
    rtp_LPF_SampFrequency_Num) * rtu_Signal_Input;

  /* Delay: '<S214>/Resettable Delay2' */
  if ((int32_T)localDW->icLoad != 0) {
    localDW->ResettableDelay2_DSTATE = rtb_Product2_mo;
  }

  /* Delay: '<S214>/Resettable Delay1' */
  if ((int32_T)localDW->icLoad_f != 0) {
    localDW->ResettableDelay1_DSTATE = rtu_Signal_Input;
  }

  /* Sum: '<S214>/Sum1' incorporates:
   *  Constant: '<S216>/fs'
   *  Constant: '<S218>/fs'
   *  Delay: '<S214>/Resettable Delay1'
   *  Delay: '<S214>/Resettable Delay2'
   *  Gain: '<S216>/pi'
   *  Product: '<S214>/Product'
   *  Product: '<S214>/Product1'
   *  Product: '<S216>/Divide'
   *  Product: '<S218>/Divide1'
   *  Sum: '<S214>/Sum2'
   *  Sum: '<S216>/Add'
   *  Sum: '<S218>/Add1'
   *  Sum: '<S218>/Add2'
   */
  *rty_Signal_Output = (rtb_ResettableDelay1_n_tmp / (rtb_ResettableDelay1_n_tmp
    + rtp_LPF_SampFrequency_Num) * rtu_Signal_Input +
                        localDW->ResettableDelay2_DSTATE) -
    (rtb_ResettableDelay1_n_tmp - rtp_LPF_SampFrequency_Num) /
    (rtb_ResettableDelay1_n_tmp + rtp_LPF_SampFrequency_Num) *
    localDW->ResettableDelay1_DSTATE;

  /* Update for Delay: '<S214>/Resettable Delay2' */
  localDW->icLoad = 0U;
  localDW->ResettableDelay2_DSTATE = rtb_Product2_mo;

  /* Update for Delay: '<S214>/Resettable Delay1' */
  localDW->icLoad_f = 0U;
  localDW->ResettableDelay1_DSTATE = *rty_Signal_Output;
}

/*
 * Output and update for atomic system:
 *    '<S139>/Trggr_Hyst'
 *    '<S139>/Trggr_Hyst1'
 *    '<S139>/Trggr_Hyst2'
 */
void app_Trggr_Hyst(real32_T rtu_In_Sig, real32_T rtu_Up, real32_T rtu_Low,
                    boolean_T *rty_True_False, DW_Trggr_Hyst_app_T *localDW)
{
  /* Switch: '<S227>/Switch' incorporates:
   *  Constant: '<S227>/Constant'
   *  RelationalOperator: '<S227>/Relational Operator'
   *  RelationalOperator: '<S227>/Relational Operator1'
   *  UnitDelay: '<S227>/Unit Delay'
   */
  if (rtu_In_Sig >= rtu_Up) {
    *rty_True_False = true;
  } else {
    *rty_True_False = ((!(rtu_In_Sig < rtu_Low)) && localDW->UnitDelay_DSTATE);
  }

  /* End of Switch: '<S227>/Switch' */

  /* Update for UnitDelay: '<S227>/Unit Delay' */
  localDW->UnitDelay_DSTATE = *rty_True_False;
}

/*
 * System initialize for atomic system:
 *    '<S238>/Chart'
 *    '<S501>/Chart'
 */
void app_Chart_n_Init(eRPL_RePlanLevel *rty_TRP_Replan_Level)
{
  *rty_TRP_Replan_Level = RPL_Disable;
}

/*
 * Output and update for atomic system:
 *    '<S238>/Chart'
 *    '<S501>/Chart'
 */
void app_Chart_b(boolean_T rtu_is_RwPilotActv_bl, boolean_T
                 rtu_RCD_is_InitCondFlf_bl, boolean_T
                 rtu_RCD_is_ReplanCondFlf_bl, boolean_T
                 rtu_RCD_is_NormCondFlf_bl, eRPL_RePlanLevel
                 *rty_TRP_Replan_Level)
{
  /* Chart: '<S238>/Chart' */
  if (rtu_is_RwPilotActv_bl) {
    if (rtu_RCD_is_InitCondFlf_bl) {
      *rty_TRP_Replan_Level = RPL_Init;
    } else if (rtu_RCD_is_ReplanCondFlf_bl) {
      *rty_TRP_Replan_Level = RPL_RePlan;
    } else if (rtu_RCD_is_NormCondFlf_bl) {
      *rty_TRP_Replan_Level = RPL_Normal;
    } else {
      *rty_TRP_Replan_Level = RPL_KeepTrj;
    }
  } else {
    *rty_TRP_Replan_Level = RPL_Disable;
  }

  /* End of Chart: '<S238>/Chart' */
}

/*
 * Output and update for atomic system:
 *    '<S483>/Chart1'
 *    '<S501>/Chart1'
 *    '<S501>/Chart2'
 */
void app_Chart1(boolean_T rtu_input, real32_T rtu_k_TRP_t_ReplnTm_sg, real32_T
                rtu_c_TRP_t_MainLoopTm_sg, boolean_T *rty_output,
                DW_Chart1_app_T *localDW)
{
  /* Chart: '<S483>/Chart1' */
  if ((uint32_T)localDW->is_active_c71_app == 0U) {
    localDW->is_active_c71_app = 1U;
    localDW->is_c71_app = app_IN_Update;
    *rty_output = rtu_input;
  } else if (localDW->is_c71_app == app_IN_Keep) {
    if (localDW->Tm >= rtu_k_TRP_t_ReplnTm_sg) {
      localDW->is_c71_app = app_IN_Update;
      *rty_output = rtu_input;
    } else {
      *rty_output = false;
      localDW->Tm += rtu_c_TRP_t_MainLoopTm_sg;
    }
  } else {
    /* case IN_Update: */
    if (rtu_input) {
      localDW->is_c71_app = app_IN_Keep;
      *rty_output = true;
      localDW->Tm = 0.0F;
    } else {
      *rty_output = false;
    }
  }

  /* End of Chart: '<S483>/Chart1' */
}

real32_T rt_powf_snf(real32_T u0, real32_T u1)
{
  real32_T tmp;
  real32_T tmp_0;
  real32_T y;
  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {
    y = (rtNaNF);
  } else {
    tmp = fabsf(u0);
    tmp_0 = fabsf(u1);
    if (rtIsInfF(u1)) {
      if (tmp == 1.0F) {
        y = 1.0F;
      } else if (tmp > 1.0F) {
        if (u1 > 0.0F) {
          y = (rtInfF);
        } else {
          y = 0.0F;
        }
      } else if (u1 > 0.0F) {
        y = 0.0F;
      } else {
        y = (rtInfF);
      }
    } else if (tmp_0 == 0.0F) {
      y = 1.0F;
    } else if (tmp_0 == 1.0F) {
      if (u1 > 0.0F) {
        y = u0;
      } else {
        y = 1.0F / u0;
      }
    } else if (u1 == 2.0F) {
      y = u0 * u0;
    } else if ((u1 == 0.5F) && (u0 >= 0.0F)) {
      y = sqrtf(u0);
    } else if ((u0 < 0.0F) && (u1 > floorf(u1))) {
      y = (rtNaNF);
    } else {
      y = powf(u0, u1);
    }
  }

  return y;
}

/*
 * Output and update for atomic system:
 *    '<S261>/MATLAB Function'
 *    '<S279>/MATLAB Function'
 *    '<S333>/MATLAB Function'
 *    '<S351>/MATLAB Function'
 *    '<S369>/MATLAB Function'
 *    '<S387>/MATLAB Function'
 */
void app_MATLABFunction(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T *rty_Ax_Max_New, real32_T
  *rty_Ax_Min_New, real32_T *rty_t_Ax_Extrem1_New, real32_T
  *rty_t_Ax_Extrem2_New, real32_T *rty_Ax_Extrem1_New, real32_T
  *rty_Ax_Extrem2_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[4];
  real32_T Delta;
  real32_T b_A;
  real32_T ex;
  real32_T t_Ax_Extrem1_New_tmp;
  real32_T t_Ax_Extrem2_New;
  boolean_T exitg1;
  boolean_T tmp;
  b_A = rtu_c5 / 2.0F;
  Delta = rtu_c4 * rtu_c4 - 4.0F * b_A * rtu_c3;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      t_Ax_Extrem1_New_tmp = sqrtf(Delta);
      Delta = (-rtu_c4 + t_Ax_Extrem1_New_tmp) / (2.0F * b_A);
      t_Ax_Extrem2_New = (-rtu_c4 - t_Ax_Extrem1_New_tmp) / (2.0F * b_A);
    } else {
      Delta = rtu_t_end;
      t_Ax_Extrem2_New = rtu_t_end;
    }
  } else if (rtu_c4 != 0.0F) {
    Delta = -rtu_c3 / rtu_c4;
    t_Ax_Extrem2_New = Delta;
  } else {
    Delta = rtu_t_end;
    t_Ax_Extrem2_New = rtu_t_end;
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  if (t_Ax_Extrem2_New < 0.0F) {
    t_Ax_Extrem2_New = 0.0F;
  } else {
    if (t_Ax_Extrem2_New > rtu_t_end) {
      t_Ax_Extrem2_New = rtu_t_end;
    }
  }

  t_Ax_Extrem1_New_tmp = ((rtu_c3 * Delta + rtu_a0) + rtu_c4 / 2.0F * (Delta *
    Delta)) + rtu_c5 / 6.0F * rt_powf_snf(Delta, 3.0F);
  b_A = ((rtu_c3 * t_Ax_Extrem2_New + rtu_a0) + rtu_c4 / 2.0F *
         (t_Ax_Extrem2_New * t_Ax_Extrem2_New)) + rtu_c5 / 6.0F * rt_powf_snf
    (t_Ax_Extrem2_New, 3.0F);
  varargin_1_tmp[0] = ((rtu_c3 * 0.0F + rtu_a0) + rtu_c4 / 2.0F * 0.0F) + rtu_c5
    / 6.0F * 0.0F;
  varargin_1_tmp[1] = t_Ax_Extrem1_New_tmp;
  varargin_1_tmp[2] = b_A;
  varargin_1_tmp[3] = ((rtu_c3 * rtu_t_end + rtu_a0) + rtu_c4 / 2.0F *
                       (rtu_t_end * rtu_t_end)) + rtu_c5 / 6.0F * rt_powf_snf
    (rtu_t_end, 3.0F);
  tmp = rtIsNaNF(varargin_1_tmp[0]);
  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_Ax_Max_New = varargin_1_tmp[0];
  } else {
    ex = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (ex < varargin_1_tmp[idx]) {
        ex = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_Ax_Max_New = ex;
  }

  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_Ax_Min_New = varargin_1_tmp[0];
  } else {
    ex = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (ex > varargin_1_tmp[idx]) {
        ex = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_Ax_Min_New = ex;
  }

  *rty_t_Ax_Extrem1_New = Delta;
  *rty_t_Ax_Extrem2_New = t_Ax_Extrem2_New;
  *rty_Ax_Extrem1_New = t_Ax_Extrem1_New_tmp;
  *rty_Ax_Extrem2_New = b_A;
}

/*
 * Output and update for atomic system:
 *    '<S263>/MATLAB Function'
 *    '<S281>/MATLAB Function'
 *    '<S335>/MATLAB Function'
 *    '<S353>/MATLAB Function'
 *    '<S371>/MATLAB Function'
 *    '<S389>/MATLAB Function'
 */
void app_MATLABFunction_f(real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0,
  real32_T rtu_s0, real32_T *rty_c5, real32_T *rty_c4, real32_T *rty_c3)
{
  int32_T r1;
  int32_T r2;
  int32_T r3;
  int32_T rtemp;
  real32_T M[9];
  real32_T O[3];
  real32_T M_tmp;
  real32_T M_tmp_0;
  real32_T M_tmp_tmp;
  real32_T maxval;
  maxval = 0.166666672F * rt_powf_snf(rtu_t_end, 3.0F);
  M[0] = maxval;
  M_tmp = 0.0416666679F * rt_powf_snf(rtu_t_end, 4.0F);
  M[3] = M_tmp;
  M[6] = 0.00833333377F * rt_powf_snf(rtu_t_end, 5.0F);
  M_tmp_tmp = rtu_t_end * rtu_t_end;
  M_tmp_0 = M_tmp_tmp * 0.5F;
  M[1] = M_tmp_0;
  M[4] = maxval;
  M[7] = M_tmp;
  M[2] = rtu_t_end;
  M[5] = M_tmp_0;
  M[8] = maxval;
  O[0] = (-rtu_s0 - rtu_v0 * rtu_t_end) - rtu_a0 / 2.0F * M_tmp_tmp;
  O[1] = -rtu_v0 - rtu_a0 * rtu_t_end;
  O[2] = -rtu_a0;
  r1 = 0;
  r2 = 1;
  r3 = 2;
  maxval = fabsf(maxval);
  M_tmp_0 = fabsf(M_tmp_0);
  if (M_tmp_0 > maxval) {
    maxval = M_tmp_0;
    r1 = 1;
    r2 = 0;
  }

  if (fabsf(rtu_t_end) > maxval) {
    r1 = 2;
    r2 = 1;
    r3 = 0;
  }

  M[r2] /= M[r1];
  M[r3] /= M[r1];
  M[(int32_T)(r2 + 3)] -= M[(int32_T)(r1 + 3)] * M[r2];
  M[(int32_T)(r3 + 3)] -= M[(int32_T)(r1 + 3)] * M[r3];
  M[(int32_T)(r2 + 6)] -= M[(int32_T)(r1 + 6)] * M[r2];
  M[(int32_T)(r3 + 6)] -= M[(int32_T)(r1 + 6)] * M[r3];
  if (fabsf(M[(int32_T)(r3 + 3)]) > fabsf(M[(int32_T)(r2 + 3)])) {
    rtemp = r2;
    r2 = r3;
    r3 = rtemp;
  }

  M[(int32_T)(r3 + 3)] /= M[(int32_T)(r2 + 3)];
  M[(int32_T)(r3 + 6)] -= M[(int32_T)(r3 + 3)] * M[(int32_T)(r2 + 6)];
  maxval = O[r2] - O[r1] * M[r2];
  M_tmp_0 = ((O[r3] - O[r1] * M[r3]) - M[(int32_T)(r3 + 3)] * maxval) / M
    [(int32_T)(r3 + 6)];
  *rty_c5 = M_tmp_0;
  maxval -= M[(int32_T)(r2 + 6)] * M_tmp_0;
  maxval /= M[(int32_T)(r2 + 3)];
  *rty_c4 = maxval;
  *rty_c3 = ((O[r1] - M[(int32_T)(r1 + 6)] * M_tmp_0) - M[(int32_T)(r1 + 3)] *
             maxval) / M[r1];
}

/*
 * Output and update for atomic system:
 *    '<S264>/MATLAB Function'
 *    '<S282>/MATLAB Function'
 *    '<S336>/MATLAB Function'
 *    '<S354>/MATLAB Function'
 *    '<S372>/MATLAB Function'
 *    '<S390>/MATLAB Function'
 */
void app_MATLABFunction_g(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T *rty_Jerk_Max_New, real32_T *rty_Jerk_Min_New,
  real32_T *rty_t_Jerk_Extrem_New, real32_T *rty_Jerk_Extrem_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[3];
  real32_T Jerk_Extrem_New_tmp;
  real32_T ex;
  real32_T t_Jerk_Extrem_New;
  boolean_T exitg1;
  boolean_T tmp;
  if (rtu_c5 != 0.0F) {
    t_Jerk_Extrem_New = -rtu_c4 / rtu_c5;
    if (t_Jerk_Extrem_New < 0.0F) {
      t_Jerk_Extrem_New = 0.0F;
    } else {
      if (t_Jerk_Extrem_New > rtu_t_end) {
        t_Jerk_Extrem_New = rtu_t_end;
      }
    }

    Jerk_Extrem_New_tmp = (rtu_c4 * t_Jerk_Extrem_New + rtu_c3) + rtu_c5 / 2.0F *
      (t_Jerk_Extrem_New * t_Jerk_Extrem_New);
    if ((t_Jerk_Extrem_New <= 0.0F) || (t_Jerk_Extrem_New >= rtu_t_end)) {
      *rty_Jerk_Max_New = fmaxf((rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F,
        (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F * (rtu_t_end * rtu_t_end));
      *rty_Jerk_Min_New = fminf((rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F,
        (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F * (rtu_t_end * rtu_t_end));
    } else {
      varargin_1_tmp[0] = (rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F;
      varargin_1_tmp[1] = Jerk_Extrem_New_tmp;
      varargin_1_tmp[2] = (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F *
        (rtu_t_end * rtu_t_end);
      tmp = rtIsNaNF(varargin_1_tmp[0]);
      if (!tmp) {
        idx = 1;
      } else {
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k < 4)) {
          if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        *rty_Jerk_Max_New = varargin_1_tmp[0];
      } else {
        ex = varargin_1_tmp[(int32_T)(idx - 1)];
        while ((int32_T)(idx + 1) < 4) {
          if (ex < varargin_1_tmp[idx]) {
            ex = varargin_1_tmp[idx];
          }

          idx++;
        }

        *rty_Jerk_Max_New = ex;
      }

      if (!tmp) {
        idx = 1;
      } else {
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k < 4)) {
          if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        *rty_Jerk_Min_New = varargin_1_tmp[0];
      } else {
        ex = varargin_1_tmp[(int32_T)(idx - 1)];
        while ((int32_T)(idx + 1) < 4) {
          if (ex > varargin_1_tmp[idx]) {
            ex = varargin_1_tmp[idx];
          }

          idx++;
        }

        *rty_Jerk_Min_New = ex;
      }
    }
  } else {
    t_Jerk_Extrem_New = 0.0F;
    Jerk_Extrem_New_tmp = (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F *
      (rtu_t_end * rtu_t_end);
    ex = (rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F;
    *rty_Jerk_Max_New = fmaxf(ex, Jerk_Extrem_New_tmp);
    *rty_Jerk_Min_New = fminf(ex, Jerk_Extrem_New_tmp);
  }

  *rty_t_Jerk_Extrem_New = t_Jerk_Extrem_New;
  *rty_Jerk_Extrem_New = Jerk_Extrem_New_tmp;
}

/*
 * Output and update for atomic system:
 *    '<S266>/MATLAB Function'
 *    '<S284>/MATLAB Function'
 *    '<S338>/MATLAB Function'
 *    '<S356>/MATLAB Function'
 *    '<S374>/MATLAB Function'
 *    '<S392>/MATLAB Function'
 */
void app_MATLABFunction_p(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T *rty_JerkSqIntg_t_end)
{
  *rty_JerkSqIntg_t_end = (((rtu_c5 * rtu_c5 / 20.0F * rt_powf_snf(rtu_t_end,
    5.0F) + rtu_c5 * rtu_c4 / 4.0F * rt_powf_snf(rtu_t_end, 4.0F)) + (rtu_c4 *
    rtu_c4 + rtu_c5 * rtu_c3) / 3.0F * rt_powf_snf(rtu_t_end, 3.0F)) + rtu_c3 *
    rtu_c4 * (rtu_t_end * rtu_t_end)) + rtu_c3 * rtu_c3 * rtu_t_end;
}

/*
 * Output and update for atomic system:
 *    '<S267>/MATLAB Function'
 *    '<S285>/MATLAB Function'
 *    '<S339>/MATLAB Function'
 *    '<S357>/MATLAB Function'
 *    '<S375>/MATLAB Function'
 *    '<S393>/MATLAB Function'
 */
void app_MATLABFunction_gv(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0, real32_T rtu_s0,
  real32_T *rty_S_Max, real32_T *rty_S_Min, real32_T *rty_t_Sx_Extrem1_New,
  real32_T *rty_t_Sx_Extrem2_New, real32_T *rty_Sx_Extrem1_New, real32_T
  *rty_Sx_Extrem2_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[4];
  real32_T Delta;
  real32_T b_A;
  real32_T b_B;
  real32_T b_C;
  real32_T b_C_tmp;
  boolean_T exitg1;
  boolean_T tmp;
  b_A = rtu_c5 / 24.0F;
  b_B = 2.0F * b_A * rtu_t_end + rtu_c4 / 6.0F;
  b_C_tmp = rtu_t_end * rtu_t_end;
  b_C = rtu_v0 / b_C_tmp;
  Delta = b_B * b_B - 4.0F * b_A * b_C;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      Delta = sqrtf(Delta);
      b_C = (-b_B + Delta) / (2.0F * b_A);
      Delta = (-b_B - Delta) / (2.0F * b_A);
    } else {
      b_C = rtu_t_end;
      Delta = rtu_t_end;
    }
  } else if (b_B != 0.0F) {
    b_C = -b_C / b_B;
    Delta = b_C;
  } else {
    b_C = rtu_t_end;
    Delta = rtu_t_end;
  }

  if (b_C < 0.0F) {
    b_C = 0.0F;
  } else {
    if (b_C > rtu_t_end) {
      b_C = rtu_t_end;
    }
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  b_B = ((((rtu_v0 * b_C + rtu_s0) + rtu_a0 / 2.0F * (b_C * b_C)) + rtu_c3 /
          6.0F * rt_powf_snf(b_C, 3.0F)) + rtu_c4 / 24.0F * rt_powf_snf(b_C,
          4.0F)) + rtu_c5 / 120.0F * rt_powf_snf(b_C, 5.0F);
  b_A = ((((rtu_v0 * Delta + rtu_s0) + rtu_a0 / 2.0F * (Delta * Delta)) + rtu_c3
          / 6.0F * rt_powf_snf(Delta, 3.0F)) + rtu_c4 / 24.0F * rt_powf_snf
         (Delta, 4.0F)) + rtu_c5 / 120.0F * rt_powf_snf(Delta, 5.0F);
  varargin_1_tmp[0] = ((((rtu_v0 * 0.0F + rtu_s0) + rtu_a0 / 2.0F * 0.0F) +
                        rtu_c3 / 6.0F * 0.0F) + rtu_c4 / 24.0F * 0.0F) + rtu_c5 /
    120.0F * 0.0F;
  varargin_1_tmp[1] = b_B;
  varargin_1_tmp[2] = b_A;
  varargin_1_tmp[3] = ((((rtu_v0 * rtu_t_end + rtu_s0) + rtu_a0 / 2.0F * b_C_tmp)
                        + rtu_c3 / 6.0F * rt_powf_snf(rtu_t_end, 3.0F)) + rtu_c4
                       / 24.0F * rt_powf_snf(rtu_t_end, 4.0F)) + rtu_c5 / 120.0F
    * rt_powf_snf(rtu_t_end, 5.0F);
  tmp = rtIsNaNF(varargin_1_tmp[0]);
  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_S_Max = varargin_1_tmp[0];
  } else {
    b_C_tmp = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (b_C_tmp < varargin_1_tmp[idx]) {
        b_C_tmp = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_S_Max = b_C_tmp;
  }

  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_S_Min = varargin_1_tmp[0];
  } else {
    b_C_tmp = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (b_C_tmp > varargin_1_tmp[idx]) {
        b_C_tmp = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_S_Min = b_C_tmp;
  }

  *rty_t_Sx_Extrem1_New = b_C;
  *rty_t_Sx_Extrem2_New = Delta;
  *rty_Sx_Extrem1_New = b_B;
  *rty_Sx_Extrem2_New = b_A;
}

/*
 * Output and update for atomic system:
 *    '<S268>/MATLAB Function'
 *    '<S286>/MATLAB Function'
 *    '<S340>/MATLAB Function'
 *    '<S358>/MATLAB Function'
 *    '<S376>/MATLAB Function'
 *    '<S394>/MATLAB Function'
 */
void app_MATLABFunction_m(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0, real32_T
  *rty_V_max_overshoot, real32_T *rty_t_Vx_Extrem1_New, real32_T
  *rty_t_Vx_Extrem2_New, real32_T *rty_Vx_Extrem1_New, real32_T
  *rty_Vx_Extrem2_New)
{
  real32_T Delta;
  real32_T V_end;
  real32_T V_start;
  real32_T b_A;
  real32_T b_B;
  real32_T b_C;
  real32_T tmp;
  b_A = rtu_c5 / 6.0F;
  b_B = rtu_c4 / 2.0F + b_A * rtu_t_end;
  b_C = b_B * rtu_t_end + rtu_c3;
  Delta = b_B * b_B - 4.0F * b_A * b_C;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      Delta = sqrtf(Delta);
      b_C = (-b_B + Delta) / (2.0F * b_A);
      Delta = (-b_B - Delta) / (2.0F * b_A);
    } else {
      b_C = rtu_t_end;
      Delta = rtu_t_end;
    }
  } else if (b_B != 0.0F) {
    b_C = -b_C / b_B;
    Delta = b_C;
  } else {
    b_C = rtu_t_end;
    Delta = rtu_t_end;
  }

  if (b_C < 0.0F) {
    b_C = 0.0F;
  } else {
    if (b_C > rtu_t_end) {
      b_C = rtu_t_end;
    }
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  V_start = (((rtu_a0 * 0.0F + rtu_v0) + rtu_c3 / 2.0F * 0.0F) + rtu_c4 / 6.0F *
             0.0F) + rtu_c5 / 24.0F * 0.0F;
  V_end = (((rtu_a0 * rtu_t_end + rtu_v0) + rtu_c3 / 2.0F * (rtu_t_end *
             rtu_t_end)) + rtu_c4 / 6.0F * rt_powf_snf(rtu_t_end, 3.0F)) +
    rtu_c5 / 24.0F * rt_powf_snf(rtu_t_end, 4.0F);
  b_B = (((rtu_a0 * b_C + rtu_v0) + rtu_c3 / 2.0F * (b_C * b_C)) + rtu_c4 / 6.0F
         * rt_powf_snf(b_C, 3.0F)) + rtu_c5 / 24.0F * rt_powf_snf(b_C, 4.0F);
  b_A = (((rtu_a0 * Delta + rtu_v0) + rtu_c3 / 2.0F * (Delta * Delta)) + rtu_c4 /
         6.0F * rt_powf_snf(Delta, 3.0F)) + rtu_c5 / 24.0F * rt_powf_snf(Delta,
    4.0F);
  tmp = fmaxf(V_start, V_end);
  V_start = fminf(V_start, V_end);
  *rty_V_max_overshoot = fmaxf(fmaxf(0.0F, fmaxf(b_B - tmp, b_A - tmp)), fabsf
    (fminf(0.0F, fminf(b_B - V_start, b_A - V_start))));
  *rty_t_Vx_Extrem1_New = b_C;
  *rty_t_Vx_Extrem2_New = Delta;
  *rty_Vx_Extrem1_New = b_B;
  *rty_Vx_Extrem2_New = b_A;
}

/*
 * Output and update for atomic system:
 *    '<S297>/MATLAB Function'
 *    '<S315>/MATLAB Function'
 *    '<S405>/MATLAB Function'
 *    '<S423>/MATLAB Function'
 *    '<S441>/MATLAB Function'
 *    '<S459>/MATLAB Function'
 */
void app_MATLABFunction_a(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T *rty_Ax_Max_New, real32_T
  *rty_Ax_Min_New, real32_T *rty_t_Ax_Extrem1_New, real32_T
  *rty_t_Ax_Extrem2_New, real32_T *rty_Ax_Extrem1_New, real32_T
  *rty_Ax_Extrem2_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[4];
  real32_T Delta;
  real32_T b_A;
  real32_T ex;
  real32_T t_Ax_Extrem1_New_tmp;
  real32_T t_Ax_Extrem2_New;
  boolean_T exitg1;
  boolean_T tmp;
  b_A = rtu_c5 / 2.0F;
  Delta = rtu_c4 * rtu_c4 - 4.0F * b_A * rtu_c3;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      t_Ax_Extrem1_New_tmp = sqrtf(Delta);
      Delta = (-rtu_c4 + t_Ax_Extrem1_New_tmp) / (2.0F * b_A);
      t_Ax_Extrem2_New = (-rtu_c4 - t_Ax_Extrem1_New_tmp) / (2.0F * b_A);
    } else {
      Delta = rtu_t_end;
      t_Ax_Extrem2_New = rtu_t_end;
    }
  } else if (rtu_c4 != 0.0F) {
    Delta = -rtu_c3 / rtu_c4;
    t_Ax_Extrem2_New = Delta;
  } else {
    Delta = rtu_t_end;
    t_Ax_Extrem2_New = rtu_t_end;
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  if (t_Ax_Extrem2_New < 0.0F) {
    t_Ax_Extrem2_New = 0.0F;
  } else {
    if (t_Ax_Extrem2_New > rtu_t_end) {
      t_Ax_Extrem2_New = rtu_t_end;
    }
  }

  t_Ax_Extrem1_New_tmp = ((rtu_c3 * Delta + rtu_a0) + rtu_c4 / 2.0F * (Delta *
    Delta)) + rtu_c5 / 6.0F * rt_powf_snf(Delta, 3.0F);
  b_A = ((rtu_c3 * t_Ax_Extrem2_New + rtu_a0) + rtu_c4 / 2.0F *
         (t_Ax_Extrem2_New * t_Ax_Extrem2_New)) + rtu_c5 / 6.0F * rt_powf_snf
    (t_Ax_Extrem2_New, 3.0F);
  varargin_1_tmp[0] = ((rtu_c3 * 0.0F + rtu_a0) + rtu_c4 / 2.0F * 0.0F) + rtu_c5
    / 6.0F * 0.0F;
  varargin_1_tmp[1] = t_Ax_Extrem1_New_tmp;
  varargin_1_tmp[2] = b_A;
  varargin_1_tmp[3] = ((rtu_c3 * rtu_t_end + rtu_a0) + rtu_c4 / 2.0F *
                       (rtu_t_end * rtu_t_end)) + rtu_c5 / 6.0F * rt_powf_snf
    (rtu_t_end, 3.0F);
  tmp = rtIsNaNF(varargin_1_tmp[0]);
  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_Ax_Max_New = varargin_1_tmp[0];
  } else {
    ex = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (ex < varargin_1_tmp[idx]) {
        ex = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_Ax_Max_New = ex;
  }

  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_Ax_Min_New = varargin_1_tmp[0];
  } else {
    ex = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (ex > varargin_1_tmp[idx]) {
        ex = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_Ax_Min_New = ex;
  }

  *rty_t_Ax_Extrem1_New = Delta;
  *rty_t_Ax_Extrem2_New = t_Ax_Extrem2_New;
  *rty_Ax_Extrem1_New = t_Ax_Extrem1_New_tmp;
  *rty_Ax_Extrem2_New = b_A;
}

/*
 * Output and update for atomic system:
 *    '<S299>/MATLAB Function'
 *    '<S317>/MATLAB Function'
 *    '<S407>/MATLAB Function'
 *    '<S425>/MATLAB Function'
 *    '<S443>/MATLAB Function'
 *    '<S461>/MATLAB Function'
 */
void app_MATLABFunction_gl(real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0,
  real32_T rtu_s0, real32_T *rty_c5, real32_T *rty_c4, real32_T *rty_c3)
{
  int32_T r1;
  int32_T r2;
  int32_T r3;
  int32_T rtemp;
  real32_T M[9];
  real32_T O[3];
  real32_T M_tmp;
  real32_T M_tmp_0;
  real32_T M_tmp_tmp;
  real32_T maxval;
  maxval = 0.166666672F * rt_powf_snf(rtu_t_end, 3.0F);
  M[0] = maxval;
  M_tmp = 0.0416666679F * rt_powf_snf(rtu_t_end, 4.0F);
  M[3] = M_tmp;
  M[6] = 0.00833333377F * rt_powf_snf(rtu_t_end, 5.0F);
  M_tmp_tmp = rtu_t_end * rtu_t_end;
  M_tmp_0 = M_tmp_tmp * 0.5F;
  M[1] = M_tmp_0;
  M[4] = maxval;
  M[7] = M_tmp;
  M[2] = rtu_t_end;
  M[5] = M_tmp_0;
  M[8] = maxval;
  O[0] = (-rtu_s0 - rtu_v0 * rtu_t_end) - rtu_a0 / 2.0F * M_tmp_tmp;
  O[1] = -rtu_v0 - rtu_a0 * rtu_t_end;
  O[2] = -rtu_a0;
  r1 = 0;
  r2 = 1;
  r3 = 2;
  maxval = fabsf(maxval);
  M_tmp_0 = fabsf(M_tmp_0);
  if (M_tmp_0 > maxval) {
    maxval = M_tmp_0;
    r1 = 1;
    r2 = 0;
  }

  if (fabsf(rtu_t_end) > maxval) {
    r1 = 2;
    r2 = 1;
    r3 = 0;
  }

  M[r2] /= M[r1];
  M[r3] /= M[r1];
  M[(int32_T)(r2 + 3)] -= M[(int32_T)(r1 + 3)] * M[r2];
  M[(int32_T)(r3 + 3)] -= M[(int32_T)(r1 + 3)] * M[r3];
  M[(int32_T)(r2 + 6)] -= M[(int32_T)(r1 + 6)] * M[r2];
  M[(int32_T)(r3 + 6)] -= M[(int32_T)(r1 + 6)] * M[r3];
  if (fabsf(M[(int32_T)(r3 + 3)]) > fabsf(M[(int32_T)(r2 + 3)])) {
    rtemp = r2;
    r2 = r3;
    r3 = rtemp;
  }

  M[(int32_T)(r3 + 3)] /= M[(int32_T)(r2 + 3)];
  M[(int32_T)(r3 + 6)] -= M[(int32_T)(r3 + 3)] * M[(int32_T)(r2 + 6)];
  maxval = O[r2] - O[r1] * M[r2];
  M_tmp_0 = ((O[r3] - O[r1] * M[r3]) - M[(int32_T)(r3 + 3)] * maxval) / M
    [(int32_T)(r3 + 6)];
  *rty_c5 = M_tmp_0;
  maxval -= M[(int32_T)(r2 + 6)] * M_tmp_0;
  maxval /= M[(int32_T)(r2 + 3)];
  *rty_c4 = maxval;
  *rty_c3 = ((O[r1] - M[(int32_T)(r1 + 6)] * M_tmp_0) - M[(int32_T)(r1 + 3)] *
             maxval) / M[r1];
}

/*
 * Output and update for atomic system:
 *    '<S300>/MATLAB Function'
 *    '<S318>/MATLAB Function'
 *    '<S408>/MATLAB Function'
 *    '<S426>/MATLAB Function'
 *    '<S444>/MATLAB Function'
 *    '<S462>/MATLAB Function'
 */
void app_MATLABFunction_k(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T *rty_Jerk_Max_New, real32_T *rty_Jerk_Min_New,
  real32_T *rty_t_Jerk_Extrem_New, real32_T *rty_Jerk_Extrem_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[3];
  real32_T Jerk_Extrem_New_tmp;
  real32_T ex;
  real32_T t_Jerk_Extrem_New;
  boolean_T exitg1;
  boolean_T tmp;
  if (rtu_c5 != 0.0F) {
    t_Jerk_Extrem_New = -rtu_c4 / rtu_c5;
    if (t_Jerk_Extrem_New < 0.0F) {
      t_Jerk_Extrem_New = 0.0F;
    } else {
      if (t_Jerk_Extrem_New > rtu_t_end) {
        t_Jerk_Extrem_New = rtu_t_end;
      }
    }

    Jerk_Extrem_New_tmp = (rtu_c4 * t_Jerk_Extrem_New + rtu_c3) + rtu_c5 / 2.0F *
      (t_Jerk_Extrem_New * t_Jerk_Extrem_New);
    if ((t_Jerk_Extrem_New <= 0.0F) || (t_Jerk_Extrem_New >= rtu_t_end)) {
      *rty_Jerk_Max_New = fmaxf((rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F,
        (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F * (rtu_t_end * rtu_t_end));
      *rty_Jerk_Min_New = fminf((rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F,
        (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F * (rtu_t_end * rtu_t_end));
    } else {
      varargin_1_tmp[0] = (rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F;
      varargin_1_tmp[1] = Jerk_Extrem_New_tmp;
      varargin_1_tmp[2] = (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F *
        (rtu_t_end * rtu_t_end);
      tmp = rtIsNaNF(varargin_1_tmp[0]);
      if (!tmp) {
        idx = 1;
      } else {
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k < 4)) {
          if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        *rty_Jerk_Max_New = varargin_1_tmp[0];
      } else {
        ex = varargin_1_tmp[(int32_T)(idx - 1)];
        while ((int32_T)(idx + 1) < 4) {
          if (ex < varargin_1_tmp[idx]) {
            ex = varargin_1_tmp[idx];
          }

          idx++;
        }

        *rty_Jerk_Max_New = ex;
      }

      if (!tmp) {
        idx = 1;
      } else {
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k < 4)) {
          if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        *rty_Jerk_Min_New = varargin_1_tmp[0];
      } else {
        ex = varargin_1_tmp[(int32_T)(idx - 1)];
        while ((int32_T)(idx + 1) < 4) {
          if (ex > varargin_1_tmp[idx]) {
            ex = varargin_1_tmp[idx];
          }

          idx++;
        }

        *rty_Jerk_Min_New = ex;
      }
    }
  } else {
    t_Jerk_Extrem_New = 0.0F;
    Jerk_Extrem_New_tmp = (rtu_c4 * rtu_t_end + rtu_c3) + rtu_c5 / 2.0F *
      (rtu_t_end * rtu_t_end);
    ex = (rtu_c4 * 0.0F + rtu_c3) + rtu_c5 / 2.0F * 0.0F;
    *rty_Jerk_Max_New = fmaxf(ex, Jerk_Extrem_New_tmp);
    *rty_Jerk_Min_New = fminf(ex, Jerk_Extrem_New_tmp);
  }

  *rty_t_Jerk_Extrem_New = t_Jerk_Extrem_New;
  *rty_Jerk_Extrem_New = Jerk_Extrem_New_tmp;
}

/*
 * Output and update for atomic system:
 *    '<S302>/MATLAB Function'
 *    '<S320>/MATLAB Function'
 *    '<S410>/MATLAB Function'
 *    '<S428>/MATLAB Function'
 *    '<S446>/MATLAB Function'
 *    '<S464>/MATLAB Function'
 */
void app_MATLABFunction_k0(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T *rty_JerkSqIntg_t_end)
{
  *rty_JerkSqIntg_t_end = (((rtu_c5 * rtu_c5 / 20.0F * rt_powf_snf(rtu_t_end,
    5.0F) + rtu_c5 * rtu_c4 / 4.0F * rt_powf_snf(rtu_t_end, 4.0F)) + (rtu_c4 *
    rtu_c4 + rtu_c5 * rtu_c3) / 3.0F * rt_powf_snf(rtu_t_end, 3.0F)) + rtu_c3 *
    rtu_c4 * (rtu_t_end * rtu_t_end)) + rtu_c3 * rtu_c3 * rtu_t_end;
}

/*
 * Output and update for atomic system:
 *    '<S303>/MATLAB Function'
 *    '<S321>/MATLAB Function'
 *    '<S411>/MATLAB Function'
 *    '<S429>/MATLAB Function'
 *    '<S447>/MATLAB Function'
 *    '<S465>/MATLAB Function'
 */
void app_MATLABFunction_aa(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0, real32_T rtu_s0,
  real32_T *rty_S_Max, real32_T *rty_S_Min, real32_T *rty_t_Sx_Extrem1_New,
  real32_T *rty_t_Sx_Extrem2_New, real32_T *rty_Sx_Extrem1_New, real32_T
  *rty_Sx_Extrem2_New)
{
  int32_T idx;
  int32_T k;
  real32_T varargin_1_tmp[4];
  real32_T Delta;
  real32_T b_A;
  real32_T b_B;
  real32_T b_C;
  real32_T b_C_tmp;
  boolean_T exitg1;
  boolean_T tmp;
  b_A = rtu_c5 / 24.0F;
  b_B = 2.0F * b_A * rtu_t_end + rtu_c4 / 6.0F;
  b_C_tmp = rtu_t_end * rtu_t_end;
  b_C = rtu_v0 / b_C_tmp;
  Delta = b_B * b_B - 4.0F * b_A * b_C;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      Delta = sqrtf(Delta);
      b_C = (-b_B + Delta) / (2.0F * b_A);
      Delta = (-b_B - Delta) / (2.0F * b_A);
    } else {
      b_C = rtu_t_end;
      Delta = rtu_t_end;
    }
  } else if (b_B != 0.0F) {
    b_C = -b_C / b_B;
    Delta = b_C;
  } else {
    b_C = rtu_t_end;
    Delta = rtu_t_end;
  }

  if (b_C < 0.0F) {
    b_C = 0.0F;
  } else {
    if (b_C > rtu_t_end) {
      b_C = rtu_t_end;
    }
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  b_B = ((((rtu_v0 * b_C + rtu_s0) + rtu_a0 / 2.0F * (b_C * b_C)) + rtu_c3 /
          6.0F * rt_powf_snf(b_C, 3.0F)) + rtu_c4 / 24.0F * rt_powf_snf(b_C,
          4.0F)) + rtu_c5 / 120.0F * rt_powf_snf(b_C, 5.0F);
  b_A = ((((rtu_v0 * Delta + rtu_s0) + rtu_a0 / 2.0F * (Delta * Delta)) + rtu_c3
          / 6.0F * rt_powf_snf(Delta, 3.0F)) + rtu_c4 / 24.0F * rt_powf_snf
         (Delta, 4.0F)) + rtu_c5 / 120.0F * rt_powf_snf(Delta, 5.0F);
  varargin_1_tmp[0] = ((((rtu_v0 * 0.0F + rtu_s0) + rtu_a0 / 2.0F * 0.0F) +
                        rtu_c3 / 6.0F * 0.0F) + rtu_c4 / 24.0F * 0.0F) + rtu_c5 /
    120.0F * 0.0F;
  varargin_1_tmp[1] = b_B;
  varargin_1_tmp[2] = b_A;
  varargin_1_tmp[3] = ((((rtu_v0 * rtu_t_end + rtu_s0) + rtu_a0 / 2.0F * b_C_tmp)
                        + rtu_c3 / 6.0F * rt_powf_snf(rtu_t_end, 3.0F)) + rtu_c4
                       / 24.0F * rt_powf_snf(rtu_t_end, 4.0F)) + rtu_c5 / 120.0F
    * rt_powf_snf(rtu_t_end, 5.0F);
  tmp = rtIsNaNF(varargin_1_tmp[0]);
  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_S_Max = varargin_1_tmp[0];
  } else {
    b_C_tmp = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (b_C_tmp < varargin_1_tmp[idx]) {
        b_C_tmp = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_S_Max = b_C_tmp;
  }

  if (!tmp) {
    idx = 1;
  } else {
    idx = 0;
    k = 2;
    exitg1 = false;
    while ((!exitg1) && (k < 5)) {
      if (!rtIsNaNF(varargin_1_tmp[(int32_T)(k - 1)])) {
        idx = k;
        exitg1 = true;
      } else {
        k++;
      }
    }
  }

  if (idx == 0) {
    *rty_S_Min = varargin_1_tmp[0];
  } else {
    b_C_tmp = varargin_1_tmp[(int32_T)(idx - 1)];
    while ((int32_T)(idx + 1) < 5) {
      if (b_C_tmp > varargin_1_tmp[idx]) {
        b_C_tmp = varargin_1_tmp[idx];
      }

      idx++;
    }

    *rty_S_Min = b_C_tmp;
  }

  *rty_t_Sx_Extrem1_New = b_C;
  *rty_t_Sx_Extrem2_New = Delta;
  *rty_Sx_Extrem1_New = b_B;
  *rty_Sx_Extrem2_New = b_A;
}

/*
 * Output and update for atomic system:
 *    '<S304>/MATLAB Function'
 *    '<S322>/MATLAB Function'
 *    '<S412>/MATLAB Function'
 *    '<S430>/MATLAB Function'
 *    '<S448>/MATLAB Function'
 *    '<S466>/MATLAB Function'
 */
void app_MATLABFunction_n(real32_T rtu_c5, real32_T rtu_c4, real32_T rtu_c3,
  real32_T rtu_t_end, real32_T rtu_a0, real32_T rtu_v0, real32_T
  *rty_V_max_overshoot, real32_T *rty_t_Vx_Extrem1_New, real32_T
  *rty_t_Vx_Extrem2_New, real32_T *rty_Vx_Extrem1_New, real32_T
  *rty_Vx_Extrem2_New)
{
  real32_T Delta;
  real32_T V_end;
  real32_T V_start;
  real32_T b_A;
  real32_T b_B;
  real32_T b_C;
  real32_T tmp;
  b_A = rtu_c5 / 6.0F;
  b_B = rtu_c4 / 2.0F + b_A * rtu_t_end;
  b_C = b_B * rtu_t_end + rtu_c3;
  Delta = b_B * b_B - 4.0F * b_A * b_C;
  if (b_A != 0.0F) {
    if (Delta >= 0.0F) {
      Delta = sqrtf(Delta);
      b_C = (-b_B + Delta) / (2.0F * b_A);
      Delta = (-b_B - Delta) / (2.0F * b_A);
    } else {
      b_C = rtu_t_end;
      Delta = rtu_t_end;
    }
  } else if (b_B != 0.0F) {
    b_C = -b_C / b_B;
    Delta = b_C;
  } else {
    b_C = rtu_t_end;
    Delta = rtu_t_end;
  }

  if (b_C < 0.0F) {
    b_C = 0.0F;
  } else {
    if (b_C > rtu_t_end) {
      b_C = rtu_t_end;
    }
  }

  if (Delta < 0.0F) {
    Delta = 0.0F;
  } else {
    if (Delta > rtu_t_end) {
      Delta = rtu_t_end;
    }
  }

  V_start = (((rtu_a0 * 0.0F + rtu_v0) + rtu_c3 / 2.0F * 0.0F) + rtu_c4 / 6.0F *
             0.0F) + rtu_c5 / 24.0F * 0.0F;
  V_end = (((rtu_a0 * rtu_t_end + rtu_v0) + rtu_c3 / 2.0F * (rtu_t_end *
             rtu_t_end)) + rtu_c4 / 6.0F * rt_powf_snf(rtu_t_end, 3.0F)) +
    rtu_c5 / 24.0F * rt_powf_snf(rtu_t_end, 4.0F);
  b_B = (((rtu_a0 * b_C + rtu_v0) + rtu_c3 / 2.0F * (b_C * b_C)) + rtu_c4 / 6.0F
         * rt_powf_snf(b_C, 3.0F)) + rtu_c5 / 24.0F * rt_powf_snf(b_C, 4.0F);
  b_A = (((rtu_a0 * Delta + rtu_v0) + rtu_c3 / 2.0F * (Delta * Delta)) + rtu_c4 /
         6.0F * rt_powf_snf(Delta, 3.0F)) + rtu_c5 / 24.0F * rt_powf_snf(Delta,
    4.0F);
  tmp = fmaxf(V_start, V_end);
  V_start = fminf(V_start, V_end);
  *rty_V_max_overshoot = fmaxf(fmaxf(0.0F, fmaxf(b_B - tmp, b_A - tmp)), fabsf
    (fminf(0.0F, fminf(b_B - V_start, b_A - V_start))));
  *rty_t_Vx_Extrem1_New = b_C;
  *rty_t_Vx_Extrem2_New = Delta;
  *rty_Vx_Extrem1_New = b_B;
  *rty_Vx_Extrem2_New = b_A;
}

/* Output and update for function-call system: '<S140>/Longt_Dist_Keep' */
void app_Longt_Dist_Keep(real32_T rtu_Traj_Bartch_Out, real32_T
  rtu_Traj_Coff_Batch_Out, real32_T rtu_Traj_Coff_Batch_Out_p, real32_T
  rtu_Traj_Coff_Batch_Out_d, real32_T rtu_Traj_Coff_Batch_Out_o, real32_T
  rtu_Traj_Coff_Batch_Out_c, real32_T rtu_Traj_Coff_Batch_Out_j, real32_T
  rtu_Traj_Coff_Batch_Out_k, real32_T rtu_Traj_Coff_Batch_Out_ce, real32_T
  rtu_Traj_Coff_Batch_Out_b, real32_T rtu_Traj_Coff_Batch_Out_ju, real32_T
  rtu_Traj_Coff_Batch_Out_l, real32_T rtu_Traj_Coff_Batch_Out_h, boolean_T
  rtu_Long_Traj_DistReplan_Flag, real32_T *rty_s_trajFol_rel, real32_T
  *rty_v_trajFol_rel, real32_T *rty_a_trajFol_rel, real32_T *rty_j_trajFol_rel,
  real32_T *rty_t_Fol, real32_T *rty_t_remainFol, real32_T
  *rty_s_trajFol_real_dis, real32_T *rty_v_trajFol_real_dis, real32_T
  *rty_a_trajFol_real_dis, real32_T *rty_jerk_trajFol_real_dis, real32_T
  *rty_s_trajFol_real_dis_predict_one_ste, real32_T
  *rty_v_trajFol_real_dis_predict_one_ste, real32_T
  *rty_a_trajFol_real_dis_prdtOneStp, real32_T
  *rty_jerk_trajFol_real_dis_prdtOneStp, const ConstB_Longt_Dist_Keep_app_T
  *localC, DW_Longt_Dist_Keep_app_T *localDW)
{
  real32_T rtb_Add5_kq;
  real32_T tmp;
  real32_T tmp_0;
  real32_T tmp_1;

  /* Switch: '<S235>/Switch' incorporates:
   *  Constant: '<S235>/Constant'
   *  Constant: '<S235>/CycleTime'
   *  Delay: '<S235>/Resettable Delay'
   *  Sum: '<S235>/Add1'
   */
  if (rtu_Long_Traj_DistReplan_Flag) {
    rtb_Add5_kq = 0.0F;
  } else {
    rtb_Add5_kq = localDW->ResettableDelay_DSTATE + 0.05F;
  }

  /* End of Switch: '<S235>/Switch' */

  /* MinMax: '<S235>/Min' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   */
  localDW->ResettableDelay_DSTATE = fminf(rtu_Traj_Bartch_Out, rtb_Add5_kq);

  /* Sum: '<S235>/Add2' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   */
  *rty_t_remainFol = rtu_Traj_Bartch_Out - localDW->ResettableDelay_DSTATE;

  /* Sum: '<S235>/Add5' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   */
  rtb_Add5_kq = localDW->ResettableDelay_DSTATE + localC->Gain;

  /* MATLAB Function: '<S235>/MATLAB Function1' */
  tmp = rt_powf_snf(rtb_Add5_kq, 3.0F);
  tmp_1 = rtb_Add5_kq * rtb_Add5_kq;

  /* SignalConversion generated from: '<S235>/a_trajFol_real_dis_prdtOneStp' incorporates:
   *  MATLAB Function: '<S235>/MATLAB Function1'
   */
  *rty_a_trajFol_real_dis_prdtOneStp = ((6.0F * rtu_Traj_Coff_Batch_Out_ju *
    rtb_Add5_kq + 2.0F * rtu_Traj_Coff_Batch_Out_b) + 12.0F *
    rtu_Traj_Coff_Batch_Out_l * tmp_1) + 20.0F * rtu_Traj_Coff_Batch_Out_h * tmp;

  /* SignalConversion generated from: '<S235>/jerk_trajFol_real_dis_prdtOneStp' incorporates:
   *  MATLAB Function: '<S235>/MATLAB Function1'
   */
  *rty_jerk_trajFol_real_dis_prdtOneStp = (24.0F * rtu_Traj_Coff_Batch_Out_l *
    rtb_Add5_kq + 6.0F * rtu_Traj_Coff_Batch_Out_ju) + 60.0F *
    rtu_Traj_Coff_Batch_Out_h * tmp_1;

  /* MATLAB Function: '<S235>/MATLAB Function1' */
  tmp_0 = rt_powf_snf(rtb_Add5_kq, 4.0F);

  /* SignalConversion generated from: '<S235>/s_trajFol_real_dis_predict_one_step' incorporates:
   *  MATLAB Function: '<S235>/MATLAB Function1'
   */
  *rty_s_trajFol_real_dis_predict_one_ste = ((((rtu_Traj_Coff_Batch_Out_ce *
    rtb_Add5_kq + rtu_Traj_Coff_Batch_Out_k) + tmp_1 * rtu_Traj_Coff_Batch_Out_b)
    + rtu_Traj_Coff_Batch_Out_ju * tmp) + rtu_Traj_Coff_Batch_Out_l * tmp_0) +
    rtu_Traj_Coff_Batch_Out_h * rt_powf_snf(rtb_Add5_kq, 5.0F);

  /* SignalConversion generated from: '<S235>/v_trajFol_real_dis_predict_one_step' incorporates:
   *  MATLAB Function: '<S235>/MATLAB Function1'
   */
  *rty_v_trajFol_real_dis_predict_one_ste = (((2.0F * rtu_Traj_Coff_Batch_Out_b *
    rtb_Add5_kq + rtu_Traj_Coff_Batch_Out_ce) + 3.0F *
    rtu_Traj_Coff_Batch_Out_ju * tmp_1) + 4.0F * rtu_Traj_Coff_Batch_Out_l * tmp)
    + 5.0F * rtu_Traj_Coff_Batch_Out_h * tmp_0;

  /* SignalConversion generated from: '<S235>/a_trajFol_rel' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function'
   */
  *rty_a_trajFol_rel = ((6.0F * rtu_Traj_Coff_Batch_Out_o *
    localDW->ResettableDelay_DSTATE + 2.0F * rtu_Traj_Coff_Batch_Out_d) + 12.0F *
                        rtu_Traj_Coff_Batch_Out_c *
                        (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE)) + 20.0F * rtu_Traj_Coff_Batch_Out_j *
    rt_powf_snf(localDW->ResettableDelay_DSTATE, 3.0F);

  /* SignalConversion generated from: '<S235>/j_trajFol_rel' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function'
   */
  *rty_j_trajFol_rel = (24.0F * rtu_Traj_Coff_Batch_Out_c *
                        localDW->ResettableDelay_DSTATE + 6.0F *
                        rtu_Traj_Coff_Batch_Out_o) + 60.0F *
    rtu_Traj_Coff_Batch_Out_j * (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE);

  /* SignalConversion generated from: '<S235>/s_trajFol_rel' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function'
   */
  *rty_s_trajFol_rel = ((((rtu_Traj_Coff_Batch_Out_p *
    localDW->ResettableDelay_DSTATE + rtu_Traj_Coff_Batch_Out) +
    localDW->ResettableDelay_DSTATE * localDW->ResettableDelay_DSTATE *
    rtu_Traj_Coff_Batch_Out_d) + rtu_Traj_Coff_Batch_Out_o * rt_powf_snf
    (localDW->ResettableDelay_DSTATE, 3.0F)) + rtu_Traj_Coff_Batch_Out_c *
                        rt_powf_snf(localDW->ResettableDelay_DSTATE, 4.0F)) +
    rtu_Traj_Coff_Batch_Out_j * rt_powf_snf(localDW->ResettableDelay_DSTATE,
    5.0F);

  /* SignalConversion generated from: '<S235>/v_trajFol_rel' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function'
   */
  *rty_v_trajFol_rel = (((2.0F * rtu_Traj_Coff_Batch_Out_d *
    localDW->ResettableDelay_DSTATE + rtu_Traj_Coff_Batch_Out_p) + 3.0F *
    rtu_Traj_Coff_Batch_Out_o * (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE)) + 4.0F * rtu_Traj_Coff_Batch_Out_c *
                        rt_powf_snf(localDW->ResettableDelay_DSTATE, 3.0F)) +
    5.0F * rtu_Traj_Coff_Batch_Out_j * rt_powf_snf
    (localDW->ResettableDelay_DSTATE, 4.0F);

  /* SignalConversion generated from: '<S235>/a_trajFol_real_dis' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function2'
   */
  *rty_a_trajFol_real_dis = ((6.0F * rtu_Traj_Coff_Batch_Out_ju *
    localDW->ResettableDelay_DSTATE + 2.0F * rtu_Traj_Coff_Batch_Out_b) + 12.0F *
    rtu_Traj_Coff_Batch_Out_l * (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE)) + 20.0F * rtu_Traj_Coff_Batch_Out_h *
    rt_powf_snf(localDW->ResettableDelay_DSTATE, 3.0F);

  /* SignalConversion generated from: '<S235>/jerk_trajFol_real_dis' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function2'
   */
  *rty_jerk_trajFol_real_dis = (24.0F * rtu_Traj_Coff_Batch_Out_l *
    localDW->ResettableDelay_DSTATE + 6.0F * rtu_Traj_Coff_Batch_Out_ju) + 60.0F
    * rtu_Traj_Coff_Batch_Out_h * (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE);

  /* SignalConversion generated from: '<S235>/s_trajFol_real_dis' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function2'
   */
  *rty_s_trajFol_real_dis = ((((rtu_Traj_Coff_Batch_Out_ce *
    localDW->ResettableDelay_DSTATE + rtu_Traj_Coff_Batch_Out_k) +
    localDW->ResettableDelay_DSTATE * localDW->ResettableDelay_DSTATE *
    rtu_Traj_Coff_Batch_Out_b) + rtu_Traj_Coff_Batch_Out_ju * rt_powf_snf
    (localDW->ResettableDelay_DSTATE, 3.0F)) + rtu_Traj_Coff_Batch_Out_l *
    rt_powf_snf(localDW->ResettableDelay_DSTATE, 4.0F)) +
    rtu_Traj_Coff_Batch_Out_h * rt_powf_snf(localDW->ResettableDelay_DSTATE,
    5.0F);

  /* SignalConversion generated from: '<S235>/v_trajFol_real_dis' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   *  MATLAB Function: '<S235>/MATLAB Function2'
   */
  *rty_v_trajFol_real_dis = (((2.0F * rtu_Traj_Coff_Batch_Out_b *
    localDW->ResettableDelay_DSTATE + rtu_Traj_Coff_Batch_Out_ce) + 3.0F *
    rtu_Traj_Coff_Batch_Out_ju * (localDW->ResettableDelay_DSTATE *
    localDW->ResettableDelay_DSTATE)) + 4.0F * rtu_Traj_Coff_Batch_Out_l *
    rt_powf_snf(localDW->ResettableDelay_DSTATE, 3.0F)) + 5.0F *
    rtu_Traj_Coff_Batch_Out_h * rt_powf_snf(localDW->ResettableDelay_DSTATE,
    4.0F);

  /* SignalConversion generated from: '<S235>/t_Fol' incorporates:
   *  Delay: '<S235>/Resettable Delay'
   */
  *rty_t_Fol = localDW->ResettableDelay_DSTATE;
}

/*
 * Output and update for atomic system:
 *    '<S497>/SfD'
 *    '<S561>/SfD'
 *    '<S589>/SfD'
 *    '<S617>/SfD'
 *    '<S648>/SfD'
 *    '<S676>/SfD'
 *    '<S704>/SfD'
 *    '<S731>/SfD'
 *    '<S735>/SfD'
 *    '<S759>/SfD'
 *    ...
 * Common block description:
 *   Safe Divide
 */
void app_SfD_i(real32_T rtu_Num_In, real32_T rtu_Den_In, real32_T
               *rty_Divide_Out, real32_T rtp_Den_In_Min)
{
  real32_T rtb_Switch_kr;
  real32_T rtu_Den_In_0;

  /* Abs: '<S506>/Abs' */
  rtb_Switch_kr = fabsf(rtu_Den_In);

  /* Switch: '<S506>/Switch' incorporates:
   *  Constant: '<S506>/Constant'
   *  RelationalOperator: '<S506>/Relational Operator'
   */
  if (!(rtb_Switch_kr >= rtp_Den_In_Min)) {
    rtb_Switch_kr = rtp_Den_In_Min;
  }

  /* End of Switch: '<S506>/Switch' */

  /* Signum: '<S506>/Sign' */
  if (rtu_Den_In < 0.0F) {
    rtu_Den_In_0 = -1.0F;
  } else if (rtu_Den_In > 0.0F) {
    rtu_Den_In_0 = 1.0F;
  } else if (rtu_Den_In == 0.0F) {
    rtu_Den_In_0 = 0.0F;
  } else {
    rtu_Den_In_0 = (rtNaNF);
  }

  /* End of Signum: '<S506>/Sign' */

  /* Product: '<S506>/Multiply' incorporates:
   *  Product: '<S506>/Divide'
   */
  *rty_Divide_Out = rtu_Num_In / rtb_Switch_kr * rtu_Den_In_0;
}

/*
 * Output and update for action system:
 *    '<S554>/If Action Subsystem'
 *    '<S582>/If Action Subsystem'
 *    '<S610>/If Action Subsystem'
 *    '<S641>/If Action Subsystem'
 *    '<S669>/If Action Subsystem'
 *    '<S697>/If Action Subsystem'
 *    '<S728>/If Action Subsystem'
 *    '<S757>/If Action Subsystem'
 *    '<S782>/If Action Subsystem'
 *    '<S811>/If Action Subsystem'
 *    ...
 */
void app_IfActionSubsystem(real32_T rtu_a_extrem1, real32_T rtu_t_extrem1,
  real32_T rtu_t_extrem2, real32_T *rty_Ax_Extrem, real32_T *rty_Ax_Extrem_k,
  real32_T *rty_Ax_Extrem_e, real32_T *rty_Ax_Extrem_el)
{
  /* SignalConversion generated from: '<S562>/Ax_Extrem' */
  *rty_Ax_Extrem = rtu_a_extrem1;

  /* SignalConversion generated from: '<S562>/Ax_Extrem' */
  *rty_Ax_Extrem_k = rtu_a_extrem1;

  /* SignalConversion generated from: '<S562>/Ax_Extrem' */
  *rty_Ax_Extrem_e = rtu_t_extrem1;

  /* SignalConversion generated from: '<S562>/Ax_Extrem' */
  *rty_Ax_Extrem_el = rtu_t_extrem2;
}

/*
 * Output and update for action system:
 *    '<S554>/If Action Subsystem1'
 *    '<S582>/If Action Subsystem1'
 *    '<S610>/If Action Subsystem1'
 *    '<S641>/If Action Subsystem1'
 *    '<S669>/If Action Subsystem1'
 *    '<S697>/If Action Subsystem1'
 *    '<S728>/If Action Subsystem1'
 *    '<S757>/If Action Subsystem1'
 *    '<S782>/If Action Subsystem1'
 *    '<S811>/If Action Subsystem1'
 *    ...
 */
void app_IfActionSubsystem1(real32_T rtu_a_extrem1, real32_T rtu_a_extrem2,
  real32_T rtu_t_extrem1, real32_T *rty_Ax_Extrem, real32_T *rty_Ax_Extrem_m,
  real32_T *rty_Ax_Extrem_l, real32_T *rty_Ax_Extrem_ld)
{
  /* SignalConversion generated from: '<S563>/Ax_Extrem' */
  *rty_Ax_Extrem = rtu_a_extrem1;

  /* SignalConversion generated from: '<S563>/Ax_Extrem' */
  *rty_Ax_Extrem_m = rtu_a_extrem2;

  /* SignalConversion generated from: '<S563>/Ax_Extrem' */
  *rty_Ax_Extrem_l = rtu_t_extrem1;

  /* SignalConversion generated from: '<S563>/Ax_Extrem' */
  *rty_Ax_Extrem_ld = rtu_t_extrem1;
}

/*
 * Output and update for action system:
 *    '<S554>/If Action Subsystem2'
 *    '<S582>/If Action Subsystem2'
 *    '<S610>/If Action Subsystem2'
 *    '<S641>/If Action Subsystem2'
 *    '<S669>/If Action Subsystem2'
 *    '<S697>/If Action Subsystem2'
 *    '<S728>/If Action Subsystem2'
 *    '<S757>/If Action Subsystem2'
 *    '<S782>/If Action Subsystem2'
 *    '<S811>/If Action Subsystem2'
 *    ...
 */
void app_IfActionSubsystem2(real32_T rtu_a_extrem1, real32_T rtu_a_extrem2,
  real32_T rtu_t_extrem1, real32_T rtu_t_extrem2, real32_T *rty_Ax_Extrem,
  real32_T *rty_Ax_Extrem_n, real32_T *rty_Ax_Extrem_n2, real32_T
  *rty_Ax_Extrem_k)
{
  /* SignalConversion generated from: '<S564>/Ax_Extrem' */
  *rty_Ax_Extrem = rtu_a_extrem1;

  /* SignalConversion generated from: '<S564>/Ax_Extrem' */
  *rty_Ax_Extrem_n = rtu_a_extrem2;

  /* SignalConversion generated from: '<S564>/Ax_Extrem' */
  *rty_Ax_Extrem_n2 = rtu_t_extrem2;

  /* SignalConversion generated from: '<S564>/Ax_Extrem' */
  *rty_Ax_Extrem_k = rtu_t_extrem1;
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem'
 *    '<S589>/If Action Subsystem'
 *    '<S617>/If Action Subsystem'
 *    '<S648>/If Action Subsystem'
 *    '<S676>/If Action Subsystem'
 *    '<S704>/If Action Subsystem'
 *    '<S735>/If Action Subsystem'
 *    '<S763>/If Action Subsystem'
 *    '<S789>/If Action Subsystem'
 *    '<S818>/If Action Subsystem'
 *    ...
 */
void app_IfActionSubsystem_c(real32_T rtu_A, real32_T rtu_B, real32_T rtu_Delta,
  real32_T rtu_t_end, real32_T rty_t[2])
{
  real32_T rtb_Divide_bm;
  real32_T rtb_Multiply1;
  real32_T rtb_Switch2_ax;

  /* Product: '<S571>/Multiply1' incorporates:
   *  Constant: '<S571>/Constant1'
   */
  rtb_Multiply1 = 2.0F * rtu_A;

  /* Sqrt: '<S571>/Sqrt' */
  rtb_Switch2_ax = sqrtf(rtu_Delta);

  /* Product: '<S571>/Divide' incorporates:
   *  Product: '<S571>/Multiply'
   *  Sum: '<S571>/Add'
   */
  rtb_Divide_bm = (-rtu_B + rtb_Switch2_ax) / rtb_Multiply1;

  /* Product: '<S571>/Divide1' incorporates:
   *  Product: '<S571>/Multiply'
   *  Sum: '<S571>/Add1'
   */
  rtb_Multiply1 = (-rtu_B - rtb_Switch2_ax) / rtb_Multiply1;

  /* Switch: '<S579>/Switch2' incorporates:
   *  Constant: '<S571>/Constant3'
   *  RelationalOperator: '<S579>/LowerRelop1'
   *  RelationalOperator: '<S579>/UpperRelop'
   *  Switch: '<S579>/Switch'
   */
  if (rtb_Divide_bm > rtu_t_end) {
    /* SignalConversion: '<S571>/Signal Conversion' */
    rty_t[0] = rtu_t_end;
  } else if (rtb_Divide_bm < 0.0F) {
    /* Switch: '<S579>/Switch' incorporates:
     *  Constant: '<S571>/Constant3'
     *  SignalConversion: '<S571>/Signal Conversion'
     */
    rty_t[0] = 0.0F;
  } else {
    /* SignalConversion: '<S571>/Signal Conversion' incorporates:
     *  Switch: '<S579>/Switch'
     */
    rty_t[0] = rtb_Divide_bm;
  }

  /* End of Switch: '<S579>/Switch2' */

  /* Switch: '<S580>/Switch2' incorporates:
   *  Constant: '<S571>/Constant3'
   *  RelationalOperator: '<S580>/LowerRelop1'
   *  RelationalOperator: '<S580>/UpperRelop'
   *  Switch: '<S580>/Switch'
   */
  if (rtb_Multiply1 > rtu_t_end) {
    /* SignalConversion: '<S571>/Signal Conversion' */
    rty_t[1] = rtu_t_end;
  } else if (rtb_Multiply1 < 0.0F) {
    /* Switch: '<S580>/Switch' incorporates:
     *  Constant: '<S571>/Constant3'
     *  SignalConversion: '<S571>/Signal Conversion'
     */
    rty_t[1] = 0.0F;
  } else {
    /* SignalConversion: '<S571>/Signal Conversion' incorporates:
     *  Switch: '<S580>/Switch'
     */
    rty_t[1] = rtb_Multiply1;
  }

  /* End of Switch: '<S580>/Switch2' */
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem1'
 *    '<S589>/If Action Subsystem1'
 *    '<S617>/If Action Subsystem1'
 *    '<S648>/If Action Subsystem1'
 *    '<S676>/If Action Subsystem1'
 *    '<S704>/If Action Subsystem1'
 *    '<S735>/If Action Subsystem1'
 *    '<S763>/If Action Subsystem1'
 *    '<S789>/If Action Subsystem1'
 *    '<S818>/If Action Subsystem1'
 *    ...
 */
void app_IfActionSubsystem1_h(real32_T rtu_B, real32_T rtu_C, real32_T rtu_t_end,
  real32_T rty_t[2])
{
  real32_T rtb_Divide_jb;

  /* Product: '<S572>/Divide' */
  rtb_Divide_jb = rtu_C / rtu_B;

  /* Switch: '<S581>/Switch2' incorporates:
   *  Constant: '<S572>/Constant3'
   *  RelationalOperator: '<S581>/LowerRelop1'
   *  RelationalOperator: '<S581>/UpperRelop'
   *  Switch: '<S581>/Switch'
   */
  if (rtb_Divide_jb > rtu_t_end) {
    rtb_Divide_jb = rtu_t_end;
  } else {
    if (rtb_Divide_jb < 0.0F) {
      /* Switch: '<S581>/Switch' incorporates:
       *  Constant: '<S572>/Constant3'
       */
      rtb_Divide_jb = 0.0F;
    }
  }

  /* End of Switch: '<S581>/Switch2' */

  /* SignalConversion: '<S572>/Signal Conversion' */
  rty_t[0] = rtb_Divide_jb;
  rty_t[1] = rtb_Divide_jb;
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem3'
 *    '<S589>/If Action Subsystem3'
 *    '<S617>/If Action Subsystem3'
 *    '<S648>/If Action Subsystem3'
 *    '<S676>/If Action Subsystem3'
 *    '<S704>/If Action Subsystem3'
 *    '<S735>/If Action Subsystem3'
 *    '<S763>/If Action Subsystem3'
 *    '<S789>/If Action Subsystem3'
 *    '<S818>/If Action Subsystem3'
 *    ...
 */
void app_IfActionSubsystem3(real32_T rtu_v_t1, real32_T
  *rty_MOS_v_MaxOvershootSpd_sg)
{
  /* MinMax: '<S574>/Max' incorporates:
   *  Abs: '<S574>/Abs'
   *  Constant: '<S574>/Constant1'
   *  Sum: '<S574>/Add1'
   */
  *rty_MOS_v_MaxOvershootSpd_sg = fmaxf(0.0F, fabsf(rtu_v_t1));
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem4'
 *    '<S589>/If Action Subsystem4'
 *    '<S617>/If Action Subsystem4'
 *    '<S648>/If Action Subsystem4'
 *    '<S676>/If Action Subsystem4'
 *    '<S704>/If Action Subsystem4'
 *    '<S735>/If Action Subsystem4'
 *    '<S763>/If Action Subsystem4'
 *    '<S789>/If Action Subsystem4'
 *    '<S818>/If Action Subsystem4'
 *    ...
 */
void app_IfActionSubsystem4(real32_T rtu_v_t2, real32_T
  *rty_MOS_v_MaxOvershootSpd_sg)
{
  /* MinMax: '<S575>/Max' incorporates:
   *  Abs: '<S575>/Abs'
   *  Constant: '<S575>/Constant1'
   *  Sum: '<S575>/Add1'
   */
  *rty_MOS_v_MaxOvershootSpd_sg = fmaxf(0.0F, fabsf(rtu_v_t2));
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem5'
 *    '<S589>/If Action Subsystem5'
 *    '<S617>/If Action Subsystem5'
 *    '<S648>/If Action Subsystem5'
 *    '<S676>/If Action Subsystem5'
 *    '<S704>/If Action Subsystem5'
 *    '<S735>/If Action Subsystem5'
 *    '<S763>/If Action Subsystem5'
 *    '<S789>/If Action Subsystem5'
 *    '<S818>/If Action Subsystem5'
 *    ...
 */
void app_IfActionSubsystem5(real32_T rtu_v_t1, real32_T rtu_v_t2, real32_T
  *rty_MOS_v_MaxOvershootSpd_sg)
{
  /* MinMax: '<S576>/Max' incorporates:
   *  Abs: '<S576>/Abs'
   *  Abs: '<S576>/Abs1'
   *  Constant: '<S576>/Constant1'
   *  Sum: '<S576>/Add1'
   *  Sum: '<S576>/Add2'
   */
  *rty_MOS_v_MaxOvershootSpd_sg = fmaxf(fmaxf(0.0F, fabsf(rtu_v_t1)), fabsf
    (rtu_v_t2));
}

/*
 * Output and update for action system:
 *    '<S561>/If Action Subsystem6'
 *    '<S589>/If Action Subsystem6'
 *    '<S617>/If Action Subsystem6'
 *    '<S648>/If Action Subsystem6'
 *    '<S676>/If Action Subsystem6'
 *    '<S704>/If Action Subsystem6'
 *    '<S735>/If Action Subsystem6'
 *    '<S763>/If Action Subsystem6'
 *    '<S789>/If Action Subsystem6'
 *    '<S818>/If Action Subsystem6'
 *    ...
 */
void app_IfActionSubsystem6(real32_T *rty_MOS_v_MaxOvershootSpd_sg)
{
  /* SignalConversion generated from: '<S577>/MOS_v_MaxOvershootSpd_sg' incorporates:
   *  Constant: '<S577>/Constant1'
   */
  *rty_MOS_v_MaxOvershootSpd_sg = 0.0F;
}

/* Output and update for atomic system: '<S543>/LinSpace' */
void app_LinSpace(real32_T rtu_x_start, real32_T rtu_x_end, real32_T
                  rty_LinearVector[6], B_LinSpace_app_T *localB, uint8_T
                  rtp_PntsNum)
{
  int32_T i;
  int32_T s726_iter;
  real32_T rtb_Divide_f;

  /* Product: '<S725>/Divide' incorporates:
   *  Constant: '<S725>/Constant'
   *  Sum: '<S725>/Add'
   */
  rtb_Divide_f = (rtu_x_end - rtu_x_start) / 5.0F;

  /* Outputs for Iterator SubSystem: '<S725>/For Iterator Subsystem' incorporates:
   *  ForIterator: '<S726>/For Iterator'
   */
  /* Constant: '<S725>/Constant1' */
  for (s726_iter = 0; s726_iter < (int32_T)rtp_PntsNum; s726_iter++) {
    /* Assignment: '<S726>/Assignment' incorporates:
     *  Product: '<S726>/Multiply'
     *  Sum: '<S726>/Add'
     */
    if (s726_iter == 0) {
      /* Assignment: '<S726>/Assignment' */
      for (i = 0; i < 6; i++) {
        localB->Assignment[i] = 0.0F;
      }

      /* End of Assignment: '<S726>/Assignment' */
    }

    localB->Assignment[s726_iter] = (real32_T)s726_iter * rtb_Divide_f +
      rtu_x_start;

    /* End of Assignment: '<S726>/Assignment' */
  }

  /* End of Constant: '<S725>/Constant1' */
  /* End of Outputs for SubSystem: '<S725>/For Iterator Subsystem' */

  /* Reshape: '<S725>/Reshape' */
  for (i = 0; i < 6; i++) {
    rty_LinearVector[i] = localB->Assignment[i];
  }

  /* End of Reshape: '<S725>/Reshape' */
}

/* System initialize for function-call system: '<S502>/Trj_RePlan1' */
void app_Trj_RePlan1_Init(DW_Trj_RePlan1_app_T *localDW)
{
  /* InitializeConditions for UnitDelay: '<S536>/Unit Delay7' */
  localDW->UnitDelay7_DSTATE = 0.02F;
}

/* Output and update for function-call system: '<S502>/Trj_RePlan1' */
void app_Trj_RePlan1(uint8_T rtu_Traj_B_Batch_Out, real32_T
                     rtu_Traj_B_Batch_Out_j, real32_T rtu_Traj_B_Batch_Out_o,
                     real32_T rtu_Traj_B_Batch_Out_i, real32_T
                     rtu_Traj_B_Batch_Out_m, real32_T rtu_Traj_B_Batch_Out_d,
                     real32_T rtu_Traj_B_Batch_Out_db, real32_T
                     rtu_Traj_Batch_Out, boolean_T rtu_Traj_Batch_Out_o,
                     real32_T rtu_Traj_Batch_Out_f, real32_T
                     rtu_Traj_Batch_Out_b, real32_T rtu_Traj_Batch_Out_a,
                     boolean_T rtu_Traj_Batch_Out_l, real32_T
                     rtu_Traj_Batch_Out_i, uint8_T rtu_Traj_Batch_Out_d, const
                     real32_T rtu_Traj_Batch_Out_h[3], const real32_T
                     rtu_Traj_Batch_Out_c[3], real32_T rtu_Traj_Batch_Out_fu,
                     real32_T rtu_Traj_Batch_Out_e, real32_T
                     rtu_Traj_Batch_Out_k, real32_T rtu_Traj_Batch_Out_m,
                     real32_T rtu_Traj_Batch_Out_g, real32_T
                     rtu_Traj_Batch_Out_i4, real32_T rtu_Traj_Batch_Out_mh,
                     real32_T rtu_Traj_Batch_Out_mw, real32_T
                     *rty_Trj_b_BatchFol_Out, real32_T *rty_Trj_b_BatchFol_Out_j,
                     real32_T *rty_Trj_b_BatchFol_Out_o, real32_T
                     *rty_Trj_b_BatchFol_Out_i, real32_T
                     *rty_Trj_b_BatchFol_Out_m, real32_T
                     *rty_Trj_b_BatchFol_Out_d, real32_T
                     *rty_Trj_b_BatchFol_Out_db, real32_T
                     *rty_Trj_b_BatchFol_Out_d4, real32_T
                     *rty_Trj_b_BatchFol_Out_ow, real32_T
                     *rty_Trj_b_BatchFol_Out_f, real32_T
                     *rty_Trj_b_BatchFol_Out_b, uint8_T
                     *rty_Trj_b_BatchFol_Out_a, boolean_T *rty_Trj_BatchFol_Out,
                     real32_T *rty_Trj_BatchFol_Out_i, real32_T
                     *rty_Trj_BatchFol_Out_d, real32_T *rty_Trj_BatchFol_Out_h,
                     real32_T *rty_Trj_BatchFol_Out_c, real32_T
                     *rty_Trj_BatchFol_Out_f, real32_T *rty_Trj_BatchFol_Out_e,
                     real32_T *rty_Trj_BatchFol_Out_k, real32_T
                     *rty_Trj_BatchFol_Out_m, real32_T *rty_Trj_BatchFol_Out_g,
                     real32_T *rty_Trj_BatchFol_Out_i4, real32_T
                     *rty_Trj_BatchFol_Out_mh, real32_T *rty_Trj_BatchFol_Out_mw,
                     boolean_T *rty_Trj_BatchFol_Out_gw, real32_T
                     *rty_Trj_BatchFol_Out_f5, uint8_T *rty_Trj_BatchFol_Out_a,
                     real32_T rty_Trj_BatchFol_Out_ek[3], real32_T
                     rty_Trj_BatchFol_Out_k2[3], uint8_T *rty_Traj_ID_FolSpdFol,
                     real32_T *rty_Traj_t_TrjTrvlTmFol_sg, real32_T
                     *rty_Traj_t_TrjRemainTmFol_sg, const
                     ConstB_Trj_RePlan1_app_T *localC, DW_Trj_RePlan1_app_T
                     *localDW)
{
  real32_T rtb_Add_bg;

  /* Switch: '<S536>/Switch' incorporates:
   *  Constant: '<S536>/0'
   *  Constant: '<S536>/CycleTime'
   *  Constant: '<S898>/Constant'
   *  Logic: '<S536>/AND'
   *  RelationalOperator: '<S898>/Compare'
   *  RelationalOperator: '<S899>/FixPt Relational Operator'
   *  Sum: '<S536>/Add'
   *  UnitDelay: '<S536>/Unit Delay7'
   *  UnitDelay: '<S899>/Delay Input1'
   *
   * Block description for '<S899>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if ((rtu_Traj_B_Batch_Out != localDW->DelayInput1_DSTATE) && ((int32_T)
       rtu_Traj_B_Batch_Out != 0)) {
    rtb_Add_bg = 0.0F;
  } else {
    rtb_Add_bg = localDW->UnitDelay7_DSTATE + 0.05F;
  }

  /* End of Switch: '<S536>/Switch' */

  /* MinMax: '<S536>/Min' incorporates:
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  localDW->UnitDelay7_DSTATE = fminf(rtu_Traj_Batch_Out, rtb_Add_bg);

  /* Sum: '<S536>/Add1' incorporates:
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Traj_t_TrjRemainTmFol_sg = rtu_Traj_Batch_Out -
    localDW->UnitDelay7_DSTATE;

  /* SignalConversion generated from: '<S536>/Traj_t_TrjTrvlTmFol_sg' incorporates:
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Traj_t_TrjTrvlTmFol_sg = localDW->UnitDelay7_DSTATE;

  /* Sum: '<S901>/Add' incorporates:
   *  Product: '<S901>/Multiply'
   *  Product: '<S901>/Multiply1'
   *  Product: '<S901>/Multiply2'
   *  Product: '<S901>/Multiply3'
   *  Product: '<S901>/Multiply4'
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Trj_b_BatchFol_Out = ((((rtu_Traj_B_Batch_Out_j *
    localDW->UnitDelay7_DSTATE + rtu_Traj_B_Batch_Out_db) +
    rtu_Traj_B_Batch_Out_o * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE) + rtu_Traj_B_Batch_Out_i *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE) + rtu_Traj_B_Batch_Out_m *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE) +
    rtu_Traj_B_Batch_Out_d * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE;

  /* Sum: '<S902>/Add' incorporates:
   *  Gain: '<S900>/Gain2'
   *  Gain: '<S900>/Gain3'
   *  Gain: '<S900>/Gain4'
   *  Gain: '<S900>/Gain5'
   *  Product: '<S902>/Multiply1'
   *  Product: '<S902>/Multiply2'
   *  Product: '<S902>/Multiply3'
   *  Product: '<S902>/Multiply4'
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Trj_b_BatchFol_Out_j = (((2.0F * rtu_Traj_B_Batch_Out_o *
    localDW->UnitDelay7_DSTATE + rtu_Traj_B_Batch_Out_j) + 3.0F *
    rtu_Traj_B_Batch_Out_i * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE) + 4.0F * rtu_Traj_B_Batch_Out_m *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE) + 5.0F * rtu_Traj_B_Batch_Out_d *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE;

  /* Sum: '<S903>/Add' incorporates:
   *  Gain: '<S900>/Gain10'
   *  Gain: '<S900>/Gain11'
   *  Gain: '<S900>/Gain12'
   *  Gain: '<S900>/Gain9'
   *  Product: '<S903>/Multiply2'
   *  Product: '<S903>/Multiply3'
   *  Product: '<S903>/Multiply4'
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Trj_b_BatchFol_Out_o = ((6.0F * rtu_Traj_B_Batch_Out_i *
    localDW->UnitDelay7_DSTATE + 2.0F * rtu_Traj_B_Batch_Out_o) + 12.0F *
    rtu_Traj_B_Batch_Out_m * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE) + 20.0F * rtu_Traj_B_Batch_Out_d *
    localDW->UnitDelay7_DSTATE * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE;

  /* Sum: '<S904>/Add' incorporates:
   *  Gain: '<S900>/Gain17'
   *  Gain: '<S900>/Gain18'
   *  Gain: '<S900>/Gain19'
   *  Product: '<S904>/Multiply3'
   *  Product: '<S904>/Multiply4'
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  *rty_Trj_b_BatchFol_Out_i = (24.0F * rtu_Traj_B_Batch_Out_m *
    localDW->UnitDelay7_DSTATE + 6.0F * rtu_Traj_B_Batch_Out_i) + 60.0F *
    rtu_Traj_B_Batch_Out_d * localDW->UnitDelay7_DSTATE *
    localDW->UnitDelay7_DSTATE;

  /* Sum: '<S900>/Add' incorporates:
   *  UnitDelay: '<S536>/Unit Delay7'
   */
  rtb_Add_bg = localDW->UnitDelay7_DSTATE + localC->Gain;

  /* Sum: '<S905>/Add' incorporates:
   *  Gain: '<S900>/Gain1'
   *  Gain: '<S900>/Gain6'
   *  Gain: '<S900>/Gain7'
   *  Gain: '<S900>/Gain8'
   *  Product: '<S905>/Multiply2'
   *  Product: '<S905>/Multiply3'
   *  Product: '<S905>/Multiply4'
   */
  *rty_Trj_b_BatchFol_Out_m = ((6.0F * rtu_Traj_B_Batch_Out_i * rtb_Add_bg +
    2.0F * rtu_Traj_B_Batch_Out_o) + 12.0F * rtu_Traj_B_Batch_Out_m * rtb_Add_bg
    * rtb_Add_bg) + 20.0F * rtu_Traj_B_Batch_Out_d * rtb_Add_bg * rtb_Add_bg *
    rtb_Add_bg;

  /* SignalConversion generated from: '<S536>/Traj_ID_FolSpdFol' */
  *rty_Traj_ID_FolSpdFol = rtu_Traj_B_Batch_Out;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out = rtu_Traj_Batch_Out_o;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_g = rtu_Traj_Batch_Out_f;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_i4 = rtu_Traj_Batch_Out_b;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_mh = rtu_Traj_Batch_Out_a;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_mw = rtu_Traj_Batch_Out;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_gw = rtu_Traj_Batch_Out_l;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_f5 = rtu_Traj_Batch_Out_i;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_a = rtu_Traj_Batch_Out_d;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_ek[0] = rtu_Traj_Batch_Out_h[0];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_k2[0] = rtu_Traj_Batch_Out_c[0];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_ek[1] = rtu_Traj_Batch_Out_h[1];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_k2[1] = rtu_Traj_Batch_Out_c[1];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_ek[2] = rtu_Traj_Batch_Out_h[2];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  rty_Trj_BatchFol_Out_k2[2] = rtu_Traj_Batch_Out_c[2];

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_i = rtu_Traj_Batch_Out_fu;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_d = rtu_Traj_Batch_Out_e;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_h = rtu_Traj_Batch_Out_k;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_c = rtu_Traj_Batch_Out_m;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_f = rtu_Traj_Batch_Out_g;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_e = rtu_Traj_Batch_Out_i4;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_k = rtu_Traj_Batch_Out_mh;

  /* SignalConversion generated from: '<S536>/Trj_BatchFol_Out' */
  *rty_Trj_BatchFol_Out_m = rtu_Traj_Batch_Out_mw;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_f = rtu_Traj_B_Batch_Out_m;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_b = rtu_Traj_B_Batch_Out_d;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_a = rtu_Traj_B_Batch_Out;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_d = rtu_Traj_B_Batch_Out_db;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_db = rtu_Traj_B_Batch_Out_j;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_d4 = rtu_Traj_B_Batch_Out_o;

  /* SignalConversion generated from: '<S536>/Trj_b_BatchFol_Out' */
  *rty_Trj_b_BatchFol_Out_ow = rtu_Traj_B_Batch_Out_i;

  /* Update for UnitDelay: '<S899>/Delay Input1'
   *
   * Block description for '<S899>/Delay Input1':
   *
   *  Store in Global RAM
   */
  localDW->DelayInput1_DSTATE = rtu_Traj_B_Batch_Out;
}

/*
 * Output and update for atomic system:
 *    '<S906>/Chattering_Filter'
 *    '<S906>/Chattering_Filter1'
 *    '<S906>/Chattering_Filter2'
 *    '<S906>/Chattering_Filter3'
 *    '<S906>/Chattering_Filter4'
 *    '<S906>/Chattering_Filter5'
 *    '<S906>/Chattering_Filter6'
 *    '<S906>/Chattering_Filter7'
 *    '<S1030>/Chattering_Filter'
 *    '<S1030>/Chattering_Filter1'
 * Common block description:
 *   Detect the input signals.
 *   If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
 *   else ignore the input and keep the output y in previous step.
 */
boolean_T app_Chattering_Filter(boolean_T rtu_Input_bl,
  DW_Chattering_Filter_app_T *localDW)
{
  boolean_T rty_Output_bl_0;
  boolean_T rtb_RelationalOperator1_iz;
  boolean_T rtb_UnitDelay1_k;

  /* UnitDelay: '<S912>/Unit Delay1' */
  rtb_UnitDelay1_k = localDW->UnitDelay1_DSTATE;

  /* RelationalOperator: '<S912>/Relational Operator1' incorporates:
   *  UnitDelay: '<S912>/Unit Delay1'
   *  UnitDelay: '<S912>/Unit Delay2'
   */
  rtb_RelationalOperator1_iz = (localDW->UnitDelay1_DSTATE ==
    localDW->UnitDelay2_DSTATE);

  /* UnitDelay: '<S912>/Unit Delay3' incorporates:
   *  UnitDelay: '<S912>/Unit Delay2'
   */
  localDW->UnitDelay2_DSTATE = localDW->UnitDelay3_DSTATE;

  /* Switch: '<S912>/Switch' incorporates:
   *  Logic: '<S912>/Logical Operator'
   *  RelationalOperator: '<S912>/Relational Operator'
   *  UnitDelay: '<S912>/Unit Delay1'
   *  UnitDelay: '<S912>/Unit Delay2'
   */
  if ((rtu_Input_bl == localDW->UnitDelay1_DSTATE) && rtb_RelationalOperator1_iz)
  {
    rty_Output_bl_0 = rtu_Input_bl;
  } else {
    rty_Output_bl_0 = localDW->UnitDelay2_DSTATE;
  }

  /* End of Switch: '<S912>/Switch' */

  /* Update for UnitDelay: '<S912>/Unit Delay1' */
  localDW->UnitDelay1_DSTATE = rtu_Input_bl;

  /* Update for UnitDelay: '<S912>/Unit Delay2' */
  localDW->UnitDelay2_DSTATE = rtb_UnitDelay1_k;

  /* Update for UnitDelay: '<S912>/Unit Delay3' */
  localDW->UnitDelay3_DSTATE = rty_Output_bl_0;
  return rty_Output_bl_0;
}

/*
 * Output and update for atomic system:
 *    '<S906>/Fallingedge_Detection'
 *    '<S906>/Fallingedge_Detection1'
 *    '<S906>/Fallingedge_Detection2'
 *    '<S906>/Fallingedge_Detection3'
 * Common block description:
 *   Upedge Detection
 *
 *   if u(k)~=u(k-1) && u(k)==1;
 *
 *   set       y = 1;
 *
 *        else y=0;
 */
void app_Fallingedge_Detection(boolean_T rtu_Input_bl, boolean_T *rty_Output_bl,
  DW_Fallingedge_Detection_app_T *localDW)
{
  /* Logic: '<S920>/Logical Operator' incorporates:
   *  Logic: '<S920>/Logical Operator1'
   *  RelationalOperator: '<S920>/Relational Operator'
   *  UnitDelay: '<S920>/Unit Delay1'
   */
  *rty_Output_bl = ((!rtu_Input_bl) && (rtu_Input_bl !=
    localDW->UnitDelay1_DSTATE));

  /* Update for UnitDelay: '<S920>/Unit Delay1' */
  localDW->UnitDelay1_DSTATE = rtu_Input_bl;
}

/*
 * Output and update for atomic system:
 *    '<S906>/Upedge_Detection'
 *    '<S1030>/Upedge_Detection'
 *    '<S1030>/Upedge_Detection1'
 * Common block description:
 *   Upedge Detection
 *
 *   if u(k)~=u(k-1) && u(k)==1;
 *
 *   set       y = 1;
 *
 *        else y=0;
 */
void app_Upedge_Detection(boolean_T rtu_Input_bl, boolean_T *rty_Output_bl,
  DW_Upedge_Detection_app_T *localDW)
{
  /* Logic: '<S927>/Logical Operator' incorporates:
   *  RelationalOperator: '<S927>/Relational Operator'
   *  UnitDelay: '<S927>/Unit Delay1'
   */
  *rty_Output_bl = (rtu_Input_bl && (rtu_Input_bl != localDW->UnitDelay1_DSTATE));

  /* Update for UnitDelay: '<S927>/Unit Delay1' */
  localDW->UnitDelay1_DSTATE = rtu_Input_bl;
}

/*
 * System initialize for atomic system:
 *    '<S949>/Debounce_Module'
 *    '<S949>/Debounce_Module1'
 *    '<S950>/Debounce_Module'
 *    '<S950>/Debounce_Module2'
 *    '<S976>/Debounce_Module1'
 *    '<S976>/Debounce_Module2'
 *    '<S976>/Debounce_Module3'
 *    '<S976>/Debounce_Module4'
 *    '<S976>/Debounce_Module5'
 *    '<S1004>/Debounce_Module1'
 *    '<S1004>/Debounce_Module2'
 */
void app_Debounce_Module_d_Init(boolean_T *rty_Out)
{
  /* SystemInitialize for Chart: '<S958>/Debounce_Module' */
  *rty_Out = false;
}

/*
 * Output and update for atomic system:
 *    '<S949>/Debounce_Module'
 *    '<S949>/Debounce_Module1'
 *    '<S950>/Debounce_Module'
 *    '<S950>/Debounce_Module2'
 *    '<S976>/Debounce_Module1'
 *    '<S976>/Debounce_Module2'
 *    '<S976>/Debounce_Module3'
 *    '<S976>/Debounce_Module4'
 *    '<S976>/Debounce_Module5'
 *    '<S1004>/Debounce_Module1'
 *    '<S1004>/Debounce_Module2'
 */
boolean_T app_Debounce_Module_b(boolean_T rtu_In, real32_T rtu_RiseTimeLmt,
  real32_T rtu_FallTimeLmt, real32_T rtu_MainLoop_Time,
  DW_Debounce_Module_app_h_T *localDW)
{
  /* Chart: '<S958>/Debounce_Module' */
  if ((int32_T)localDW->InPrev < (int32_T)rtu_In) {
    localDW->fallInternTimeVal = 0.0F;
    if (localDW->riseInternTimeVal < rtu_RiseTimeLmt) {
      localDW->riseInternTimeVal += rtu_MainLoop_Time;
    } else {
      localDW->riseInternTimeVal = 0.0F;
      localDW->InPrev = true;
    }
  } else if ((int32_T)localDW->InPrev > (int32_T)rtu_In) {
    localDW->riseInternTimeVal = 0.0F;
    if (localDW->fallInternTimeVal < rtu_FallTimeLmt) {
      localDW->fallInternTimeVal += rtu_MainLoop_Time;
    } else {
      localDW->fallInternTimeVal = 0.0F;
      localDW->InPrev = false;
    }
  } else {
    localDW->riseInternTimeVal = 0.0F;
    localDW->fallInternTimeVal = 0.0F;
    localDW->InPrev = rtu_In;
  }

  return localDW->InPrev;

  /* End of Chart: '<S958>/Debounce_Module' */
}

/* System initialize for atomic system: '<S951>/DownEdge_counter' */
void app_DownEdge_counter_Init(boolean_T *rty_TrgEnbl_bl)
{
  /* SystemInitialize for Chart: '<S968>/DFIn_TmCntrSF_TRUE'
   *
   * Block description for '<S968>/DFIn_TmCntrSF_TRUE':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   */
  *rty_TrgEnbl_bl = false;
}

/* Output and update for atomic system: '<S951>/DownEdge_counter' */
void app_DownEdge_counter(boolean_T rtu_Trg_bl, real32_T rtu_CntTm_sg, boolean_T
  *rty_TrgEnbl_bl, DW_DownEdge_counter_app_T *localDW)
{
  int32_T tmp;
  real32_T u0;

  /* Chart: '<S968>/DFIn_TmCntrSF_TRUE' incorporates:
   *  DataTypeConversion: '<S968>/Data Type Conversion11'
   *
   * Block description for '<S968>/DFIn_TmCntrSF_TRUE':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   */
  if ((uint32_T)localDW->is_active_c83_app == 0U) {
    localDW->is_active_c83_app = 1U;
    localDW->is_c83_app = app_IN_Initial_Condition;
    *rty_TrgEnbl_bl = false;
    localDW->status_counter = 0U;
  } else {
    switch (localDW->is_c83_app) {
     case app_IN_Counter_Satisfy_Condition:
      /* Product: '<S968>/Divide' incorporates:
       *  Constant: '<S968>/Constant1'
       *
       * Block description for '<S968>/Constant1':
       *  % C_system_step = 0.01s.
       */
      u0 = rtu_CntTm_sg / 0.02F;

      /* Saturate: '<S968>/Saturation2_To_-4' */
      if (u0 > 65530.0F) {
        u0 = 65530.0F;
      } else {
        if (u0 < 0.0F) {
          u0 = 0.0F;
        }
      }

      /* End of Saturate: '<S968>/Saturation2_To_-4' */

      /* DataTypeConversion: '<S968>/Data Type Conversion11' */
      u0 = floorf(u0);
      if (rtIsNaNF(u0)) {
        u0 = 0.0F;
      } else {
        u0 = fmodf(u0, 65536.0F);
      }

      if (localDW->status_counter >= (uint16_T)u0) {
        localDW->is_c83_app = app_IN_Initial_Condition;
        *rty_TrgEnbl_bl = false;
        localDW->status_counter = 0U;
      } else {
        *rty_TrgEnbl_bl = true;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      }
      break;

     case app_IN_Initial_Condition:
      if (rtu_Trg_bl) {
        localDW->is_c83_app = app_IN_Middle_Condition;
        *rty_TrgEnbl_bl = false;
      }
      break;

     default:
      /* case IN_Middle_Condition: */
      if (!rtu_Trg_bl) {
        localDW->is_c83_app = app_IN_Counter_Satisfy_Condition;
        *rty_TrgEnbl_bl = true;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      } else {
        *rty_TrgEnbl_bl = false;
      }
      break;
    }
  }

  /* End of Chart: '<S968>/DFIn_TmCntrSF_TRUE' */
}

/*
 * System initialize for atomic system:
 *    '<S945>/DFIn_TmCntrSF_TRUE1'
 *    '<S945>/DFIn_TmCntrSF_TRUE2'
 *    '<S909>/DFIn_TmCntrSF_TRUE'
 *    '<S1041>/Timing_Counter'
 *    '<S1039>/TimingCounterFun'
 */
void app_DFIn_TmCntrSF_TRUE1_Init(boolean_T *rty_OutPut)
{
  *rty_OutPut = false;
}

/*
 * Output and update for atomic system:
 *    '<S945>/DFIn_TmCntrSF_TRUE1'
 *    '<S945>/DFIn_TmCntrSF_TRUE2'
 *    '<S909>/DFIn_TmCntrSF_TRUE'
 *    '<S1041>/Timing_Counter'
 *    '<S1039>/TimingCounterFun'
 */
void app_DFIn_TmCntrSF_TRUE1(boolean_T rtu_IsSignalNeedTiming, real32_T
  rtu_P_status_counter, boolean_T *rty_OutPut, DW_DFIn_TmCntrSF_TRUE1_app_T
  *localDW)
{
  int32_T tmp;

  /* Chart: '<S945>/DFIn_TmCntrSF_TRUE1'
   *
   * Block description for '<S945>/DFIn_TmCntrSF_TRUE1':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   */
  if ((uint32_T)localDW->is_active_c84_app == 0U) {
    localDW->is_active_c84_app = 1U;
    localDW->is_c84_app = app_IN_Initial_Condition_l;
    *rty_OutPut = false;
    localDW->status_counter = 0U;
  } else {
    switch (localDW->is_c84_app) {
     case app_IN_Counter_Satisfy_Condition_b:
      if (!rtu_IsSignalNeedTiming) {
        localDW->is_c84_app = app_IN_Initial_Condition_l;
        *rty_OutPut = false;
        localDW->status_counter = 0U;
      }
      break;

     case app_IN_Initial_Condition_l:
      if (rtu_IsSignalNeedTiming) {
        localDW->is_c84_app = app_IN_Middle_Condition_m;
        *rty_OutPut = false;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      }
      break;

     default:
      /* case IN_Middle_Condition: */
      if (!rtu_IsSignalNeedTiming) {
        localDW->is_c84_app = app_IN_Initial_Condition_l;
        *rty_OutPut = false;
        localDW->status_counter = 0U;
      } else if ((real32_T)localDW->status_counter >= rtu_P_status_counter) {
        localDW->is_c84_app = app_IN_Counter_Satisfy_Condition_b;
        *rty_OutPut = true;
        localDW->status_counter = 0U;
      } else {
        *rty_OutPut = false;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      }
      break;
    }
  }

  /* End of Chart: '<S945>/DFIn_TmCntrSF_TRUE1' */
}

/* System initialize for atomic system: '<S997>/HMI_ACCDetObjDistLvl' */
void app_HMI_ACCDetObjDistLvl_Init(eCDL_ACCDistLvl
  *rty_ACC_indx_HMIDetObjDistLvl_u8)
{
  /* SystemInitialize for Chart: '<S1003>/ACC_ACCDetObjDistLvl' */
  *rty_ACC_indx_HMIDetObjDistLvl_u8 = CDL_DistLvl0;
}

/* Output and update for atomic system: '<S997>/HMI_ACCDetObjDistLvl' */
eCDL_ACCDistLvl app_HMI_ACCDetObjDistLvl(real32_T
  rtu_DFIn_d_CODPACCFMRdrLongtDist_sg, real32_T rtu_DFIn_v_VDPEgoAvgVehSpd_sg,
  real32_T rtu_ACC_d_FTCDsrdDistLvl1HMI_sg, uint8_T
  rtu_ACC_indx_HMISeldDistLvl_u8, const ConstB_HMI_ACCDetObjDistLvl_app_T
  *localC, DW_HMI_ACCDetObjDistLvl_app_T *localDW)
{
  eCDL_ACCDistLvl rty_ACC_indx_HMIDetObjDistLvl_u8_0;
  real32_T rtb_ACC_d_HMIDistLvlCmpNeg_sg;
  real32_T rtb_ACC_d_HMIDistLvlCmpPos_sg;
  real32_T rtb_ACC_d_HMIDsrdDistLvl1Mid_sg;
  real32_T rtb_HMI_DetDistLvl23Cmp;

  /* Product: '<S1003>/Product1' incorporates:
   *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u13'
   */
  rtb_ACC_d_HMIDsrdDistLvl1Mid_sg = rtu_ACC_d_FTCDsrdDistLvl1HMI_sg *
    P_ACC_Gx_HMIDsrdDistLvl1Mid_sg;

  /* Switch: '<S1003>/Switch' incorporates:
   *  Constant: '<S1003>/Constant2'
   *  Constant: '<S1003>/Constant3'
   *  Constant: '<S1003>/Constant4'
   *  RelationalOperator: '<S1003>/Relational Operator'
   *  RelationalOperator: '<S1003>/Relational Operator1'
   *  RelationalOperator: '<S1003>/Relational Operator2'
   *  Switch: '<S1003>/Switch1'
   *  Switch: '<S1003>/Switch2'
   *  Switch: '<S1003>/Switch3'
   */
  if ((int32_T)rtu_ACC_indx_HMISeldDistLvl_u8 == 3) {
    rtb_HMI_DetDistLvl23Cmp = localC->Divide;
    rtb_ACC_d_HMIDsrdDistLvl1Mid_sg = localC->Divide1;
  } else {
    if ((int32_T)rtu_ACC_indx_HMISeldDistLvl_u8 == 2) {
      /* Switch: '<S1003>/Switch1' incorporates:
       *  Constant: '<S1003>/2 wheels1'
       *  Product: '<S1003>/Divide2'
       *  Sum: '<S1003>/Add2'
       */
      rtb_HMI_DetDistLvl23Cmp = (rtb_ACC_d_HMIDsrdDistLvl1Mid_sg +
        rtu_ACC_d_FTCDsrdDistLvl1HMI_sg) / 2.0F;
    } else if ((int32_T)rtu_ACC_indx_HMISeldDistLvl_u8 == 1) {
      /* Switch: '<S1003>/Switch2' incorporates:
       *  Constant: '<S1003>/2 wheels2'
       *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u14'
       *  Product: '<S1003>/Divide4'
       *  Product: '<S1003>/Product2'
       *  Sum: '<S1003>/Add4'
       *  Switch: '<S1003>/Switch1'
       */
      rtb_HMI_DetDistLvl23Cmp = (rtu_ACC_d_FTCDsrdDistLvl1HMI_sg *
        P_ACC_Gx_HMIDsrdDistLvl1Ner_sg + rtb_ACC_d_HMIDsrdDistLvl1Mid_sg) / 2.0F;
    } else {
      /* Switch: '<S1003>/Switch2' incorporates:
       *  Switch: '<S1003>/Switch1'
       */
      rtb_HMI_DetDistLvl23Cmp = localC->Divide6;
    }

    /* Switch: '<S1003>/Switch4' incorporates:
     *  Constant: '<S1003>/Constant4'
     *  Constant: '<S1003>/Constant7'
     *  Constant: '<S1003>/Constant8'
     *  RelationalOperator: '<S1003>/Relational Operator2'
     *  RelationalOperator: '<S1003>/Relational Operator4'
     *  RelationalOperator: '<S1003>/Relational Operator5'
     *  Switch: '<S1003>/Switch1'
     *  Switch: '<S1003>/Switch2'
     *  Switch: '<S1003>/Switch5'
     */
    if ((int32_T)rtu_ACC_indx_HMISeldDistLvl_u8 == 2) {
      rtb_ACC_d_HMIDsrdDistLvl1Mid_sg = localC->Divide3;
    } else if ((int32_T)rtu_ACC_indx_HMISeldDistLvl_u8 == 1) {
      /* Switch: '<S1003>/Switch5' incorporates:
       *  Constant: '<S1003>/2 wheels7'
       *  Product: '<S1003>/Divide5'
       *  Sum: '<S1003>/Add7'
       */
      rtb_ACC_d_HMIDsrdDistLvl1Mid_sg = (rtb_ACC_d_HMIDsrdDistLvl1Mid_sg +
        rtu_ACC_d_FTCDsrdDistLvl1HMI_sg) / 2.0F;
    } else {
      /* Switch: '<S1003>/Switch5' */
      rtb_ACC_d_HMIDsrdDistLvl1Mid_sg = localC->Divide7;
    }

    /* End of Switch: '<S1003>/Switch4' */
  }

  /* End of Switch: '<S1003>/Switch' */

  /* Sum: '<S1003>/Add10' incorporates:
   *  Lookup_n-D: '<S1003>/HMI_DetDistLvl12Cmp'
   */
  rtb_HMI_DetDistLvl23Cmp -= look1_iflf_binlcpw(rtu_DFIn_v_VDPEgoAvgVehSpd_sg,
    P_TX_ACC_v_HMIDetDistLvlCmp_sg, P_TY_ACC_d_HMIDetDistLvl12Cmp_sg, 5U);

  /* Sum: '<S1003>/Add11' incorporates:
   *  Lookup_n-D: '<S1003>/HMI_DetDistLvl23Cmp'
   */
  rtb_ACC_d_HMIDsrdDistLvl1Mid_sg -= look1_iflf_binlcpw
    (rtu_DFIn_v_VDPEgoAvgVehSpd_sg, P_TX_ACC_v_HMIDetDistLvlCmp_sg,
     P_TY_ACC_d_HMIDetDistLvl23Cmp_sg, 5U);

  /* Sum: '<S1003>/Add5' incorporates:
   *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u1'
   *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u2'
   *  Product: '<S1003>/Product3'
   */
  rtb_ACC_d_HMIDistLvlCmpPos_sg = rtu_DFIn_v_VDPEgoAvgVehSpd_sg *
    P_ACC_Gx_HMIDistLvlLgrCmpCoe_sg + P_ACC_d_HMIDistLvlLgrCmp_sg;

  /* Sum: '<S1003>/Add6' incorporates:
   *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u3'
   *  Constant: '<S1003>/P_ACC_cnt_OAFReActvThrs_u4'
   *  Product: '<S1003>/Product4'
   */
  rtb_ACC_d_HMIDistLvlCmpNeg_sg = rtu_DFIn_v_VDPEgoAvgVehSpd_sg *
    P_ACC_Gx_HMIDistLvlSmlCmpCoe_sg + P_ACC_d_HMIDistLvlSmlCmp_sg;

  /* Chart: '<S1003>/ACC_ACCDetObjDistLvl' */
  if ((uint32_T)localDW->is_active_c92_app == 0U) {
    localDW->is_active_c92_app = 1U;
    rtb_HMI_DetDistLvl23Cmp -= rtb_ACC_d_HMIDistLvlCmpPos_sg;
    if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg < rtb_HMI_DetDistLvl23Cmp) {
      localDW->is_c92_app = app_IN_DetObjDistLvl1;
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl1;
    } else if ((rtu_DFIn_d_CODPACCFMRdrLongtDist_sg >= rtb_HMI_DetDistLvl23Cmp) &&
               (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg <
                rtb_ACC_d_HMIDsrdDistLvl1Mid_sg + rtb_ACC_d_HMIDistLvlCmpNeg_sg))
    {
      localDW->is_c92_app = app_IN_DetObjDistLvl2;
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl2;
    } else {
      localDW->is_c92_app = app_IN_DetObjDistLvl3;
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl3;
    }
  } else {
    switch (localDW->is_c92_app) {
     case app_IN_DetObjDistLvl1:
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl1;
      if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg >= rtb_ACC_d_HMIDsrdDistLvl1Mid_sg
          + rtb_ACC_d_HMIDistLvlCmpPos_sg) {
        localDW->is_c92_app = app_IN_DetObjDistLvl3;
        rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl3;
      } else {
        if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg >= rtb_HMI_DetDistLvl23Cmp -
            rtb_ACC_d_HMIDistLvlCmpNeg_sg) {
          localDW->is_c92_app = app_IN_DetObjDistLvl2;
          rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl2;
        }
      }
      break;

     case app_IN_DetObjDistLvl2:
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl2;
      if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg < rtb_HMI_DetDistLvl23Cmp -
          rtb_ACC_d_HMIDistLvlCmpPos_sg) {
        localDW->is_c92_app = app_IN_DetObjDistLvl1;
        rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl1;
      } else {
        if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg >=
            rtb_ACC_d_HMIDsrdDistLvl1Mid_sg + rtb_ACC_d_HMIDistLvlCmpPos_sg) {
          localDW->is_c92_app = app_IN_DetObjDistLvl3;
          rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl3;
        }
      }
      break;

     default:
      /* case IN_DetObjDistLvl3: */
      rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl3;
      if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg < rtb_HMI_DetDistLvl23Cmp -
          rtb_ACC_d_HMIDistLvlCmpPos_sg) {
        localDW->is_c92_app = app_IN_DetObjDistLvl1;
        rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl1;
      } else {
        if (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg <
            rtb_ACC_d_HMIDsrdDistLvl1Mid_sg + rtb_ACC_d_HMIDistLvlCmpNeg_sg) {
          localDW->is_c92_app = app_IN_DetObjDistLvl2;
          rty_ACC_indx_HMIDetObjDistLvl_u8_0 = CDL_DistLvl2;
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1003>/ACC_ACCDetObjDistLvl' */
  return rty_ACC_indx_HMIDetObjDistLvl_u8_0;
}

/* System initialize for atomic system: '<S997>/HMI_ACCObjDetJud' */
void app_HMI_ACCObjDetJud_Init(void)
{
  boolean_T rtb_Out_iu;

  /* SystemInitialize for Atomic SubSystem: '<S1004>/Debounce_Module1' */
  app_Debounce_Module_d_Init(&rtb_Out_iu);

  /* End of SystemInitialize for SubSystem: '<S1004>/Debounce_Module1' */

  /* SystemInitialize for Atomic SubSystem: '<S1004>/Debounce_Module2' */
  app_Debounce_Module_d_Init(&rtb_Out_iu);

  /* End of SystemInitialize for SubSystem: '<S1004>/Debounce_Module2' */
}

/* Output and update for atomic system: '<S997>/HMI_ACCObjDetJud' */
uint8_T app_HMI_ACCObjDetJud(boolean_T rtu_DFIn_is_CODPFoloTgtExist_bl, real32_T
  rtu_DFIn_v_CODPACCHdVehSpd_sg, real32_T rtu_DFIn_d_CODPACCFMRdrLongtDist_sg,
  uint8_T rtu_DFIn_indx_CODPACCTgtID_u8, boolean_T rtu_DFIn_is_VDPVehSdslSts_bl,
  E_ACCReqSts_t rtu_ACC_indx_SMRSts_en, const ConstB_HMI_ACCObjDetJud_app_T
  *localC, DW_HMI_ACCObjDetJud_app_T *localDW)
{
  uint8_T rty_ACC_is_HMIObjDet_u8_0;
  boolean_T rtb_Out_a;
  boolean_T rtb_Out_k;
  boolean_T rtb_RelationalOperator3_m;

  /* RelationalOperator: '<S1004>/Relational Operator3' incorporates:
   *  UnitDelay: '<S1004>/Unit Delay'
   */
  rtb_RelationalOperator3_m = (rtu_DFIn_indx_CODPACCTgtID_u8 !=
    localDW->UnitDelay_DSTATE);

  /* Switch: '<S1004>/Switch2' incorporates:
   *  Constant: '<S1004>/Constant25'
   *  Constant: '<S1004>/Constant3'
   *  Constant: '<S1004>/Constant6'
   *  RelationalOperator: '<S1004>/Relational Operator4'
   *  RelationalOperator: '<S1004>/Relational Operator6'
   *  Switch: '<S1004>/Switch3'
   *  UnitDelay: '<S1004>/Unit Delay2'
   */
  if (rtu_DFIn_v_CODPACCHdVehSpd_sg < P_ACC_v_HMIObjDetStnObjSpd_sg) {
    localDW->UnitDelay2_DSTATE = C_ACC_HMIZero_bl;
  } else {
    if (rtu_DFIn_v_CODPACCHdVehSpd_sg > P_ACC_v_HMIObjDetMovObjSpd_sg) {
      /* Switch: '<S1004>/Switch3' incorporates:
       *  Constant: '<S1004>/Constant7'
       *  UnitDelay: '<S1004>/Unit Delay2'
       */
      localDW->UnitDelay2_DSTATE = C_ACC_HMIZero_bl;
    }
  }

  /* End of Switch: '<S1004>/Switch2' */

  /* UnitDelay: '<S1004>/Unit Delay1' incorporates:
   *  UnitDelay: '<S1004>/Unit Delay'
   */
  localDW->UnitDelay_DSTATE = localDW->UnitDelay1_DSTATE;

  /* Outputs for Atomic SubSystem: '<S1004>/Debounce_Module1' */
  /* Logic: '<S1004>/Logical Operator8' incorporates:
   *  Constant: '<S1004>/Constant1'
   *  Constant: '<S1004>/Constant4'
   *  Constant: '<S1004>/Constant9'
   *  Logic: '<S1004>/Logical Operator11'
   *  Logic: '<S1004>/Logical Operator6'
   *  RelationalOperator: '<S1004>/Relational Operator5'
   *  RelationalOperator: '<S1004>/Relational Operator8'
   *  UnitDelay: '<S1004>/Unit Delay'
   *  UnitDelay: '<S1004>/Unit Delay2'
   */
  rtb_Out_a = app_Debounce_Module_b((!localDW->UnitDelay2_DSTATE) &&
    (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg < P_ACC_d_HMIObjDetStnObjDist_sg) &&
    (rtu_DFIn_indx_CODPACCTgtID_u8 == localDW->UnitDelay_DSTATE),
    P_ACC_t_HMIObjDetStnObjTmCfm_sg, localC->TmpSignalConversionAtDebounce_Modu,
    0.02F, &localDW->Debounce_Module1);

  /* End of Outputs for SubSystem: '<S1004>/Debounce_Module1' */

  /* UnitDelay: '<S1004>/Unit Delay3' incorporates:
   *  UnitDelay: '<S1004>/Unit Delay'
   */
  localDW->UnitDelay_DSTATE = localDW->UnitDelay3_DSTATE;

  /* Outputs for Atomic SubSystem: '<S1004>/Debounce_Module2' */
  /* Logic: '<S1004>/Logical Operator9' incorporates:
   *  Constant: '<S1004>/Constant2'
   *  Constant: '<S1004>/Constant5'
   *  Constant: '<S1004>/Constant8'
   *  Logic: '<S1004>/Logical Operator7'
   *  RelationalOperator: '<S1004>/Relational Operator12'
   *  RelationalOperator: '<S1004>/Relational Operator7'
   *  UnitDelay: '<S1004>/Unit Delay'
   *  UnitDelay: '<S1004>/Unit Delay2'
   */
  rtb_Out_k = app_Debounce_Module_b(localDW->UnitDelay2_DSTATE &&
    (rtu_DFIn_d_CODPACCFMRdrLongtDist_sg < P_ACC_d_HMIObjDetMovObjDist_sg) &&
    (rtu_DFIn_indx_CODPACCTgtID_u8 == localDW->UnitDelay_DSTATE),
    P_ACC_t_HMIObjDetMovObjTmCfm_sg, localC->TmpSignalConversionAtDebounce_Mo_k,
    0.02F, &localDW->Debounce_Module2);

  /* End of Outputs for SubSystem: '<S1004>/Debounce_Module2' */

  /* Chart: '<S1004>/Chart' incorporates:
   *  Constant: '<S1004>/Constant12'
   *  Logic: '<S1004>/Logical Operator10'
   *  Logic: '<S1004>/Logical Operator5'
   *  RelationalOperator: '<S1004>/Relational Operator'
   */
  if ((uint32_T)localDW->is_active_c93_app == 0U) {
    localDW->is_active_c93_app = 1U;
    if (rtu_DFIn_is_VDPVehSdslSts_bl) {
      localDW->is_c93_app = app_IN_EgoVeh_Stsl;
      localDW->is_EgoVeh_Stsl = app_IN_Obj_Stdy;
      rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
    } else {
      localDW->is_c93_app = app_IN_EgoVeh_Mov;
      rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
    }
  } else if (localDW->is_c93_app == app_IN_EgoVeh_Mov) {
    if (rtu_DFIn_is_VDPVehSdslSts_bl) {
      localDW->is_c93_app = app_IN_EgoVeh_Stsl;
      localDW->is_EgoVeh_Stsl = app_IN_Obj_Stdy;
      rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
    } else {
      rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
    }
  } else {
    /* case IN_EgoVeh_Stsl: */
    if (!rtu_DFIn_is_VDPVehSdslSts_bl) {
      localDW->is_Obj_ChgOrDet = app_IN_NO_ACTIVE_CHILD_e;
      localDW->is_EgoVeh_Stsl = app_IN_NO_ACTIVE_CHILD_e;
      localDW->is_c93_app = app_IN_EgoVeh_Mov;
      rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
    } else if (localDW->is_EgoVeh_Stsl == app_IN_Obj_ChgOrDet) {
      if (!rtu_DFIn_is_CODPFoloTgtExist_bl) {
        localDW->is_Obj_ChgOrDet = app_IN_NO_ACTIVE_CHILD_e;
        localDW->is_EgoVeh_Stsl = app_IN_Obj_Stdy;
        rtb_RelationalOperator3_m = false;
      } else if (localDW->is_Obj_ChgOrDet == app_IN_Obj_NotVld) {
        if (rtb_Out_a || rtb_Out_k) {
          localDW->is_Obj_ChgOrDet = app_IN_Obj_Vld;
          rtb_RelationalOperator3_m = true;
        } else {
          rtb_RelationalOperator3_m = false;
        }
      } else {
        /* case IN_Obj_Vld: */
        rtb_RelationalOperator3_m = true;
      }
    } else {
      /* case IN_Obj_Stdy: */
      if (((int32_T)rtu_DFIn_indx_CODPACCTgtID_u8 != 0) &&
          rtb_RelationalOperator3_m) {
        localDW->is_EgoVeh_Stsl = app_IN_Obj_ChgOrDet;
        localDW->is_Obj_ChgOrDet = app_IN_Obj_NotVld;
        rtb_RelationalOperator3_m = false;
      } else {
        rtb_RelationalOperator3_m = rtu_DFIn_is_CODPFoloTgtExist_bl;
      }
    }
  }

  /* End of Chart: '<S1004>/Chart' */

  /* DataTypeConversion: '<S1004>/Data Type Conversion2' incorporates:
   *  Constant: '<S1004>/BrkPdlSw_on'
   *  Constant: '<S1004>/TCSOpngStsActive1'
   *  Constant: '<S1004>/TCSOpngStsActive10'
   *  Constant: '<S1004>/TCSOpngStsActive11'
   *  Constant: '<S1004>/TCSOpngStsActive2'
   *  Constant: '<S1004>/TCSOpngStsActive4'
   *  Constant: '<S1004>/TCSOpngStsActive9'
   *  Logic: '<S1004>/Logical Operator'
   *  Logic: '<S1004>/Logical Operator1'
   *  Logic: '<S1004>/Logical Operator2'
   *  Logic: '<S1004>/Logical Operator23'
   *  Logic: '<S1004>/Logical Operator24'
   *  Logic: '<S1004>/Logical Operator3'
   *  Logic: '<S1004>/Logical Operator4'
   *  RelationalOperator: '<S1004>/Relational Operator1'
   *  RelationalOperator: '<S1004>/Relational Operator10'
   *  RelationalOperator: '<S1004>/Relational Operator11'
   *  RelationalOperator: '<S1004>/Relational Operator2'
   *  RelationalOperator: '<S1004>/Relational Operator25'
   *  RelationalOperator: '<S1004>/Relational Operator26'
   *  RelationalOperator: '<S1004>/Relational Operator9'
   */
  rty_ACC_is_HMIObjDet_u8_0 = (uint8_T)(rtb_RelationalOperator3_m &&
    ((rtu_ACC_indx_SMRSts_en == eCruiseCCC) || (rtu_ACC_indx_SMRSts_en ==
    eCruiseACCApproaching) || (rtu_ACC_indx_SMRSts_en ==
    eACCReqStsActiveOverride) || (rtu_ACC_indx_SMRSts_en == eStandStillActive) ||
     (rtu_ACC_indx_SMRSts_en == eStandStillWait) || (rtu_ACC_indx_SMRSts_en ==
    eACCReqStsBrkOnly) || (rtu_ACC_indx_SMRSts_en == eACCReqStsStandby)));

  /* Update for UnitDelay: '<S1004>/Unit Delay' */
  localDW->UnitDelay_DSTATE = rtu_DFIn_indx_CODPACCTgtID_u8;

  /* Update for UnitDelay: '<S1004>/Unit Delay1' */
  localDW->UnitDelay1_DSTATE = rtu_DFIn_indx_CODPACCTgtID_u8;

  /* Update for UnitDelay: '<S1004>/Unit Delay3' */
  localDW->UnitDelay3_DSTATE = rtu_DFIn_indx_CODPACCTgtID_u8;
  return rty_ACC_is_HMIObjDet_u8_0;
}

/* Output and update for atomic system: '<S997>/HMI_ACCSeldDistLvl' */
uint8_T app_HMI_ACCSeldDistLvl(eDSL_DrvrSetLvl rtu_ACC_indx_DISTmDistLvl_en)
{
  /* DataTypeConversion: '<S1005>/Data Type Conversion' */
  return (uint8_T)rtu_ACC_indx_DISTmDistLvl_en;
}

/* System initialize for atomic system: '<S997>/HMI_ACCSysCanclReq' */
void app_HMI_ACCSysCanclReq_Init(eCCR_ACCCancelReq
  *rty_ACC_indx_HMISysCanclReq_u8)
{
  /* SystemInitialize for Chart: '<S1006>/ACCSysCanclReq' */
  *rty_ACC_indx_HMISysCanclReq_u8 = CCR_NoCancl;
}

/* Output and update for atomic system: '<S997>/HMI_ACCSysCanclReq' */
eCCR_ACCCancelReq app_HMI_ACCSysCanclReq(boolean_T
  rtu_DFIn_is_VDPACCSwCanclSw_bl, E_ACCReqSts_t rtu_ACC_indx_SMRSts_en,
  DW_HMI_ACCSysCanclReq_app_T *localDW)
{
  eCCR_ACCCancelReq rty_ACC_indx_HMISysCanclReq_u8_0;

  /* Chart: '<S1006>/ACCSysCanclReq' incorporates:
   *  UnitDelay: '<S1006>/Unit Delay'
   */
  if (rtu_DFIn_is_VDPACCSwCanclSw_bl && (rtu_ACC_indx_SMRSts_en ==
       eACCReqStsStandby) && (localDW->UnitDelay_DSTATE == eACCReqStsActive)) {
    rty_ACC_indx_HMISysCanclReq_u8_0 = CCR_ManualCancl;
  } else if ((!rtu_DFIn_is_VDPACCSwCanclSw_bl) && (rtu_ACC_indx_SMRSts_en ==
              eACCReqStsStandby) && (localDW->UnitDelay_DSTATE ==
              eACCReqStsActive)) {
    rty_ACC_indx_HMISysCanclReq_u8_0 = CCR_ACC_CondDissatf;
  } else {
    rty_ACC_indx_HMISysCanclReq_u8_0 = CCR_NoCancl;
  }

  /* End of Chart: '<S1006>/ACCSysCanclReq' */

  /* Update for UnitDelay: '<S1006>/Unit Delay' */
  localDW->UnitDelay_DSTATE = rtu_ACC_indx_SMRSts_en;
  return rty_ACC_indx_HMISysCanclReq_u8_0;
}

/* Output and update for atomic system: '<S997>/HMI_ACCSysFltStsHMI_WithSCS' */
eFLT_SysFltSts app_HMI_ACCSysFltStsHMI_WithSCS(boolean_T
  rtu_DFIn_is_VDPACCSwOnSw_bl, boolean_T rtu_DFIn_is_FDP_ACCTmpUnavablFlg_bl,
  boolean_T rtu_DFIn_is_FDP_ACCServReqFlg_bl, ePWR_PwrMd
  rtu_DFIn_indx_VDPSysPwrMd_en, boolean_T rtu_DFIn_is_CCFMRFltFSMWtSCS_bl)
{
  eFLT_SysFltSts rty_ACC_indx_HMISysFltStsHMI_u8_0;

  /* Switch: '<S1007>/Switch' incorporates:
   *  Constant: '<S1007>/Constant'
   *  Constant: '<S1007>/Constant1'
   *  RelationalOperator: '<S1007>/Relational Operator'
   */
  if (rtu_DFIn_indx_VDPSysPwrMd_en == PWR_Run) {
    /* Chart: '<S1007>/ACC_ACCSysFltStsHMI' */
    if (rtu_DFIn_is_FDP_ACCServReqFlg_bl && rtu_DFIn_is_VDPACCSwOnSw_bl) {
      rty_ACC_indx_HMISysFltStsHMI_u8_0 = FLT_ServReq;
    } else if ((rtu_DFIn_is_FDP_ACCTmpUnavablFlg_bl ||
                rtu_DFIn_is_CCFMRFltFSMWtSCS_bl) && rtu_DFIn_is_VDPACCSwOnSw_bl)
    {
      rty_ACC_indx_HMISysFltStsHMI_u8_0 = FLT_TmpUnavabl;
    } else {
      rty_ACC_indx_HMISysFltStsHMI_u8_0 = FLT_NoError;
    }

    /* End of Chart: '<S1007>/ACC_ACCSysFltStsHMI' */
  } else {
    rty_ACC_indx_HMISysFltStsHMI_u8_0 = FLT_NoError;
  }

  /* End of Switch: '<S1007>/Switch' */
  return rty_ACC_indx_HMISysFltStsHMI_u8_0;
}

/* System initialize for atomic system: '<S997>/HMI_ACCSysStsJud' */
void app_HMI_ACCSysStsJud_Init(E_ACCReqSts_t *rty_ACC_indx_HMISysSts_u8)
{
  /* SystemInitialize for Chart: '<S1008>/ACCReqSts2Output' */
  *rty_ACC_indx_HMISysSts_u8 = eACCReqStsOff;
}

/* Output and update for atomic system: '<S997>/HMI_ACCSysStsJud' */
E_ACCReqSts_t app_HMI_ACCSysStsJud(E_ACCReqSts_t rtu_ACC_indx_SMRSts_en)
{
  E_ACCReqSts_t rty_ACC_indx_HMISysSts_u8_0;

  /* Chart: '<S1008>/ACCReqSts2Output' */
  if (rtu_ACC_indx_SMRSts_en == eACCReqStsOff) {
    rty_ACC_indx_HMISysSts_u8_0 = eACCReqStsOff;
  } else if ((rtu_ACC_indx_SMRSts_en == eACCReqStsStandby) ||
             (rtu_ACC_indx_SMRSts_en == eACCRevsFault) ||
             (rtu_ACC_indx_SMRSts_en == eACCIRRevsFault)) {
    rty_ACC_indx_HMISysSts_u8_0 = eACCReqStsStandby;
  } else {
    switch (rtu_ACC_indx_SMRSts_en) {
     case eACCReqStsActiveOverride:
      rty_ACC_indx_HMISysSts_u8_0 = eACCReqStsActiveOverride;
      break;

     case eACCReqStsBrkOnly:
      rty_ACC_indx_HMISysSts_u8_0 = eACCReqStsBrkOnly;
      break;

     case eStandStillActive:
      rty_ACC_indx_HMISysSts_u8_0 = eStandStillActive;
      break;

     case eStandStillWait:
      rty_ACC_indx_HMISysSts_u8_0 = eStandStillWait;
      break;

     default:
      rty_ACC_indx_HMISysSts_u8_0 = eACCReqStsActive;
      break;
    }
  }

  /* End of Chart: '<S1008>/ACCReqSts2Output' */
  return rty_ACC_indx_HMISysSts_u8_0;
}

/* System initialize for atomic system: '<S1023>/EstdLongtAccel1' */
void app_EstdLongtAccel1_Init(B_EstdLongtAccel1_app_T *localB)
{
  /* SystemInitialize for Chart: '<S1041>/Timing_Counter'
   *
   * Block description for '<S1041>/Timing_Counter':
   *  %This module is used for measurement the counters when the signals satisfying the condition.
   *  E.g. If ABS_Active Signal is received and lasting for 150ms(15 counters), we trust this signal, otherwise NOT.
   */
  app_DFIn_TmCntrSF_TRUE1_Init(&localB->OutPut);
}

/* Output and update for atomic system: '<S1023>/EstdLongtAccel1' */
real32_T app_EstdLongtAccel1(real32_T rtu_DFIn_v_AvgWhlGndVel_sg, real32_T
  rtu_DFIn_v_EgoAvgVehSpd_sg, B_EstdLongtAccel1_app_T *localB,
  DW_EstdLongtAccel1_app_T *localDW)
{
  real32_T rty_DFIn_a_EstdLongtAccelMnFilt_sg_0;
  int_T i;
  real32_T maxV;
  real32_T rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg;
  real32_T rtb_Switch2_ez;
  uint8_T rtb_DataTypeConversion1_g;

  /* Chart: '<S1041>/Timing_Counter' incorporates:
   *  Constant: '<S1041>/2 wheels2'
   *  Constant: '<S1041>/2 wheels4'
   *  Constant: '<S1041>/C_system_step_1'
   *  Product: '<S1041>/Divide6'
   *  RelationalOperator: '<S1041>/Relational Operator1'
   *
   * Block description for '<S1041>/Timing_Counter':
   *  %This module is used for measurement the counters when the signals satisfying the condition.
   *  E.g. If ABS_Active Signal is received and lasting for 150ms(15 counters), we trust this signal, otherwise NOT.
   *
   * Block description for '<S1041>/2 wheels4':
   *  Unit:m/s
   *  Every Ten_CycleDelay indcates a 0.1s delay.

   *
   * Block description for '<S1041>/C_system_step_1':
   *  % C_system_step = 0.01s.
   */
  app_DFIn_TmCntrSF_TRUE1(rtu_DFIn_v_EgoAvgVehSpd_sg > 0.0F,
    C_DFIn_t_AccelDelyFilt_sg / 0.02F, &localB->OutPut,
    &localDW->sf_Timing_Counter);

  /* MinMax: '<S1042>/MinMax' incorporates:
   *  S-Function (sfix_udelay): '<S1042>/Tapped Delay'
   */
  rtb_Switch2_ez = localDW->TappedDelay_X[0];
  for (i = 0; i < 29; i++) {
    rtb_Switch2_ez = fminf(rtb_Switch2_ez, localDW->TappedDelay_X[(int32_T)(i +
      1)]);
  }

  /* Sum: '<S1042>/Sum of Elements' incorporates:
   *  S-Function (sfix_udelay): '<S1042>/Tapped Delay'
   */
  rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = -0.0F;
  for (i = 0; i < 30; i++) {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg += localDW->TappedDelay_X[i];
  }

  /* MinMax: '<S1042>/MinMax1' incorporates:
   *  S-Function (sfix_udelay): '<S1042>/Tapped Delay'
   */
  maxV = localDW->TappedDelay_X[0];
  for (i = 0; i < 29; i++) {
    maxV = fmaxf(maxV, localDW->TappedDelay_X[(int32_T)(i + 1)]);
  }

  /* DataTypeConversion: '<S1042>/Data Type Conversion27' incorporates:
   *  Constant: '<S1042>/2 wheels3'
   *  Constant: '<S1042>/P_VDC_FSCAccelCmftUpRt_sg'
   *  MinMax: '<S1042>/MinMax'
   *  MinMax: '<S1042>/MinMax1'
   *  Product: '<S1042>/Divide'
   *  Product: '<S1042>/Divide1'
   *  Product: '<S1042>/Divide2'
   *  Sum: '<S1042>/Add'
   *  Sum: '<S1042>/Subtract'
   *  Sum: '<S1042>/Sum of Elements'
   */
  rty_DFIn_a_EstdLongtAccelMnFilt_sg_0 = (real32_T)((real_T)
    ((rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg - rtb_Switch2_ez) - maxV) /
    (P_DFIn_cntr_DelayCntr_d * 0.0099999997764825821 / 0.019999999552965164 -
     2.0));

  /* Product: '<S1041>/Divide1' incorporates:
   *  Constant: '<S1041>/2 wheels3'
   *  Constant: '<S1041>/C_system_step_2'
   *
   * Block description for '<S1041>/2 wheels3':
   *  Unit:m/s
   *  Every Ten_CycleDelay indcates a 0.1s delay.

   *
   * Block description for '<S1041>/C_system_step_2':
   *  % C_system_step = 0.01s.
   */
  rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = C_DFIn_t_AccelDelyFilt_sg / 0.02F;

  /* DataTypeConversion: '<S1041>/Data Type Conversion1' */
  rtb_Switch2_ez = fabsf(rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg);
  if (rtb_Switch2_ez < 8.388608E+6F) {
    if (rtb_Switch2_ez >= 0.5F) {
      rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = floorf
        (rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg + 0.5F);
    } else {
      rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg *= 0.0F;
    }
  }

  if (rtIsNaNF(rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg) || rtIsInfF
      (rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg)) {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = 0.0F;
  } else {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = fmodf
      (rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg, 256.0F);
  }

  rtb_DataTypeConversion1_g = (uint8_T)(rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg <
    0.0F ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)
    -rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg : (int32_T)(uint8_T)
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg);

  /* End of DataTypeConversion: '<S1041>/Data Type Conversion1' */

  /* Delay: '<S1041>/Delay' */
  if ((int32_T)rtb_DataTypeConversion1_g <= 0) {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = rtu_DFIn_v_AvgWhlGndVel_sg;
  } else {
    if ((int32_T)rtb_DataTypeConversion1_g > 100) {
      rtb_DataTypeConversion1_g = 100U;
    }

    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = localDW->Delay_DSTATE[(uint8_T)
      (uint32_T)(100U - (uint32_T)rtb_DataTypeConversion1_g)];
  }

  /* End of Delay: '<S1041>/Delay' */

  /* Switch: '<S1041>/Switch13' incorporates:
   *  Constant: '<S1041>/2 wheels'
   *  Constant: '<S1041>/2 wheels1'
   *  Product: '<S1041>/Divide'
   *  Sum: '<S1041>/Subtract'
   *
   * Block description for '<S1041>/Switch13':
   *  /+ +/
   *
   * Block description for '<S1041>/2 wheels':
   *  Unit:m/s
   *  Every Ten_CycleDelay indcates a 0.1s delay.

   */
  if (localB->OutPut) {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = (rtu_DFIn_v_AvgWhlGndVel_sg -
      rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg) / C_DFIn_t_AccelDelyFilt_sg;
  } else {
    rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg = 0.0F;
  }

  /* End of Switch: '<S1041>/Switch13' */

  /* Sum: '<S1045>/Difference Inputs1' incorporates:
   *  UnitDelay: '<S1045>/Delay Input2'
   *
   * Block description for '<S1045>/Difference Inputs1':
   *
   *  Add in CPU
   *
   * Block description for '<S1045>/Delay Input2':
   *
   *  Store in Global RAM
   */
  rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg -= localDW->DelayInput2_DSTATE;

  /* Product: '<S1045>/delta rise limit' incorporates:
   *  Constant: '<S1043>/P_VDC_FSCAccelCmftUpRt_sg'
   *  SampleTimeMath: '<S1045>/sample time'
   *
   * About '<S1045>/sample time':
   *  y = K where K = ( w * Ts )
   */
  rtb_Switch2_ez = 0.8F;

  /* Switch: '<S1046>/Switch2' incorporates:
   *  RelationalOperator: '<S1046>/LowerRelop1'
   */
  if (!(rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg > 0.8F)) {
    /* Switch: '<S1046>/Switch' incorporates:
     *  RelationalOperator: '<S1046>/UpperRelop'
     */
    if (rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg < -0.8F) {
      rtb_Switch2_ez = -0.8F;
    } else {
      rtb_Switch2_ez = rtb_DFIn_v_AvgWhlGndVel_60CycDly_sg;
    }

    /* End of Switch: '<S1046>/Switch' */
  }

  /* End of Switch: '<S1046>/Switch2' */

  /* Sum: '<S1045>/Difference Inputs2' incorporates:
   *  UnitDelay: '<S1045>/Delay Input2'
   *
   * Block description for '<S1045>/Difference Inputs2':
   *
   *  Add in CPU
   *
   * Block description for '<S1045>/Delay Input2':
   *
   *  Store in Global RAM
   */
  localDW->DelayInput2_DSTATE += rtb_Switch2_ez;

  /* Update for S-Function (sfix_udelay): '<S1042>/Tapped Delay' incorporates:
   *  UnitDelay: '<S1045>/Delay Input2'
   *
   * Block description for '<S1045>/Delay Input2':
   *
   *  Store in Global RAM
   */
  for (i = 0; i < 29; i++) {
    localDW->TappedDelay_X[i] = localDW->TappedDelay_X[(int_T)(i + 1)];
  }

  localDW->TappedDelay_X[29] = localDW->DelayInput2_DSTATE;

  /* End of Update for S-Function (sfix_udelay): '<S1042>/Tapped Delay' */

  /* Update for Delay: '<S1041>/Delay' */
  for (i = 0; i < 99; i++) {
    localDW->Delay_DSTATE[i] = localDW->Delay_DSTATE[(int_T)(i + 1)];
  }

  localDW->Delay_DSTATE[99] = rtu_DFIn_v_AvgWhlGndVel_sg;

  /* End of Update for Delay: '<S1041>/Delay' */
  return rty_DFIn_a_EstdLongtAccelMnFilt_sg_0;
}

/* System initialize for atomic system: '<S1023>/EstdVSELongtAccel' */
void app_EstdVSELongtAccel_Init(B_EstdVSELongtAccel_app_T *localB)
{
  /* SystemInitialize for Chart: '<S1039>/TimingCounterFun'
   *
   * Block description for '<S1039>/TimingCounterFun':
   *  %This module is used for measurement the counters when the signals satisfying the condition.
   *  E.g. If ABS_Active Signal is received and lasting for 150ms(15 counters), we trust this signal, otherwise NOT.
   */
  app_DFIn_TmCntrSF_TRUE1_Init(&localB->OutPut);
}

/* Output and update for atomic system: '<S1023>/EstdVSELongtAccel' */
void app_EstdVSELongtAccel(real32_T rtu_DFIn_v_AvgVehSpd_d, real32_T
  rtu_DFIn_a_EstdLongtAccelMnFilt_sg, real32_T rtu_DFIn_a_VSELongtAccel_sg,
  real32_T *rty_DFIn_a_EstdVSELongtAccel_sg, B_EstdVSELongtAccel_app_T *localB,
  DW_EstdVSELongtAccel_app_T *localDW)
{
  /* Chart: '<S1039>/TimingCounterFun' incorporates:
   *  Constant: '<S1039>/2 wheels2'
   *  Constant: '<S1039>/C_system_step_4'
   *  Constant: '<S1039>/P_DFIn_t_VSELongtAccelFilter'
   *  Product: '<S1039>/Divide3'
   *  RelationalOperator: '<S1039>/Relational Operator10'
   *
   * Block description for '<S1039>/TimingCounterFun':
   *  %This module is used for measurement the counters when the signals satisfying the condition.
   *  E.g. If ABS_Active Signal is received and lasting for 150ms(15 counters), we trust this signal, otherwise NOT.
   *
   * Block description for '<S1039>/C_system_step_4':
   *  % C_system_step = 0.01s.
   *
   * Block description for '<S1039>/P_DFIn_t_VSELongtAccelFilter':
   *  The cycle of the acceleration signal is 20ms =0.02s;
   *  This parameter is used as a time threshold.
   *  When the time length is larger than this value, the conditions is considered as satisfied.
   */
  app_DFIn_TmCntrSF_TRUE1(rtu_DFIn_a_VSELongtAccel_sg == 0.0F,
    P_DFIn_t_VSELongtAccelFilter_sg / 0.02F, &localB->OutPut,
    &localDW->sf_TimingCounterFun);

  /* Switch: '<S1039>/Switch1' incorporates:
   *  Abs: '<S1039>/Abs1'
   *  Constant: '<S1039>/2 wheels1'
   *  Constant: '<S1039>/2 wheels4'
   *  Constant: '<S1039>/2 wheels5'
   *  Logic: '<S1039>/Logical Operator8'
   *  RelationalOperator: '<S1039>/Relational Operator11'
   *  RelationalOperator: '<S1039>/Relational Operator8'
   *  Switch: '<S1039>/Switch7'
   *
   * Block description for '<S1039>/2 wheels5':
   *  Unit:m/s^2
   *  Constant ZERO

   */
  if (rtu_DFIn_v_AvgVehSpd_d == 0.0F) {
    *rty_DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else if (localB->OutPut && (P_DFIn_a_EstdLogAccTrtLoThrs_sg >= fabsf
              (rtu_DFIn_a_EstdLongtAccelMnFilt_sg))) {
    /* Switch: '<S1039>/Switch7' */
    *rty_DFIn_a_EstdVSELongtAccel_sg = rtu_DFIn_a_VSELongtAccel_sg;
  } else {
    *rty_DFIn_a_EstdVSELongtAccel_sg = rtu_DFIn_a_EstdLongtAccelMnFilt_sg;
  }

  /* End of Switch: '<S1039>/Switch1' */
}

/*
 * System initialize for atomic system:
 *    '<S1030>/Hyseresis_Keep'
 *    '<S1030>/Hyseresis_Keep1'
 */
void app_Hyseresis_Keep_Init(boolean_T *rty_TrgEnbl_bl)
{
  /* SystemInitialize for Chart: '<S1054>/DFIn_TmCntrSF_TRUE'
   *
   * Block description for '<S1054>/DFIn_TmCntrSF_TRUE':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   */
  *rty_TrgEnbl_bl = false;
}

/*
 * Output and update for atomic system:
 *    '<S1030>/Hyseresis_Keep'
 *    '<S1030>/Hyseresis_Keep1'
 */
void app_Hyseresis_Keep(boolean_T rtu_Trg_bl, boolean_T *rty_TrgEnbl_bl, const
  ConstB_Hyseresis_Keep_app_T *localC, DW_Hyseresis_Keep_app_T *localDW)
{
  int32_T tmp;

  /* Chart: '<S1054>/DFIn_TmCntrSF_TRUE'
   *
   * Block description for '<S1054>/DFIn_TmCntrSF_TRUE':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   */
  if ((uint32_T)localDW->is_active_c104_app == 0U) {
    localDW->is_active_c104_app = 1U;
    localDW->is_c104_app = app_IN_Initial_Condition_i;
    *rty_TrgEnbl_bl = false;
    localDW->status_counter = 0U;
  } else {
    switch (localDW->is_c104_app) {
     case app_IN_Counter_Satisfy_Condition_a:
      if (!rtu_Trg_bl) {
        localDW->is_c104_app = app_IN_Initial_Condition_i;
        *rty_TrgEnbl_bl = false;
        localDW->status_counter = 0U;
      }
      break;

     case app_IN_Initial_Condition_i:
      if (rtu_Trg_bl) {
        localDW->is_c104_app = app_IN_Middle_Condition_c;
        *rty_TrgEnbl_bl = false;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      }
      break;

     default:
      /* case IN_Middle_Condition: */
      if (localDW->status_counter >= localC->DataTypeConversion11) {
        localDW->is_c104_app = app_IN_Counter_Satisfy_Condition_a;
        *rty_TrgEnbl_bl = true;
        localDW->status_counter = 0U;
      } else if (!rtu_Trg_bl) {
        localDW->is_c104_app = app_IN_Initial_Condition_i;
        *rty_TrgEnbl_bl = false;
        localDW->status_counter = 0U;
      } else {
        *rty_TrgEnbl_bl = false;
        tmp = (int32_T)((int32_T)localDW->status_counter + 1);
        if ((int32_T)((int32_T)localDW->status_counter + 1) > 65535) {
          tmp = 65535;
        }

        localDW->status_counter = (uint16_T)tmp;
      }
      break;
    }
  }

  /* End of Chart: '<S1054>/DFIn_TmCntrSF_TRUE' */
}

/* Output and update for atomic system: '<S1035>/VehSpdVaild' */
void app_VehSpdVaild(real32_T rtu_DA_IN_WhlGndVelLNonDrvn_sg, real32_T
                     rtu_DA_IN_WhlGndVelRNonDrvn_sg, real32_T
                     rtu_DA_IN_WhlGndVelLDrvn_sg, real32_T
                     rtu_DA_IN_WhlGndVelRDrvn_sg, boolean_T
                     rtu_DFIn_is_VIDPRolBckNoSpdThrs_bl, eVLD_ValidSts
                     *rty_DFIn_indx_EgoVehSpdV_en, real32_T
                     *rty_DFIn_v_AvgWhlGndVel_sg, const ConstB_VehSpdVaild_app_T
                     *localC, DW_VehSpdVaild_app_T *localDW)
{
  real32_T u0;
  uint8_T rtb_Switch1_ot;
  uint8_T rtb_Switch5_a;
  boolean_T rtb_RelationalOperator10_c;
  boolean_T rtb_RelationalOperator11_gx;
  boolean_T rtb_RelationalOperator1_g;
  boolean_T rtb_RelationalOperator9_b;

  /* RelationalOperator: '<S1062>/Relational Operator1' incorporates:
   *  Constant: '<S1062>/Constant3'
   *
   * Block description for '<S1062>/Constant3':
   *  /+ wheel speed error value. +/
   */
  rtb_RelationalOperator1_g = (rtu_DA_IN_WhlGndVelLNonDrvn_sg == 10000.0F);

  /* Switch: '<S1062>/Switch5' */
  rtb_Switch5_a = (uint8_T)!rtb_RelationalOperator1_g;

  /* RelationalOperator: '<S1062>/Relational Operator9' incorporates:
   *  Constant: '<S1062>/Constant3'
   *
   * Block description for '<S1062>/Constant3':
   *  /+ wheel speed error value. +/
   */
  rtb_RelationalOperator9_b = (rtu_DA_IN_WhlGndVelRNonDrvn_sg == 10000.0F);

  /* Switch: '<S1062>/Switch1' */
  rtb_Switch1_ot = (uint8_T)!rtb_RelationalOperator9_b;

  /* Product: '<S1062>/Divide4' incorporates:
   *  Constant: '<S1062>/2 wheels2'
   *  Product: '<S1062>/Product'
   *  Product: '<S1062>/Product1'
   *  Sum: '<S1062>/Add3'
   */
  u0 = ((real32_T)rtb_Switch5_a * rtu_DA_IN_WhlGndVelLNonDrvn_sg + (real32_T)
        rtb_Switch1_ot * rtu_DA_IN_WhlGndVelRNonDrvn_sg) / 2.0F;

  /* Saturate: '<S1062>/Saturation'
   *
   * Block description for '<S1062>/Saturation':
   *  unit: m/s
   */
  if (u0 > ACC_v_VIDPEgoSpdMax_sg) {
    u0 = ACC_v_VIDPEgoSpdMax_sg;
  } else {
    if (u0 < ACC_v_VIDPEgoSpdMin_sg) {
      u0 = ACC_v_VIDPEgoSpdMin_sg;
    }
  }

  /* End of Saturate: '<S1062>/Saturation' */

  /* MinMax: '<S1062>/MinMax2' incorporates:
   *  Sum: '<S1062>/Add1'
   *  UnitDelay: '<S1062>/Unit Delay'
   *
   * Block description for '<S1062>/MinMax2':
   *  /+ The vehicle speed calculated from the wheel speed shall be filtered by the max deceleration.
   *     In future the algorithm could be improved according to the Vref of ABS. +/
   */
  localDW->UnitDelay_DSTATE = fmaxf(localDW->UnitDelay_DSTATE - localC->Divide5,
    u0);

  /* Switch: '<S1062>/Switch' incorporates:
   *  Abs: '<S1062>/Abs'
   *  Gain: '<S1062>/Gain'
   */
  if (rtu_DFIn_is_VIDPRolBckNoSpdThrs_bl) {
    *rty_DFIn_v_AvgWhlGndVel_sg = -fabsf(localDW->UnitDelay_DSTATE);
  } else {
    *rty_DFIn_v_AvgWhlGndVel_sg = localDW->UnitDelay_DSTATE;
  }

  /* End of Switch: '<S1062>/Switch' */

  /* RelationalOperator: '<S1062>/Relational Operator10' incorporates:
   *  Constant: '<S1062>/Constant3'
   *
   * Block description for '<S1062>/Constant3':
   *  /+ wheel speed error value. +/
   */
  rtb_RelationalOperator10_c = (rtu_DA_IN_WhlGndVelLDrvn_sg == 10000.0F);

  /* RelationalOperator: '<S1062>/Relational Operator11' incorporates:
   *  Constant: '<S1062>/Constant3'
   *
   * Block description for '<S1062>/Constant3':
   *  /+ wheel speed error value. +/
   */
  rtb_RelationalOperator11_gx = (rtu_DA_IN_WhlGndVelRDrvn_sg == 10000.0F);

  /* Switch: '<S1062>/Switch4' incorporates:
   *  Constant: '<S1062>/Constant1'
   *  Constant: '<S1062>/Valid_ENM1'
   *  Constant: '<S1062>/Valid_ENM2'
   *  Logic: '<S1062>/Logical Operator1'
   *  Logic: '<S1062>/Logical Operator6'
   *  Logic: '<S1062>/Logical Operator7'
   *  RelationalOperator: '<S1062>/Relational Operator12'
   *  Sum: '<S1062>/Add2'
   *  Switch: '<S1062>/Switch2'
   *  Switch: '<S1062>/Switch3'
   *
   * Block description for '<S1062>/Logical Operator6':
   *  /+ If the two wheel speed in same axle are error, the vehicle speed is
   *  invalid. +/
   */
  if (((int32_T)(uint32_T)((uint32_T)((uint32_T)((uint32_T)rtb_Switch5_a +
          (uint32_T)rtb_Switch1_ot) + (uint32_T)!rtb_RelationalOperator10_c) +
        (uint32_T)!rtb_RelationalOperator11_gx) <= 2) ||
      (rtb_RelationalOperator1_g || rtb_RelationalOperator9_b) ||
      (rtb_RelationalOperator10_c && rtb_RelationalOperator11_gx)) {
    *rty_DFIn_indx_EgoVehSpdV_en = VLD_Invalid;
  } else {
    *rty_DFIn_indx_EgoVehSpdV_en = VLD_Valid;
  }

  /* End of Switch: '<S1062>/Switch4' */
}

/*
 * System initialize for atomic system:
 *    '<S1063>/Chart'
 *    '<S1068>/Chart'
 */
void app_Chart_g_Init(uint8_T *rty_count)
{
  *rty_count = 0U;
}

/*
 * Output and update for atomic system:
 *    '<S1063>/Chart'
 *    '<S1068>/Chart'
 */
void app_Chart_k(uint8_T *rty_count)
{
  int32_T tmp;

  /* Chart: '<S1063>/Chart' */
  tmp = (int32_T)(uint32_T)((uint32_T)*rty_count + 1U);
  if ((uint32_T)((uint32_T)*rty_count + 1U) > 255U) {
    tmp = 255;
  }

  *rty_count = (uint8_T)tmp;
  if ((int32_T)*rty_count > 15) {
    *rty_count = 0U;
  }

  /* End of Chart: '<S1063>/Chart' */
}

/*
 * Output and update for atomic system:
 *    '<S1067>/Chart4'
 *    '<S1120>/Chart1'
 *    '<S1120>/Chart2'
 *    '<S1120>/Chart3'
 *    '<S1121>/Chart13'
 *    '<S1121>/Chart4'
 *    '<S1121>/Chart5'
 *    '<S1121>/Chart6'
 *    '<S1121>/Chart7'
 *    '<S1144>/Chart1'
 *    ...
 */
void app_Chart4(boolean_T rtu_in_cond, real32_T rtu_loop_time, real32_T
                rtu_rise_time, real32_T rtu_fall_time, boolean_T *rty_out_cond,
                DW_Chart4_app_T *localDW)
{
  /* Chart: '<S1067>/Chart4' */
  if ((uint32_T)localDW->is_active_c32_app == 0U) {
    localDW->is_active_c32_app = 1U;
    localDW->is_c32_app = app_IN_OFF_j;
    *rty_out_cond = false;
    localDW->local_time = 0.0F;
  } else if (localDW->is_c32_app == app_IN_OFF_j) {
    *rty_out_cond = false;
    if (localDW->local_time > rtu_rise_time) {
      localDW->is_c32_app = app_IN_ON_i;
      *rty_out_cond = true;
      localDW->local_time = 0.0F;
    } else if (rtu_in_cond) {
      localDW->local_time += rtu_loop_time;
    } else {
      localDW->local_time = 0.0F;
    }
  } else {
    /* case IN_ON: */
    *rty_out_cond = true;
    if (localDW->local_time > rtu_fall_time) {
      localDW->is_c32_app = app_IN_OFF_j;
      *rty_out_cond = false;
      localDW->local_time = 0.0F;
    } else if (!rtu_in_cond) {
      localDW->local_time += rtu_loop_time;
    } else {
      localDW->local_time = 0.0F;
    }
  }

  /* End of Chart: '<S1067>/Chart4' */
}

/*
 * Output and update for atomic system:
 *    '<S1069>/Chart1'
 *    '<S1069>/Chart2'
 */
void app_Chart1_p(boolean_T rtu_Arb_is_LatCtrlActv_bl, boolean_T rtu_lane_cond,
                  uint8_T *rty_out_cond)
{
  /* Chart: '<S1069>/Chart1' */
  if (rtu_lane_cond) {
    if (rtu_Arb_is_LatCtrlActv_bl) {
      *rty_out_cond = 2U;
    } else {
      *rty_out_cond = 1U;
    }
  } else {
    *rty_out_cond = 0U;
  }

  /* End of Chart: '<S1069>/Chart1' */
}

real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T tmp;
  real_T tmp_0;
  real_T y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else {
    tmp = fabs(u0);
    tmp_0 = fabs(u1);
    if (rtIsInf(u1)) {
      if (tmp == 1.0) {
        y = 1.0;
      } else if (tmp > 1.0) {
        if (u1 > 0.0) {
          y = (rtInf);
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = (rtInf);
      }
    } else if (tmp_0 == 0.0) {
      y = 1.0;
    } else if (tmp_0 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = (rtNaN);
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

/*
 * System initialize for atomic system:
 *    '<S1084>/Chart'
 *    '<S1098>/Chart'
 */
void app_Chart_i_Init(uint8_T rty_msg[64])
{
  memset(&rty_msg[0], 0, (uint32_T)(sizeof(uint8_T) << 6U));
}

/*
 * Output and update for atomic system:
 *    '<S1084>/Chart'
 *    '<S1098>/Chart'
 */
void app_Chart_g(uint8_T rtu_signal_len, uint8_T rtu_start_bit, uint32_T
                 rtu_signal_raw, const uint8_T rtu_msg_in[64], uint8_T rty_msg
                 [64])
{
  real_T tmp_tmp;
  int32_T tmp_0;
  uint32_T mod_data;
  uint32_T tmp;
  int8_T i;

  /* Chart: '<S1084>/Chart' */
  for (i = 0; (int32_T)i < 64; i = (int8_T)(int32_T)((int32_T)i + 1)) {
    rty_msg[(int32_T)i] = rtu_msg_in[i];
  }

  tmp_0 = (int32_T)((int32_T)rtu_signal_len - 1);
  if ((int32_T)((int32_T)rtu_signal_len - 1) > 127) {
    tmp_0 = 127;
  }

  i = (int8_T)tmp_0;
  mod_data = rtu_signal_raw;
  while ((int32_T)i >= 0) {
    tmp_tmp = rt_powd_snf(2.0, (real_T)i);
    tmp = (uint32_T)((real_T)mod_data / tmp_tmp);
    tmp_tmp = (real_T)mod_data - (real_T)tmp * tmp_tmp;
    if (tmp_tmp >= 0.0) {
      mod_data = (uint32_T)tmp_tmp;
    } else {
      mod_data = 0U;
    }

    if (tmp > 255U) {
      tmp = 255U;
    }

    rty_msg[(int32_T)((int32_T)((int32_T)rtu_start_bit - (int32_T)i) - 1)] =
      (uint8_T)tmp;
    i = (int8_T)(int32_T)((int32_T)i - 1);
  }

  /* End of Chart: '<S1084>/Chart' */
}

/*
 * System initialize for atomic system:
 *    '<S1085>/Chart'
 *    '<S1086>/Chart'
 *    '<S1087>/Chart'
 *    '<S1100>/Chart'
 *    '<S1101>/Chart'
 *    '<S1102>/Chart'
 */
void app_Chart_l_Init(uint8_T rty_msg[64])
{
  memset(&rty_msg[0], 0, (uint32_T)(sizeof(uint8_T) << 6U));
}

/*
 * Output and update for atomic system:
 *    '<S1085>/Chart'
 *    '<S1086>/Chart'
 *    '<S1087>/Chart'
 *    '<S1100>/Chart'
 *    '<S1101>/Chart'
 *    '<S1102>/Chart'
 */
void app_Chart_c(uint8_T rtu_signal_len, uint8_T rtu_start_bit, uint32_T
                 rtu_signal_raw, const uint8_T rtu_msg_in[64], uint8_T rty_msg
                 [64])
{
  real_T tmp_tmp;
  int32_T tmp_0;
  uint32_T mod_data;
  uint32_T tmp;
  int8_T i;

  /* Chart: '<S1085>/Chart' */
  for (i = 0; (int32_T)i < 64; i = (int8_T)(int32_T)((int32_T)i + 1)) {
    rty_msg[(int32_T)i] = rtu_msg_in[i];
  }

  tmp_0 = (int32_T)((int32_T)rtu_signal_len - 1);
  if ((int32_T)((int32_T)rtu_signal_len - 1) > 127) {
    tmp_0 = 127;
  }

  i = (int8_T)tmp_0;
  mod_data = rtu_signal_raw;
  while ((int32_T)i >= 0) {
    tmp_tmp = rt_powd_snf(2.0, (real_T)i);
    tmp = (uint32_T)((real_T)mod_data / tmp_tmp);
    tmp_tmp = (real_T)mod_data - (real_T)tmp * tmp_tmp;
    if (tmp_tmp >= 0.0) {
      mod_data = (uint32_T)tmp_tmp;
    } else {
      mod_data = 0U;
    }

    if (tmp > 255U) {
      tmp = 255U;
    }

    rty_msg[(int32_T)((int32_T)((int32_T)rtu_start_bit - (int32_T)i) - 1)] =
      (uint8_T)tmp;
    i = (int8_T)(int32_T)((int32_T)i - 1);
  }

  /* End of Chart: '<S1085>/Chart' */
}

/* Output and update for function-call system: '<S1137>/Planner' */
void app_Planner(const real32_T rtu_initial_lateral_status[3], real32_T
                 rty_y_cof[7], B_Planner_app_T *localB, const
                 ConstB_Planner_app_T *localC)
{
  int32_T i;
  int32_T s1149_iter;
  int32_T s1160_iter;
  real32_T rtb_Add_dp[10];
  real32_T rtb_Product1_pw[10];
  real32_T rtb_Product2_lz[10];
  real32_T rtb_Product_cz[10];
  real32_T rtb_Divide_oj[9];
  real32_T rtb_Product30[3];
  real32_T min_cost_value;
  real32_T rtb_Add_jw;
  real32_T rtb_Divide_m;
  real32_T rtb_Gain21;
  real32_T rtb_Gain3_b4;
  real32_T rtb_Gain5_e;
  real32_T rtb_Gain5_m;
  real32_T rtb_Gain7_n2;
  real32_T rtb_Gain_fx;
  real32_T rtb_Selector8_idx_1;
  real32_T rtb_Selector8_idx_3;
  real32_T rtb_Sqrt;
  real32_T rtb_Sqrt_tmp;
  real32_T rtb_Sqrt_tmp_0;
  real32_T rtb_Subtract_b;
  real32_T rtb_Subtract_gw;
  real32_T rtu_initial_lateral_status_0;
  real32_T s1150_iter_idx_1;
  real32_T s1150_iter_idx_1_tmp;
  real32_T s1150_iter_idx_2;
  real32_T tmp;
  real32_T tmp_0;
  real32_T tmp_1;

  /* DataStoreWrite: '<S1148>/Data Store Write' incorporates:
   *  Constant: '<S1148>/Constant12'
   */
  min_cost_value = 9999.0F;

  /* Outputs for Iterator SubSystem: '<S1148>/PlannerLoop' incorporates:
   *  ForIterator: '<S1149>/For Iterator'
   */
  /* Outputs for Iterator SubSystem: '<S1149>/For Iterator Subsystem' incorporates:
   *  ForIterator: '<S1150>/For Iterator'
   */
  /* Gain: '<S1153>/Gain21' */
  rtb_Gain21 = 0.5F * rtu_initial_lateral_status[2];

  /* SignalConversion generated from: '<S1153>/Product30' incorporates:
   *  Constant: '<S1150>/Constant1'
   *  Gain: '<S1153>/Gain14'
   *  Sum: '<S1153>/Subtract2'
   */
  s1150_iter_idx_2 = 0.0F - 2.0F * rtb_Gain21;

  /* Gain: '<S1158>/Gain' */
  rtb_Gain_fx = 2.0F * rtb_Gain21;

  /* Sum: '<S1162>/Add' */
  rtu_initial_lateral_status_0 = rtu_initial_lateral_status[1];

  /* Gain: '<S1158>/Gain5' */
  rtb_Gain5_e = 2.0F * rtb_Gain21;

  /* End of Outputs for SubSystem: '<S1149>/For Iterator Subsystem' */
  for (s1149_iter = 0; s1149_iter < 14; s1149_iter++) {
    /* Sum: '<S1149>/Add' incorporates:
     *  Constant: '<S1148>/k_TJA_PP_t_MinPlanedTm_sg'
     *  Product: '<S1149>/Product'
     */
    rtb_Add_jw = (real32_T)s1149_iter * localC->Divide + 2.0F;

    /* Outputs for Iterator SubSystem: '<S1149>/For Iterator Subsystem' incorporates:
     *  ForIterator: '<S1150>/For Iterator'
     */
    /* Product: '<S1154>/Divide' incorporates:
     *  Constant: '<S1154>/Constant'
     *  Sum: '<S1154>/Subtract'
     */
    rtb_Divide_m = rtb_Add_jw / 9.0F;

    /* Sum: '<S1153>/Subtract1' incorporates:
     *  Product: '<S1153>/Product28'
     *  Product: '<S1153>/Product29'
     */
    s1150_iter_idx_1_tmp = rtb_Gain21 * rtb_Add_jw;

    /* SignalConversion generated from: '<S1153>/Product30' incorporates:
     *  Constant: '<S1150>/Constant'
     *  Gain: '<S1153>/Gain22'
     *  Product: '<S1153>/Product29'
     *  Sum: '<S1153>/Add1'
     *  Sum: '<S1153>/Subtract1'
     */
    s1150_iter_idx_1 = 0.0F - (s1150_iter_idx_1_tmp * 2.0F +
      rtu_initial_lateral_status[1]);

    /* Outputs for Iterator SubSystem: '<S1154>/For Iterator Subsystem' incorporates:
     *  ForIterator: '<S1160>/For Iterator'
     */
    for (s1160_iter = 0; s1160_iter < 10; s1160_iter++) {
      /* Assignment: '<S1160>/Assignment' incorporates:
       *  Product: '<S1160>/Product'
       */
      if (s1160_iter == 0) {
        /* Assignment: '<S1160>/Assignment' */
        for (i = 0; i < 10; i++) {
          localB->Assignment[i] = 0.0F;
        }
      }

      localB->Assignment[s1160_iter] = (real32_T)s1160_iter * rtb_Divide_m;

      /* End of Assignment: '<S1160>/Assignment' */
    }

    /* End of Outputs for SubSystem: '<S1154>/For Iterator Subsystem' */
    for (s1160_iter = 0; s1160_iter < 7; s1160_iter++) {
      /* Product: '<S1153>/Product19' incorporates:
       *  Gain: '<S1153>/Gain16'
       *  Gain: '<S1153>/Gain18'
       *  Gain: '<S1153>/Gain19'
       *  Gain: '<S1153>/Gain20'
       *  Product: '<S1153>/Product20'
       *  Product: '<S1153>/Product22'
       *  Product: '<S1153>/Product23'
       *  Product: '<S1153>/Product24'
       *  Product: '<S1153>/Product26'
       */
      tmp_0 = rtb_Add_jw * rtb_Add_jw;
      rtb_Divide_m = tmp_0 * rtb_Add_jw;

      /* Product: '<S1153>/Product24' incorporates:
       *  Gain: '<S1153>/Gain15'
       *  Product: '<S1153>/Product21'
       *  Product: '<S1153>/Product25'
       */
      tmp_1 = rtb_Divide_m * rtb_Add_jw;

      /* Concatenate: '<S1153>/Matrix Concatenate2' incorporates:
       *  Gain: '<S1153>/Gain15'
       *  Gain: '<S1153>/Gain16'
       *  Gain: '<S1153>/Gain17'
       *  Gain: '<S1153>/Gain18'
       *  Gain: '<S1153>/Gain19'
       *  Gain: '<S1153>/Gain20'
       *  Product: '<S1153>/Product25'
       *  Product: '<S1164>/Divide'
       */
      rtb_Divide_oj[6] = tmp_1 * rtb_Add_jw;
      rtb_Divide_oj[1] = tmp_0 * 3.0F;
      rtb_Divide_oj[4] = rtb_Divide_m * 4.0F;
      rtb_Divide_oj[7] = tmp_1 * 5.0F;
      rtb_Divide_oj[2] = 6.0F * rtb_Add_jw;
      rtb_Divide_oj[5] = tmp_0 * 12.0F;
      rtb_Divide_oj[8] = rtb_Divide_m * 20.0F;

      /* Sum: '<S1184>/Subtract' incorporates:
       *  Product: '<S1164>/Divide'
       *  Product: '<S1184>/Product'
       *  Product: '<S1184>/Product1'
       *  Selector: '<S1174>/Selector4'
       *  Selector: '<S1174>/Selector5'
       *  Selector: '<S1174>/Selector7'
       *  Selector: '<S1174>/Selector8'
       *  Sum: '<S1175>/Subtract'
       */
      tmp_0 = rtb_Divide_oj[4] * rtb_Divide_oj[8] - rtb_Divide_oj[7] *
        rtb_Divide_oj[5];

      /* Product: '<S1185>/Product1' incorporates:
       *  Product: '<S1164>/Divide'
       *  Product: '<S1176>/Product'
       *  Selector: '<S1174>/Selector3'
       *  Selector: '<S1174>/Selector8'
       */
      tmp = rtb_Divide_oj[1] * rtb_Divide_oj[8];

      /* Product: '<S1185>/Product' incorporates:
       *  Product: '<S1164>/Divide'
       *  Product: '<S1176>/Product1'
       *  Selector: '<S1174>/Selector5'
       *  Selector: '<S1174>/Selector6'
       */
      rtb_Sqrt_tmp = rtb_Divide_oj[7] * rtb_Divide_oj[2];

      /* Sum: '<S1186>/Subtract' incorporates:
       *  Product: '<S1164>/Divide'
       *  Product: '<S1186>/Product'
       *  Product: '<S1186>/Product1'
       *  Selector: '<S1174>/Selector3'
       *  Selector: '<S1174>/Selector4'
       *  Selector: '<S1174>/Selector6'
       *  Selector: '<S1174>/Selector7'
       *  Sum: '<S1177>/Subtract'
       */
      rtb_Sqrt_tmp_0 = rtb_Divide_oj[1] * rtb_Divide_oj[5] - rtb_Divide_oj[4] *
        rtb_Divide_oj[2];

      /* Sum: '<S1174>/Add' incorporates:
       *  Product: '<S1153>/Product19'
       *  Product: '<S1153>/Product24'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1174>/Product'
       *  Product: '<S1174>/Product1'
       *  Product: '<S1174>/Product2'
       *  Product: '<S1185>/Product'
       *  Product: '<S1185>/Product1'
       *  Selector: '<S1174>/Selector2'
       *  Sum: '<S1184>/Subtract'
       *  Sum: '<S1185>/Subtract'
       *  Sum: '<S1186>/Subtract'
       */
      rtb_Sqrt = (tmp_0 * rtb_Divide_m + (rtb_Sqrt_tmp - tmp) * tmp_1) +
        rtb_Sqrt_tmp_0 * rtb_Divide_oj[6];

      /* Switch: '<S1164>/Switch' incorporates:
       *  Abs: '<S1164>/Abs'
       *  Constant: '<S1164>/Constant'
       */
      if (!(fabsf(rtb_Sqrt) > 1.0E-5F)) {
        rtb_Sqrt = 1.0E-5F;
      }

      /* End of Switch: '<S1164>/Switch' */

      /* Gain: '<S1164>/Gain3' incorporates:
       *  Product: '<S1153>/Product24'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1178>/Product'
       *  Product: '<S1178>/Product1'
       *  Selector: '<S1164>/Selector5'
       *  Sum: '<S1178>/Subtract'
       */
      rtb_Gain3_b4 = -(tmp_1 * rtb_Divide_oj[8] - rtb_Divide_oj[6] *
                       rtb_Divide_oj[5]);

      /* Sum: '<S1179>/Subtract' incorporates:
       *  Product: '<S1153>/Product19'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1179>/Product'
       *  Product: '<S1179>/Product1'
       *  Selector: '<S1164>/Selector3'
       */
      rtb_Subtract_gw = rtb_Divide_m * rtb_Divide_oj[8] - rtb_Divide_oj[6] *
        rtb_Divide_oj[2];

      /* Gain: '<S1164>/Gain5' incorporates:
       *  Product: '<S1153>/Product19'
       *  Product: '<S1153>/Product24'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1180>/Product'
       *  Product: '<S1180>/Product1'
       *  Selector: '<S1164>/Selector4'
       *  Sum: '<S1180>/Subtract'
       */
      rtb_Gain5_m = -(rtb_Divide_m * rtb_Divide_oj[5] - tmp_1 * rtb_Divide_oj[2]);

      /* Sum: '<S1181>/Subtract' incorporates:
       *  Product: '<S1153>/Product24'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1181>/Product'
       *  Product: '<S1181>/Product1'
       *  Selector: '<S1164>/Selector9'
       */
      rtb_Subtract_b = tmp_1 * rtb_Divide_oj[7] - rtb_Divide_oj[6] *
        rtb_Divide_oj[4];

      /* Gain: '<S1164>/Gain7' incorporates:
       *  Product: '<S1153>/Product19'
       *  Product: '<S1164>/Divide'
       *  Product: '<S1182>/Product'
       *  Product: '<S1182>/Product1'
       *  Selector: '<S1164>/Selector6'
       *  Sum: '<S1182>/Subtract'
       */
      rtb_Gain7_n2 = -(rtb_Divide_m * rtb_Divide_oj[7] - rtb_Divide_oj[6] *
                       rtb_Divide_oj[1]);

      /* Selector: '<S1164>/Selector8' incorporates:
       *  Product: '<S1164>/Divide'
       */
      rtb_Selector8_idx_1 = rtb_Divide_oj[1];
      rtb_Selector8_idx_3 = rtb_Divide_oj[4];

      /* Product: '<S1164>/Divide' incorporates:
       *  Concatenate: '<S1164>/Matrix Concatenate'
       *  Gain: '<S1164>/Gain1'
       *  Product: '<S1153>/Product19'
       *  Product: '<S1153>/Product24'
       *  Product: '<S1183>/Product'
       *  Product: '<S1183>/Product1'
       *  Selector: '<S1164>/Selector8'
       *  Selector: '<S1173>/Selector2'
       *  Selector: '<S1173>/Selector3'
       *  Sum: '<S1176>/Subtract'
       *  Sum: '<S1183>/Subtract'
       */
      rtb_Divide_oj[0] = tmp_0 / rtb_Sqrt;
      rtb_Divide_oj[1] = -(tmp - rtb_Sqrt_tmp) / rtb_Sqrt;
      rtb_Divide_oj[2] = rtb_Sqrt_tmp_0 / rtb_Sqrt;
      rtb_Divide_oj[3] = rtb_Gain3_b4 / rtb_Sqrt;
      rtb_Divide_oj[4] = rtb_Subtract_gw / rtb_Sqrt;
      rtb_Divide_oj[5] = rtb_Gain5_m / rtb_Sqrt;
      rtb_Divide_oj[6] = rtb_Subtract_b / rtb_Sqrt;
      rtb_Divide_oj[7] = rtb_Gain7_n2 / rtb_Sqrt;
      rtb_Divide_oj[8] = (rtb_Divide_m * rtb_Selector8_idx_3 - tmp_1 *
                          rtb_Selector8_idx_1) / rtb_Sqrt;

      /* SignalConversion generated from: '<S1153>/Product30' incorporates:
       *  Product: '<S1150>/Product'
       *  Product: '<S1153>/Product27'
       *  Product: '<S1153>/Product28'
       *  Sum: '<S1150>/Add'
       *  Sum: '<S1153>/Add'
       *  Sum: '<S1153>/Subtract'
       */
      rtb_Divide_m = ((real32_T)s1160_iter * localC->Divide_l + localC->Gain) -
        ((rtu_initial_lateral_status[1] * rtb_Add_jw +
          rtu_initial_lateral_status[0]) + s1150_iter_idx_1_tmp * rtb_Add_jw);

      /* Product: '<S1153>/Product30' incorporates:
       *  Product: '<S1164>/Divide'
       */
      for (i = 0; i < 3; i++) {
        rtb_Product30[i] = rtb_Divide_oj[(int32_T)(i + 6)] * s1150_iter_idx_2 +
          (rtb_Divide_oj[(int32_T)(i + 3)] * s1150_iter_idx_1 + rtb_Divide_oj[i]
           * rtb_Divide_m);
      }

      /* End of Product: '<S1153>/Product30' */

      /* Gain: '<S1158>/Gain1' */
      rtb_Divide_m = 3.0F * rtb_Product30[0];
      for (i = 0; i < 10; i++) {
        /* Sum: '<S1161>/Add' incorporates:
         *  Assignment: '<S1160>/Assignment'
         *  Product: '<S1155>/Product'
         *  Product: '<S1161>/Product'
         *  Product: '<S1161>/Product1'
         *  Product: '<S1161>/Product2'
         *  Product: '<S1161>/Product3'
         *  Product: '<S1161>/Product4'
         */
        tmp_1 = ((((rtu_initial_lateral_status[1] * localB->Assignment[i] +
                    rtu_initial_lateral_status[0]) + rtb_Gain21 *
                   localB->Assignment[i] * localB->Assignment[i]) +
                  rtb_Product30[0] * localB->Assignment[i] * localB->
                  Assignment[i] * localB->Assignment[i]) + rtb_Product30[1] *
                 localB->Assignment[i] * localB->Assignment[i] *
                 localB->Assignment[i] * localB->Assignment[i]) + rtb_Product30
          [2] * localB->Assignment[i] * localB->Assignment[i] *
          localB->Assignment[i] * localB->Assignment[i] * localB->Assignment[i];
        rtb_Add_dp[i] = tmp_1 * tmp_1;

        /* Product: '<S1162>/Product1' incorporates:
         *  Assignment: '<S1160>/Assignment'
         */
        rtb_Product_cz[i] = rtb_Divide_m * localB->Assignment[i] *
          localB->Assignment[i];
      }

      /* Gain: '<S1158>/Gain2' */
      rtb_Divide_m = 4.0F * rtb_Product30[1];

      /* Product: '<S1162>/Product2' incorporates:
       *  Assignment: '<S1160>/Assignment'
       */
      for (i = 0; i < 10; i++) {
        rtb_Product2_lz[i] = rtb_Divide_m * localB->Assignment[i] *
          localB->Assignment[i] * localB->Assignment[i];
      }

      /* End of Product: '<S1162>/Product2' */

      /* Gain: '<S1158>/Gain3' */
      rtb_Divide_m = 5.0F * rtb_Product30[2];
      for (i = 0; i < 10; i++) {
        /* Sum: '<S1162>/Add' incorporates:
         *  Assignment: '<S1160>/Assignment'
         *  Product: '<S1162>/Product'
         *  Product: '<S1162>/Product1'
         *  Product: '<S1162>/Product2'
         *  Product: '<S1162>/Product3'
         *  Sum: '<S1163>/Add'
         */
        tmp = (((rtb_Gain_fx * localB->Assignment[i] +
                 rtu_initial_lateral_status_0) + rtb_Product_cz[i]) +
               rtb_Product2_lz[i]) + rtb_Divide_m * localB->Assignment[i] *
          localB->Assignment[i] * localB->Assignment[i] * localB->Assignment[i];
        rtb_Product_cz[i] = tmp;

        /* Product: '<S1157>/Product' */
        rtb_Product2_lz[i] = tmp * tmp;
      }

      /* Gain: '<S1158>/Gain6' */
      rtb_Divide_m = 6.0F * rtb_Product30[0];

      /* Product: '<S1163>/Product' incorporates:
       *  Assignment: '<S1160>/Assignment'
       */
      for (i = 0; i < 10; i++) {
        rtb_Product_cz[i] = rtb_Divide_m * localB->Assignment[i];
      }

      /* End of Product: '<S1163>/Product' */

      /* Gain: '<S1158>/Gain8' */
      rtb_Divide_m = 12.0F * rtb_Product30[1];

      /* Product: '<S1163>/Product1' incorporates:
       *  Assignment: '<S1160>/Assignment'
       */
      for (i = 0; i < 10; i++) {
        rtb_Product1_pw[i] = rtb_Divide_m * localB->Assignment[i] *
          localB->Assignment[i];
      }

      /* End of Product: '<S1163>/Product1' */

      /* Gain: '<S1158>/Gain9' */
      rtb_Divide_m = 20.0F * rtb_Product30[2];

      /* Sum: '<S1155>/Sum of Elements' */
      tmp_1 = -0.0F;

      /* Sum: '<S1157>/Sum of Elements' */
      tmp_0 = -0.0F;
      for (i = 0; i < 10; i++) {
        /* Sum: '<S1163>/Add' incorporates:
         *  Assignment: '<S1160>/Assignment'
         *  Product: '<S1163>/Product'
         *  Product: '<S1163>/Product1'
         *  Product: '<S1163>/Product2'
         */
        tmp = rtb_Divide_m * localB->Assignment[i] * localB->Assignment[i] *
          localB->Assignment[i] + ((rtb_Gain5_e + rtb_Product_cz[i]) +
          rtb_Product1_pw[i]);

        /* Sum: '<S1155>/Sum of Elements' incorporates:
         *  Product: '<S1155>/Product'
         */
        tmp_1 += rtb_Add_dp[i];

        /* Sum: '<S1157>/Sum of Elements' incorporates:
         *  Product: '<S1157>/Product'
         */
        tmp_0 += rtb_Product2_lz[i];

        /* Sum: '<S1163>/Add' incorporates:
         *  Product: '<S1156>/Product'
         *  Product: '<S1163>/Product'
         */
        rtb_Product_cz[i] = tmp * tmp;
      }

      /* Saturate: '<S1152>/Saturation' */
      if (rtb_Add_jw > 100.0F) {
        rtb_Divide_m = 100.0F;
      } else if (rtb_Add_jw < 0.5F) {
        rtb_Divide_m = 0.5F;
      } else {
        rtb_Divide_m = rtb_Add_jw;
      }

      /* End of Saturate: '<S1152>/Saturation' */

      /* Sum: '<S1156>/Sum of Elements' incorporates:
       *  Product: '<S1156>/Product'
       */
      tmp = -0.0F;
      for (i = 0; i < 10; i++) {
        tmp += rtb_Product_cz[i];
      }

      /* Sum: '<S1152>/Add' incorporates:
       *  Constant: '<S1148>/Constant3'
       *  Constant: '<S1148>/k_TJA_PP_d_MaxPlanedLatPos_sg'
       *  Constant: '<S1148>/k_TJA_PP_d_MaxPlanedLatVel_sg'
       *  Constant: '<S1148>/k_TJA_PP_j_MaxPlanedLatJerk_sg'
       *  Constant: '<S1148>/k_TJA_PP_k_PlanedLatJerkWght_sg'
       *  Constant: '<S1148>/k_TJA_PP_k_PlanedLatOfstWght_sg'
       *  Constant: '<S1152>/Constant1'
       *  Product: '<S1155>/Divide'
       *  Product: '<S1155>/Divide1'
       *  Product: '<S1155>/Product1'
       *  Product: '<S1156>/Divide'
       *  Product: '<S1156>/Divide1'
       *  Product: '<S1156>/Product1'
       *  Product: '<S1157>/Divide'
       *  Product: '<S1157>/Divide1'
       *  Product: '<S1157>/Product1'
       *  Product: '<S1159>/Divide'
       *  Sqrt: '<S1155>/Sqrt'
       *  Sqrt: '<S1156>/Sqrt'
       *  Sqrt: '<S1157>/Sqrt'
       *  Sum: '<S1155>/Sum of Elements'
       *  Sum: '<S1156>/Sum of Elements'
       *  Sum: '<S1157>/Sum of Elements'
       */
      rtb_Divide_m = ((sqrtf(tmp_1 / 10.0F) / 1.875F * 3.0F / rtb_Divide_m +
                       sqrtf(tmp_0 / 10.0F) / 2.0F / rtb_Divide_m) + sqrtf(tmp /
        10.0F) / 10.0F * 2.0F / rtb_Divide_m) + rtb_Divide_m / 8.0F;

      /* If: '<S1150>/If' incorporates:
       *  DataStoreRead: '<S1150>/Data Store Read'
       *  DataStoreWrite: '<S1151>/Data Store Write'
       *  Inport: '<S1151>/cost_traj'
       *  Inport: '<S1151>/cost_value'
       */
      if (rtb_Divide_m < min_cost_value) {
        /* Outputs for IfAction SubSystem: '<S1150>/If Action Subsystem' incorporates:
         *  ActionPort: '<S1151>/Action Port'
         */
        rty_y_cof[0] = rtb_Add_jw;
        rty_y_cof[1] = rtu_initial_lateral_status[0];
        rty_y_cof[2] = rtu_initial_lateral_status[1];
        rty_y_cof[3] = rtb_Gain21;
        rty_y_cof[4] = rtb_Product30[0];
        rty_y_cof[5] = rtb_Product30[1];
        rty_y_cof[6] = rtb_Product30[2];
        min_cost_value = rtb_Divide_m;

        /* End of Outputs for SubSystem: '<S1150>/If Action Subsystem' */
      }

      /* End of If: '<S1150>/If' */
    }

    /* End of Outputs for SubSystem: '<S1149>/For Iterator Subsystem' */
  }

  /* End of Outputs for SubSystem: '<S1148>/PlannerLoop' */
}

/* Function for Chart: '<S909>/ACC_SSM' */
static void app_exit_internal_ACC_Active(void)
{
  switch (app_DW.is_ACC_Active) {
   case app_IN_ACC_ACTIVE_Cruise:
    if (app_DW.is_ACC_ACTIVE_Cruise == app_IN_Cruise_CCC) {
      app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
      app_DW.is_ACC_ACTIVE_Cruise = 0;
    } else {
      app_DW.is_ACC_ACTIVE_Cruise = 0;
    }

    app_DW.is_ACC_Active = 0;
    break;

   case app_IN_ACC_BrakeOnly:
    app_DW.ACCBrkOnly_Counter = 0.0;
    app_DW.is_ACC_Active = 0;
    break;

   default:
    app_DW.is_ACC_Active = 0;
    break;
  }
}

/* Function for Chart: '<S909>/ACC_SSM' */
static void app_ACC_Active(const ePWR_PwrMd *DataTypeConversion19, const
  real32_T *DataTypeConversion28, const eBPL_BrkPdlApl *DataTypeConversion30,
  const boolean_T *DFIn_is_CCFMReversibleFlt_bl, const boolean_T
  *LogicalOperator1, const uint16_T *P_ACC_cntr_FTCAutoGoTm_u16)
{
  int32_T tmp;
  uint32_T qY;
  boolean_T guard1 = false;
  if (*DFIn_is_CCFMReversibleFlt_bl) {
    app_exit_internal_ACC_Active();

    /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
    app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
    app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
    app_DW.is_c88_app = app_IN_ACC_Fault;
    app_DW.is_ACC_Fault = app_IN_Failure_Reversible;
    m_FSM_sts_ACCSMRSts_en = eACCRevsFault;
  } else if ((!app_B.Switch_g) || ((*DataTypeConversion19 == PWR_Off) ||
              (*DataTypeConversion19 == PWR_ACC))) {
    app_exit_internal_ACC_Active();

    /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
    app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
    app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
    app_DW.is_c88_app = app_IN_ACC_Off;
    m_FSM_sts_ACCSMRSts_en = eACCReqStsOff;
    app_DW.ACC_is_FirstTmActvFlag_bl = false;
    app_DW.ACC_is_FirstTmRsm_bl = false;
  } else {
    /*       /$ 20190807 deleted ACCSwOnSw ==0 due to it has been added on the ACC ACTIVE to OFF $/ Delete 20191025 CRD1.8 ||   ( ACC_indx_ACCSysReqSts_en  ==E_ACCReqSts_t.eStandStillActive)*/
    if (m_ACC_is_ACCReqDsbl_bl || ((*DataTypeConversion30 == BPL_Brake_Applied) &&
         ((m_FSM_sts_ACCSMRSts_en == eCruiseCCC) || ((m_FSM_sts_ACCSMRSts_en ==
            eCruiseACCApproaching) && (!m_ACC_is_VehSdslSts_bl))))) {
      /* sliding back or forward from STANDSTILL ACTIVE or WAIT should be detected and exit */
      app_exit_internal_ACC_Active();

      /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
      app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
      app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
      app_DW.is_c88_app = app_IN_ACC_Standby;
      m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
    } else {
      if ((int32_T)((int32_T)app_DW.ACC_cntr_IsSetSpdActv_u8 + 1) < 3) {
        app_DW.ACC_cntr_IsSetSpdActv_u8 = (uint8_T)(int32_T)((int32_T)
          app_DW.ACC_cntr_IsSetSpdActv_u8 + 1);
      } else {
        app_DW.ACC_cntr_IsSetSpdActv_u8 = 3U;
      }

      guard1 = false;
      switch (app_DW.is_ACC_Active) {
       case app_IN_ACC_ACTIVE_Cruise:
        if (app_B.OutPut_g && P_ACC_is_FullGasPdlExitEnbl_bl) {
          if ((int32_T)app_DW.is_ACC_ACTIVE_Cruise == 2) {
            app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          } else {
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          }

          app_DW.is_ACC_Active = 0;

          /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
          app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
          app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
          app_DW.is_c88_app = app_IN_ACC_Standby;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
        } else if (m_ACC_is_BrkOnlyEnbl_bl) {
          /*  deleted and need to combine the following conditions to a subsystem outside
             (ACC_a_ACCSysTgtAccel_sg<=0)&&(  (DFIn_a_VSELongtAccel_sg<=0)||(DFIn_a_EstdVSELongtAccel_sg<0))&&(DFIn_is_BrkOnlyEnbl_bl==1)&&(ACC_indx_ACCSysReqSts_en != E_ACCReqSts_t.eACCReqStsActiveOverride)... */
          if ((int32_T)app_DW.is_ACC_ACTIVE_Cruise == 2) {
            app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          } else {
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          }

          app_DW.is_ACC_Active = app_IN_ACC_BrakeOnly;
          app_DW.ACCBrkOnly_Counter = 0.0;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsBrkOnly;
        } else if (m_ACC_is_ACCOvrrdReq_bl) {
          /*  deleted20190926.(  DFIn_perc_AccelActuPos_sg >=max(DFIn_perc_AccelEfctvPos_sg,(P_ACC_perc_MinAccelPdlPos_sg+P_ACC_perc_MinAccelPdlOfst_sg)))&&(  DFIn_perc_AccelActuPos_sg <P_ACC_perc_AccelPdlOvrrdExit_sg)||   (  (ACC_indx_ACCSysReqSts_en==E_ACCReqSts_t.eCruiseACCStdStill)&&(AccPdlPos>0.3))
             by 20180627 */
          if ((int32_T)app_DW.is_ACC_ACTIVE_Cruise == 2) {
            app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          } else {
            app_DW.is_ACC_ACTIVE_Cruise = 0;
          }

          app_DW.is_ACC_Active = app_IN_ACC_Active_Override;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsActiveOverride;
          app_DW.ACC_is_FirstTmActvFlag_bl = true;
          app_DW.ACC_is_FirstTmRsm_bl = true;

          /* 20191022 Add the Logic to delete SubStates */
          app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
        } else {
          switch (app_DW.is_ACC_ACTIVE_Cruise) {
           case app_IN_ACC_Approaching:
            /* Added Mar.22
               added the vehiclespeed>0 to avoid the transfer from vehiclestandstill to cc */
            if (!long_out_isLeadVehDtct) {
              /* (DFIn_d_FMRdrLongtDist_sg>=6*ACC_d_ACCEntryDistThrs_sg)&&(  (ACC_indx_ACCSysReqSts_en !=E_ACCReqSts_t.eStandStillWait)||(ACC_indx_ACCSysReqSts_en !=E_ACCReqSts_t.eStandStillActive))) */
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_Cruise_CCC;
              m_FSM_sts_ACCSMRSts_en = eCruiseCCC;

              /* The following code is added in Sep12 to avoid the false exit when SetSpd = 0
                 which may happen when the state is transfered from StandStill to CC */
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            } else {
              /* brkpdlsw strategy is changed to ~=
                 20190807 wangbin deleted ((DFIn_is_ACCReqEnbl_bl==1)
                 20190807 wangbin deleted (DFIn_v_HdVehSpd_sg ==0) based on APTIV CRD/$20190807 wangbin changed from (DFIn_v_EgoAvgVehSpd_sg<=0)...$/ */
              /* changed at 0320; delete &&(ACC_a_ACCSysTgtAccel_sg <=0)Jul.22 2020  */
              if (m_ACC_is_VehSdslSts_bl && ((*DataTypeConversion30 ==
                    BPL_Brake_Applied) || (!m_ACC_is_SafyBltFstn_bl))) {
                /* /$ ADD 20190808 wangbin based on APTIV CRD$/ */
                app_DW.is_ACC_ACTIVE_Cruise = app_IN_eStandStillWait;
                m_FSM_sts_ACCSMRSts_en = eStandStillWait;

                /* ACCSysSts_RadarHSC2 = ACCReqSts_t.eStandStillWait */
                app_DW.ACC_cntr_VehACCStdStill_u16 = 0U;
              } else {
                m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
              }
            }
            break;

           case app_IN_Cruise_CCC:
            if (long_out_isLeadVehDtct) {
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_ACC_Approaching;
              m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
            } else if ((int32_T)((int32_T)app_DW.ACC_cntr_IsCCSetSpdActv_u8 + 1)
                       < 3) {
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = (uint8_T)(int32_T)((int32_T)
                app_DW.ACC_cntr_IsCCSetSpdActv_u8 + 1);
            } else {
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 3U;
            }
            break;

           case app_IN_eStandStillActive:
            if (*LogicalOperator1) {
              guard1 = true;
            } else if (*DataTypeConversion30 != BPL_Brake_Applied) {
              /* && (DFIn_v_EgoAvgVehSpd_sg<=0) deleted basedon APTIV CRD */
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_ACC_Approaching;
              m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
            } else {
              /* ADD 20190923 */
              if ((!long_out_isLeadVehDtct) && m_ACC_is_ACCReqEnbl_bl &&
                  (*DataTypeConversion30 != BPL_Brake_Applied)) {
                /* ADD the condition to avoid Target Cutout in StandstillActive,
                   then EGO has to wait within 3s to enter StandstillWait to CCC */
                app_DW.is_ACC_ACTIVE_Cruise = app_IN_Cruise_CCC;
                m_FSM_sts_ACCSMRSts_en = eCruiseCCC;

                /* The following code is added in Sep12 to avoid the false exit when SetSpd = 0
                   which may happen when the state is transfered from StandStill to CC */
                app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
              } else if (app_DW.ACC_cntr_VehACCStdStill_u16 >=
                         *P_ACC_cntr_FTCAutoGoTm_u16) {
                /* deleted (DFIn_v_HdVehSpd_sg<=0)...||(DFIn_is_CODPFoloTgtExist_bl ==0)
                   &&(DFIn_is_VehStdStl_bl == 1)... */
                guard1 = true;
              } else {
                /* ACC_is_ACCSdslReq_bl = 1; */
                tmp = (int32_T)((int32_T)app_DW.ACC_cntr_VehACCStdStill_u16 + 1);
                if ((int32_T)((int32_T)app_DW.ACC_cntr_VehACCStdStill_u16 + 1) >
                    65535) {
                  tmp = 65535;
                }

                app_DW.ACC_cntr_VehACCStdStill_u16 = (uint16_T)tmp;

                /* ex:ACC_is_ACCSdslReq_bl = 0; */
              }
            }
            break;

           default:
            /* case IN_eStandStillWait: */
            /* Added Sep12 to avoid the Target lost situation */
            if ((!long_out_isLeadVehDtct) && m_ACC_is_ACCReqEnbl_bl &&
                ((*DataTypeConversion28 >= P_ACC_perc_MinAccelPdlPos_sg) ||
                 app_B.LogicalOperator_a) && (*DataTypeConversion30 !=
                 BPL_Brake_Applied)) {
              /* && (ACC_is_ACCGoReq_bl ==1)* deleted 20190808 since GoReq ==1 , only when there is a head vehicle??
                 during wait , if the head vehicle leave, and there is no front vehicle, the EGO should have
                 the chance to enter into CC. */
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_Cruise_CCC;
              m_FSM_sts_ACCSMRSts_en = eCruiseCCC;

              /* The following code is added in Sep12 to avoid the false exit when SetSpd = 0
                 which may happen when the state is transfered from StandStill to CC */
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            } else if (((*DataTypeConversion28 >= P_ACC_perc_MinAccelPdlPos_sg) ||
                        app_B.LogicalOperator_a) && (*DataTypeConversion30 !=
                        BPL_Brake_Applied)) {
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_ACC_Approaching;
              m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
            } else {
              if (((*DataTypeConversion28 >= P_ACC_perc_MinAccelPdlPos_sg) ||
                   app_B.LogicalOperator_a) && (*DataTypeConversion30 !=
                   BPL_Brake_Applied)) {
                app_DW.is_ACC_ACTIVE_Cruise = app_IN_eStandStillActive;
                app_DW.ACC_cntr_VehACCStdStill_u16 = 0U;
                m_FSM_sts_ACCSMRSts_en = eStandStillActive;
              }
            }
            break;
          }
        }
        break;

       case app_IN_ACC_Active_Override:
        /* Constant: '<S909>/P_ACC_t_SetSpdActvThrs_sg7' */
        /* !!!!Aug07,2019. Need consider the case that driver override the vehicle to a very high speed, such as 200km/h */
        if ((app_DW.ACC_cntr_ACCOvrd_u32 >= app_B.P_ACC_cntr_OvrrdExitTmThrs_u16)
            || (app_B.OutPut_g && P_ACC_is_FullGasPdlExitEnbl_bl) ||
            (m_ACC_is_ACCReqDsbl_bl || (*DataTypeConversion30 ==
              BPL_Brake_Applied))) {
          app_DW.is_ACC_Active = 0;

          /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
          app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
          app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
          app_DW.is_c88_app = app_IN_ACC_Standby;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
        } else if (!m_ACC_is_ACCOvrrdReq_bl) {
          /* delete20190926.DFIn_perc_AccelActuPos_sg<min(DFIn_perc_AccelEfctvPos_sg,P_ACC_perc_MinAccelPdlPos_sg) */
          app_DW.is_ACC_Active = app_IN_ACC_ACTIVE_Cruise;
          app_DW.ACC_is_FirstTmActvFlag_bl = true;
          app_DW.ACC_is_FirstTmRsm_bl = true;

          /* Changed at 1104. Since the Previous Entry_Distance is just used for cal the minimum Braking distan
             which is too short and may cause a later entry with uncomfortable drving experience. For example, the vehicle
             need to stay in CCC for a longtime until reaching the ACC_Entry Distance which may lead to a much higher vehicle in the
             CCCstage.
           */
          if (long_out_isLeadVehDtct) {
            app_DW.is_ACC_ACTIVE_Cruise = app_IN_ACC_Approaching;
            m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
          } else {
            app_DW.is_ACC_ACTIVE_Cruise = app_IN_Cruise_CCC;
            m_FSM_sts_ACCSMRSts_en = eCruiseCCC;

            /* The following code is added in Sep12 to avoid the false exit when SetSpd = 0
               which may happen when the state is transfered from StandStill to CC */
            app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
          }
        } else {
          m_FSM_sts_ACCSMRSts_en = eACCReqStsActiveOverride;

          /* 20191022 Add the Logic to delete SubStates */
          qY = (uint32_T)(app_DW.ACC_cntr_ACCOvrd_u32 + /*MW:OvSatOk*/ 1U);
          if ((uint32_T)(app_DW.ACC_cntr_ACCOvrd_u32 + 1U) <
              app_DW.ACC_cntr_ACCOvrd_u32) {
            qY = MAX_uint32_T;
          }

          app_DW.ACC_cntr_ACCOvrd_u32 = qY;
        }

        /* End of Constant: '<S909>/P_ACC_t_SetSpdActvThrs_sg7' */
        break;

       default:
        /* case IN_ACC_BrakeOnly: */
        if ((app_DW.ACCBrkOnly_Counter >= (real_T)
             app_B.P_ACC_cntr_BrkOnlyTmThrs_u16) || m_ACC_is_BrkOnlyExit_bl) {
          /* (ACC_a_ACCSysTgtAccel_sg>=0)|| (DFIn_perc_AccelActuPos_sg >max(DFIn_perc_AccelEfctvPos_sg,(P_ACC_perc_MinAccelPdlPos_sg+0.02)))|| (DFIn_indx_BrkPdlSts_en == eBPL_BrkPdlApl.BPL_Brake_Applied) */
          app_DW.ACCBrkOnly_Counter = 0.0;
          app_DW.is_ACC_Active = 0;

          /*  Change:MAX 2 MIN in ACC_cntr_IsSetSpdActv_u8 = max(ACC_cntr_IsSetSpdActv_u8+1, 252); */
          app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
          app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
          app_DW.is_c88_app = app_IN_ACC_Standby;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
        } else {
          app_DW.ACCBrkOnly_Counter++;
        }
        break;
      }

      if (guard1) {
        app_DW.is_ACC_ACTIVE_Cruise = app_IN_eStandStillWait;
        m_FSM_sts_ACCSMRSts_en = eStandStillWait;

        /* ACCSysSts_RadarHSC2 = ACCReqSts_t.eStandStillWait */
        app_DW.ACC_cntr_VehACCStdStill_u16 = 0U;
      }
    }
  }
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_MemSpdInc_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  if (app_B.ACC_V_ACCMemSpd_sg < 32768.0F) {
    if (app_B.ACC_V_ACCMemSpd_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCMemSpd_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
  app_B.ACC_V_ACCMemSpd_sg = (real32_T)fmin((real_T)(int32_T)((int32_T)((int32_T)
    tmp - (int32_T)tmp % (int32_T)P_ACC_indx_HMIDISSpdSwChgRng_u8) + (int32_T)
    P_ACC_indx_HMIDISSpdSwChgRng_u8), (real_T)*P_ACC_V_MaxCrsSpdThrs_u8);
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_MemSpdInc_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  if (app_B.ACC_V_ACCMemSpd_sg < 32768.0F) {
    if (app_B.ACC_V_ACCMemSpd_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCMemSpd_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  app_B.ACC_V_ACCMemSpd_sg = (real32_T)fmin((real_T)tmp + 1.0, (real_T)
    *P_ACC_V_MaxCrsSpdThrs_u8);
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_MemSpdDec_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  int16_T tmp_0;

  /*  20180715
     change the P_ACC_V_MinCrsSpdThrs_u8 to P_ACC_V_MinCrsSetSpd_u8 */
  if (app_B.ACC_V_ACCMemSpd_sg < 32768.0F) {
    if (app_B.ACC_V_ACCMemSpd_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCMemSpd_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  if ((int32_T)P_ACC_V_HMIMinCrsSetSpd_u8 > 1) {
    tmp_0 = (int16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
  } else {
    tmp_0 = 1;
  }

  /* End of Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  app_B.ACC_V_ACCMemSpd_sg = (real32_T)fmin((real_T)*P_ACC_V_MaxCrsSpdThrs_u8,
    fmax((real_T)tmp - 1.0, (real_T)tmp_0));
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_MemSpdDec_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int32_T MemSpd_tmp;
  int16_T tmp;
  if (app_B.ACC_V_ACCMemSpd_sg < 32768.0F) {
    if (app_B.ACC_V_ACCMemSpd_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCMemSpd_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
  MemSpd_tmp = (int32_T)tmp % (int32_T)P_ACC_indx_HMIDISSpdSwChgRng_u8;
  if (MemSpd_tmp == 0) {
    /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
    MemSpd_tmp = (int32_T)((int32_T)tmp - (int32_T)
      P_ACC_indx_HMIDISSpdSwChgRng_u8);
  } else {
    MemSpd_tmp = (int32_T)((int32_T)tmp - MemSpd_tmp);
  }

  /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  /*  20180715
     change the P_ACC_V_MinCrsSpdThrs_u8 to P_ACC_V_MinCrsSetSpd_u8 */
  if ((int32_T)P_ACC_V_HMIMinCrsSetSpd_u8 > 1) {
    tmp = (int16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
  } else {
    tmp = 1;
  }

  /* End of Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  app_B.ACC_V_ACCMemSpd_sg = (real32_T)fmin((real_T)*P_ACC_V_MaxCrsSpdThrs_u8,
    fmax((real_T)MemSpd_tmp, (real_T)tmp));
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void DISSts_Standby_BrkOnly_StslWait_Fault(const uint16_T
  *DFIn_V_VIDPEstdEgoVehSpdIPK_u16, const real32_T *DataTypeConversion28, const
  boolean_T *ACC_is_DISMemSpdChgEnbl_bl, const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  uint16_T y;

  /* Constant: '<S999>/ACCSwitch_Off2' incorporates:
   *  Constant: '<S999>/ACCSwitch_On2'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg'
   */
  if ((app_B.Switch_g == C_ACC_HMISwitch_Off_bl) || (m_FSM_sts_ACCSMRSts_en ==
       eACCReqStsOff)) {
    app_DW.is_MemSpdAdjust = 0;
    app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = 0;
    app_DW.is_c90_app = app_IN_DISSts_OFF;
    app_B.ACC_V_ACCMemSpd_sg = 0.0F;
    app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
  } else if ((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
             ((m_FSM_sts_ACCSMRSts_en == eACCReqStsStandby) ||
              (m_FSM_sts_ACCSMRSts_en == eCruiseCCC) || (m_FSM_sts_ACCSMRSts_en ==
    eCruiseACCApproaching) || (m_FSM_sts_ACCSMRSts_en ==
               eACCReqStsActiveOverride)) && (m_FSM_sts_ACCSMRSts_en !=
              eACCReqStsBrkOnly) && (m_FSM_sts_ACCSMRSts_en != eStandStillWait) &&
             (m_FSM_sts_ACCSMRSts_en != eACCRevsFault) &&
             (m_FSM_sts_ACCSMRSts_en != eACCIRRevsFault) &&
             (m_FSM_sts_ACCSMRSts_en != eACCReqStsOff)) {
    app_DW.is_MemSpdAdjust = 0;
    app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = 0;
    app_DW.is_c90_app = app_IN_DISSts_Active;
    app_DW.ACCCrsSpdSet_Ctrl = 0.0;
    app_DW.is_DISSts_Active = app_IN_Initial_ACCSetSpeed;

    /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
    if (P_ACC_V_HMIMinCrsSetSpd_u8 > *DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
      y = (uint16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
    } else {
      y = *DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
    }

    /* End of Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
    if (*P_ACC_V_MaxCrsSpdThrs_u8 < y) {
      app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)*P_ACC_V_MaxCrsSpdThrs_u8;
    } else {
      app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)y;
    }
  } else if (((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) ||
              (*DataTypeConversion28 > P_ACC_perc_HMIGoGasPdlThrs_sg)) &&
             (m_FSM_sts_ACCSMRSts_en != eACCReqStsStandby) &&
             (m_FSM_sts_ACCSMRSts_en != eACCReqStsBrkOnly) &&
             (m_FSM_sts_ACCSMRSts_en != eStandStillWait) &&
             (m_FSM_sts_ACCSMRSts_en != eACCRevsFault) &&
             (m_FSM_sts_ACCSMRSts_en != eACCIRRevsFault) &&
             (m_FSM_sts_ACCSMRSts_en != eACCReqStsOff)) {
    app_DW.is_MemSpdAdjust = 0;
    app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = 0;
    app_DW.is_c90_app = app_IN_DISSts_Active;
    app_DW.ACCCrsSpdSet_Ctrl = 0.0;
    app_DW.is_DISSts_Active = app_IN_ResumeSpeed;
    app_B.ACC_V_ACCSetSpdIPKRAW_sg = fminf((real32_T)*P_ACC_V_MaxCrsSpdThrs_u8,
      app_B.ACC_V_ACCMemSpd_sg);
  } else if ((int32_T)app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau == 1) {
    switch (app_DW.is_MemSpdAdjust) {
     case app_IN_MemSpd_LargeDec:
      app_DW.is_MemSpdAdjust = app_IN_Wait_d;
      break;

     case app_IN_MemSpd_LargeInc:
      app_DW.is_MemSpdAdjust = app_IN_Wait_d;
      break;

     case app_IN_MemSpd_LightDec:
      app_DW.is_MemSpdAdjust = app_IN_Wait_d;
      break;

     case app_IN_MemSpd_LightInc:
      app_DW.is_MemSpdAdjust = app_IN_Wait_d;
      break;

     default:
      /* Constant: '<S999>/ACCSwitch_On2' */
      /* case IN_Wait: */
      if (app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) {
        app_DW.is_MemSpdAdjust = app_IN_MemSpd_LargeDec;
        app_MemSpdDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
      } else if (app_B.ACCSpdIncSwHldCmd_m == C_ACC_HMISwitch_On_bl) {
        app_DW.is_MemSpdAdjust = app_IN_MemSpd_LightDec;
        app_MemSpdDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
      } else if (app_B.ACCSpdIncSwHldCmd == C_ACC_HMISwitch_On_bl) {
        app_DW.is_MemSpdAdjust = app_IN_MemSpd_LightInc;
        app_MemSpdInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
      } else {
        if (app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) {
          app_DW.is_MemSpdAdjust = app_IN_MemSpd_LargeInc;
          app_MemSpdInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
        }
      }
      break;
    }
  } else {
    /* Constant: '<S999>/ACCSwitch_On2' */
    /* case IN_MemSpdGetValue: */
    if ((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) &&
        (*ACC_is_DISMemSpdChgEnbl_bl)) {
      app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = app_IN_MemSpdAdjust;
      app_DW.is_MemSpdAdjust = app_IN_MemSpd_LargeDec;
      app_MemSpdDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
    } else if ((app_B.ACCSpdIncSwHldCmd_m == C_ACC_HMISwitch_On_bl) &&
               (*ACC_is_DISMemSpdChgEnbl_bl)) {
      app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = app_IN_MemSpdAdjust;
      app_DW.is_MemSpdAdjust = app_IN_MemSpd_LightDec;
      app_MemSpdDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
    } else if ((app_B.ACCSpdIncSwHldCmd == C_ACC_HMISwitch_On_bl) &&
               (*ACC_is_DISMemSpdChgEnbl_bl)) {
      app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = app_IN_MemSpdAdjust;
      app_DW.is_MemSpdAdjust = app_IN_MemSpd_LightInc;
      app_MemSpdInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
    } else {
      if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
          (*ACC_is_DISMemSpdChgEnbl_bl)) {
        app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = app_IN_MemSpdAdjust;
        app_DW.is_MemSpdAdjust = app_IN_MemSpd_LargeInc;
        app_MemSpdInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
      }
    }
  }

  /* End of Constant: '<S999>/ACCSwitch_Off2' */
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_SpeedInc_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  if (app_B.ACC_V_ACCSetSpdIPKRAW_sg < 32768.0F) {
    if (app_B.ACC_V_ACCSetSpdIPKRAW_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCSetSpdIPKRAW_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
  app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)fmin((real_T)(int32_T)((int32_T)
    ((int32_T)tmp - (int32_T)tmp % (int32_T)P_ACC_indx_HMIDISSpdSwChgRng_u8) +
    (int32_T)P_ACC_indx_HMIDISSpdSwChgRng_u8), (real_T)*P_ACC_V_MaxCrsSpdThrs_u8);
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_SpeedInc_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  if (app_B.ACC_V_ACCSetSpdIPKRAW_sg < 32768.0F) {
    if (app_B.ACC_V_ACCSetSpdIPKRAW_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCSetSpdIPKRAW_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)fmin((real_T)tmp + 1.0, (real_T)
    *P_ACC_V_MaxCrsSpdThrs_u8);
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_SpeedDec_Large(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int32_T Setspd_tmp;
  int16_T tmp;
  if (app_B.ACC_V_ACCSetSpdIPKRAW_sg < 32768.0F) {
    if (app_B.ACC_V_ACCSetSpdIPKRAW_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCSetSpdIPKRAW_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
  Setspd_tmp = (int32_T)tmp % (int32_T)P_ACC_indx_HMIDISSpdSwChgRng_u8;
  if (Setspd_tmp == 0) {
    /* Constant: '<S999>/P_DFIn_t_VSELongtAccelFilter1' */
    Setspd_tmp = (int32_T)((int32_T)tmp - (int32_T)
      P_ACC_indx_HMIDISSpdSwChgRng_u8);
  } else {
    Setspd_tmp = (int32_T)((int32_T)tmp - Setspd_tmp);
  }

  /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  /*  20180715
     change the P_ACC_V_MinCrsSpdThrs_u8 to P_ACC_V_MinCrsSetSpd_u8 */
  if ((int32_T)P_ACC_V_HMIMinCrsSetSpd_u8 > 1) {
    tmp = (int16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
  } else {
    tmp = 1;
  }

  /* End of Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)fmin((real_T)
    *P_ACC_V_MaxCrsSpdThrs_u8, fmax((real_T)Setspd_tmp, (real_T)tmp));
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_SpeedDec_One(const uint8_T *P_ACC_V_MaxCrsSpdThrs_u8)
{
  int16_T tmp;
  int16_T tmp_0;

  /*  20180715
     change the P_ACC_V_MinCrsSpdThrs_u8 to P_ACC_V_MinCrsSetSpd_u8 */
  if (app_B.ACC_V_ACCSetSpdIPKRAW_sg < 32768.0F) {
    if (app_B.ACC_V_ACCSetSpdIPKRAW_sg >= -32768.0F) {
      tmp = (int16_T)app_B.ACC_V_ACCSetSpdIPKRAW_sg;
    } else {
      tmp = MIN_int16_T;
    }
  } else {
    tmp = MAX_int16_T;
  }

  /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  if ((int32_T)P_ACC_V_HMIMinCrsSetSpd_u8 > 1) {
    tmp_0 = (int16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
  } else {
    tmp_0 = 1;
  }

  /* End of Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
  app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)fmin((real_T)
    *P_ACC_V_MaxCrsSpdThrs_u8, fmax((real_T)tmp - 1.0, (real_T)tmp_0));
}

/* Function for Chart: '<S999>/ACC_Control_Elements' */
static void app_DISSts_Active(const uint16_T *DFIn_V_VIDPEstdEgoVehSpdIPK_u16,
  const boolean_T *LogicalOperator, const boolean_T *ACC_is_DISSetSpdChgEnbl_bl,
  const boolean_T *ACC_is_DISSetSpdSetEnbl_bl, const uint8_T
  *P_ACC_V_MaxCrsSpdThrs_u8, const boolean_T *ACC_is_TJAOvrSpd_bl)
{
  uint16_T y;

  /* Constant: '<S999>/ACCSwitch_Off2' */
  if ((app_B.Switch_g == C_ACC_HMISwitch_Off_bl) || (m_FSM_sts_ACCSMRSts_en ==
       eACCReqStsOff)) {
    app_DW.is_Speed_Decrease = 0;
    app_DW.is_Speed_Increase = 0;
    app_DW.is_DISSts_Active = 0;
    app_DW.is_c90_app = app_IN_DISSts_OFF;
    app_B.ACC_V_ACCMemSpd_sg = 0.0F;
    app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
  } else {
    /* Constant: '<S999>/ACCSwitch_On2' */
    /*    */
    if ((*LogicalOperator == C_ACC_HMISwitch_On_bl) || (m_FSM_sts_ACCSMRSts_en ==
         eACCReqStsStandby) || (m_FSM_sts_ACCSMRSts_en == eStandStillWait) ||
        (m_FSM_sts_ACCSMRSts_en == eACCRevsFault) || (m_FSM_sts_ACCSMRSts_en ==
         eACCIRRevsFault) || (m_FSM_sts_ACCSMRSts_en == eACCReqStsBrkOnly)) {
      /* This entry condition is used for keep the shortest time  staying in CrsSpdSet state. */
      app_DW.is_Speed_Decrease = 0;
      app_DW.is_Speed_Increase = 0;
      app_DW.is_DISSts_Active = 0;
      app_DW.is_c90_app = IN_DISSts_Standby_BrkOnly_StslWait_Fau;
      app_DW.is_DISSts_Standby_BrkOnly_StslWait_Fau = app_IN_MemSpdGetValue;
      app_B.ACC_V_ACCMemSpd_sg = app_B.ACC_V_ACCSetSpdIPKRAW_sg;
      app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
    } else {
      app_DW.ACCCrsSpdSet_Ctrl++;
      switch (app_DW.is_DISSts_Active) {
       case app_IN_Initial_ACCSetSpeed:
        /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1'
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg1':
         *  0x0  Resume speed +1 OFF
         *  0x1  Resume speed +1 ON
         */
        if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
            (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_DISSts_Active = app_IN_Speed_Increase;

          /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
          app_DW.is_Speed_Increase = app_IN_Large_Increase;
          app_SpeedInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
        } else if ((((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
                     P_ACC_is_HMIResumeIncSpdConfig_bl) ||
                    (app_B.ACCSpdIncSwHldCmd == C_ACC_HMISwitch_On_bl)) &&
                   (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_DISSts_Active = app_IN_Speed_Increase;

          /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
          app_DW.is_Speed_Increase = app_IN_Light_Increase;
          app_SpeedInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
        } else {
          /* the P_VLC_VACSETSwCntr is used to avoid entering into the state
             SpeedDec_One directly when the driver presses set button.
             (    (ACCCrsSpdSet_Ctrl>=P_ACC_cntr_SETBtnDecFunc_u16)&&(DFIn_is_ACCSwSetSw_bl == 1)&&(abs(ACC_V_ACCSetSpdIPKRAW_sg - DFIn_V_EgoAvgVehSpdIPK_u16)<P_ACC_V_SETBtnDecMax_u8))||    */
          if (app_B.ACCSpdIncSwHldCmd_m && (*ACC_is_DISSetSpdChgEnbl_bl)) {
            app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
            app_DW.is_Speed_Decrease = app_IN_Light_SpeedDecrease;
            app_SpeedDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
          } else if ((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) && (*
                      ACC_is_DISSetSpdChgEnbl_bl)) {
            app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
            app_DW.is_Speed_Decrease = app_IN_Large_SpeedDecrease;
            app_SpeedDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
          } else {
            /* To avoid the state stays in the Initial_ACC_V_ACCSetSpdIPKRAW_sg, otherwise the speed cannot be update when pressing the set button */
            app_DW.is_DISSts_Active = app_IN_Speed_Increase;

            /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
            app_DW.is_Speed_Increase = app_IN_Spd_Inc_Wait;
          }
        }
        break;

       case app_IN_ResumeSpeed:
        /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1' incorporates:
         *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg1':
         *  0x0  Resume speed +1 OFF
         *  0x1  Resume speed +1 ON
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg2':
         *  0x0  SET speed -1 OFF
         *  0x1  SET speed 11 ON
         */
        /* 20171101
           C: Change the Destination of this condition from the exteranl state to the Large_Inc State */
        if ((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) &&
            (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
          app_DW.is_Speed_Decrease = app_IN_Large_SpeedDecrease;
          app_SpeedDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
        } else if ((((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
                     P_ACC_is_HMISETDecSpdConfig_bl) ||
                    (app_B.ACCSpdIncSwHldCmd_m == C_ACC_HMISwitch_On_bl)) &&
                   (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
          app_DW.is_Speed_Decrease = app_IN_Light_SpeedDecrease;
          app_SpeedDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
        } else if ((((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
                     P_ACC_is_HMIResumeIncSpdConfig_bl) ||
                    (app_B.ACCSpdIncSwHldCmd == C_ACC_HMISwitch_On_bl)) &&
                   (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_DISSts_Active = app_IN_Speed_Increase;

          /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
          app_DW.is_Speed_Increase = app_IN_Light_Increase;
          app_SpeedInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
        } else {
          /* 20171101
             C: Change the Destination of this condition from the exteranl state to the Large_Inc State */
          if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
              (*ACC_is_DISSetSpdChgEnbl_bl)) {
            app_DW.is_DISSts_Active = app_IN_Speed_Increase;

            /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
            app_DW.is_Speed_Increase = app_IN_Large_Increase;
            app_SpeedInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
          } else {
            app_DW.is_DISSts_Active = app_IN_Speed_Increase;

            /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
            app_DW.is_Speed_Increase = app_IN_Spd_Inc_Wait;
          }
        }
        break;

       case app_IN_Speed_Decrease:
        /* Constant: '<S999>/P_ACC_cntr_SETBtnDecFunc_u8' incorporates:
         *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1'
         *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg1':
         *  0x0  Resume speed +1 OFF
         *  0x1  Resume speed +1 ON
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg2':
         *  0x0  SET speed -1 OFF
         *  0x1  SET speed 11 ON
         */
        if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
            (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_Speed_Decrease = 0;
          app_DW.is_DISSts_Active = app_IN_Speed_Increase;

          /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
          app_DW.is_Speed_Increase = app_IN_Large_Increase;
          app_SpeedInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
        } else if ((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) && ((fabsf
                     (app_B.ACC_V_ACCSetSpdIPKRAW_sg - (real32_T)
                      *DFIn_V_VIDPEstdEgoVehSpdIPK_u16) >= (real32_T)
                     P_ACC_V_HMISETBtnDecMax_u8) ||
                    (!P_ACC_is_HMISETDecSpdConfig_bl)) &&
                   (*ACC_is_DISSetSpdSetEnbl_bl)) {
          app_DW.is_Speed_Decrease = 0;
          app_DW.is_DISSts_Active = app_IN_Initial_ACCSetSpeed;

          /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
          if (P_ACC_V_HMIMinCrsSetSpd_u8 > *DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            y = (uint16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
          } else {
            y = *DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
          }

          if (*P_ACC_V_MaxCrsSpdThrs_u8 < y) {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)*P_ACC_V_MaxCrsSpdThrs_u8;
          } else {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)y;
          }
        } else if ((((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
                     P_ACC_is_HMIResumeIncSpdConfig_bl) ||
                    (app_B.ACCSpdIncSwHldCmd == C_ACC_HMISwitch_On_bl)) &&
                   (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_Speed_Decrease = 0;
          app_DW.is_DISSts_Active = app_IN_Speed_Increase;

          /*  Delete the Self-entering DFIn_is_ACCSwSpdIncSw_bl ==C_Switch_On_bl for Large_Increase State, since  */
          app_DW.is_Speed_Increase = app_IN_Light_Increase;
          app_SpeedInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
        } else {
          switch (app_DW.is_Speed_Decrease) {
           case app_IN_Large_SpeedDecrease:
            /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
             *
             * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg2':
             *  0x0  SET speed -1 OFF
             *  0x1  SET speed 11 ON
             */
            if ((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
                P_ACC_is_HMISETDecSpdConfig_bl) {
              /* ||  (DFIn_is_ACCSwSpdDecSwHldCmd_bl == C_Switch_On_bl) */
              app_DW.is_Speed_Decrease = app_IN_Light_SpeedDecrease;
              app_SpeedDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_Speed_Decrease = app_IN_Spd_Dec_Wait;
            }
            break;

           case app_IN_Light_SpeedDecrease:
            if (app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) {
              app_DW.is_Speed_Decrease = app_IN_Large_SpeedDecrease;
              app_SpeedDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_Speed_Decrease = app_IN_Spd_Dec_Wait;
            }
            break;

           default:
            /* case IN_Spd_Dec_Wait: */
            if (((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) ||
                 (*ACC_is_TJAOvrSpd_bl)) && (*ACC_is_DISSetSpdChgEnbl_bl)) {
              app_DW.is_Speed_Decrease = app_IN_Large_SpeedDecrease;
              app_SpeedDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
               *
               * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg2':
               *  0x0  SET speed -1 OFF
               *  0x1  SET speed 11 ON
               */
              /*   */
              if (((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
                   P_ACC_is_HMISETDecSpdConfig_bl) ||
                  (((app_B.ACCSpdIncSwHldCmd_m == C_ACC_HMISwitch_On_bl) ||
                    (*ACC_is_TJAOvrSpd_bl)) && (*ACC_is_DISSetSpdChgEnbl_bl))) {
                app_DW.is_Speed_Decrease = app_IN_Light_SpeedDecrease;
                app_SpeedDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
              }
            }
            break;
          }
        }
        break;

       default:
        /* Constant: '<S999>/P_ACC_cntr_SETBtnDecFunc_u8' incorporates:
         *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg2'
         *
         * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg2':
         *  0x0  SET speed -1 OFF
         *  0x1  SET speed 11 ON
         */
        /* case IN_Speed_Increase: */
        if ((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) && ((fabsf
              (app_B.ACC_V_ACCSetSpdIPKRAW_sg - (real32_T)
               *DFIn_V_VIDPEstdEgoVehSpdIPK_u16) >= (real32_T)
              P_ACC_V_HMISETBtnDecMax_u8) || (!P_ACC_is_HMISETDecSpdConfig_bl)) &&
            (*ACC_is_DISSetSpdSetEnbl_bl)) {
          app_DW.is_Speed_Increase = 0;
          app_DW.is_DISSts_Active = app_IN_Initial_ACCSetSpeed;

          /* Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg' */
          if (P_ACC_V_HMIMinCrsSetSpd_u8 > *DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            y = (uint16_T)P_ACC_V_HMIMinCrsSetSpd_u8;
          } else {
            y = *DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
          }

          if (*P_ACC_V_MaxCrsSpdThrs_u8 < y) {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)*P_ACC_V_MaxCrsSpdThrs_u8;
          } else {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)y;
          }
        } else if (((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
                    P_ACC_is_HMISETDecSpdConfig_bl) ||
                   (((app_B.ACCSpdIncSwHldCmd_m == C_ACC_HMISwitch_On_bl) ||
                     (*ACC_is_TJAOvrSpd_bl)) && (*ACC_is_DISSetSpdChgEnbl_bl)))
        {
          app_DW.is_Speed_Increase = 0;
          app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
          app_DW.is_Speed_Decrease = app_IN_Light_SpeedDecrease;
          app_SpeedDec_One(P_ACC_V_MaxCrsSpdThrs_u8);
        } else if (((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) ||
                    (*ACC_is_TJAOvrSpd_bl)) && (*ACC_is_DISSetSpdChgEnbl_bl)) {
          app_DW.is_Speed_Increase = 0;
          app_DW.is_DISSts_Active = app_IN_Speed_Decrease;
          app_DW.is_Speed_Decrease = app_IN_Large_SpeedDecrease;
          app_SpeedDec_Large(P_ACC_V_MaxCrsSpdThrs_u8);
        } else {
          switch (app_DW.is_Speed_Increase) {
           case app_IN_Large_Increase:
            /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1'
             *
             * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg1':
             *  0x0  Resume speed +1 OFF
             *  0x1  Resume speed +1 ON
             */
            if ((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
                P_ACC_is_HMIResumeIncSpdConfig_bl) {
              /* ||  (DFIn_is_ACCSwSpdIncSwHldCmd_bl == C_Switch_On_bl) */
              app_DW.is_Speed_Increase = app_IN_Light_Increase;
              app_SpeedInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_Speed_Increase = app_IN_Spd_Inc_Wait;
            }
            break;

           case app_IN_Light_Increase:
            if (app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) {
              app_DW.is_Speed_Increase = app_IN_Large_Increase;
              app_SpeedInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_Speed_Increase = app_IN_Spd_Inc_Wait;
            }
            break;

           default:
            /* Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg1'
             *
             * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg1':
             *  0x0  Resume speed +1 OFF
             *  0x1  Resume speed +1 ON
             */
            /* case IN_Spd_Inc_Wait: */
            if ((((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
                  P_ACC_is_HMIResumeIncSpdConfig_bl) || (app_B.ACCSpdIncSwHldCmd
                  == C_ACC_HMISwitch_On_bl)) && (*ACC_is_DISSetSpdChgEnbl_bl)) {
              app_DW.is_Speed_Increase = app_IN_Light_Increase;
              app_SpeedInc_One(P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
                  (*ACC_is_DISSetSpdChgEnbl_bl)) {
                app_DW.is_Speed_Increase = app_IN_Large_Increase;
                app_SpeedInc_Large(P_ACC_V_MaxCrsSpdThrs_u8);
              }
            }
            break;
          }
        }
        break;
      }
    }

    /* End of Constant: '<S999>/ACCSwitch_On2' */
  }

  /* End of Constant: '<S999>/ACCSwitch_Off2' */
}

/* Function for Chart: '<S1024>/ACCPtMdJud_IP31' */
static void app_enter_internal_ACCPtMd_Norm(const eVLD_ValidSts
  *DataTypeConversion49, const eTRP_TrShftPtrn *DataTypeConversion50, const
  boolean_T *DFIn_is_VIDPTrShftLvrPosEn_bl)
{
  if (((*DFIn_is_VIDPTrShftLvrPosEn_bl) && (*DataTypeConversion49 == VLD_Valid) &&
       (*DataTypeConversion50 == TRP_SftPttrn2Act)) ||
      ((*DFIn_is_VIDPTrShftLvrPosEn_bl) && (*DataTypeConversion49 == VLD_Valid) &&
       (*DataTypeConversion50 == TRP_SftPttrn3Act))) {
    app_DW.is_ACCPtMd_Norm = app_IN_ACCPtMd_Norm_NotSupt;
  } else {
    app_DW.is_ACCPtMd_Norm = app_IN_ACCPtMd_Norm_Supt;
  }
}

/* Model step function */
void app_step(uint8_T arg_radar_pubcan_1046[8], uint8_T arg_radar_pubcan_858[8],
              uint8_T arg_radar_pubcan_677[8], uint8_T arg_radar_pubcan_175[8],
              uint8_T arg_radar_pubcan_481[8], uint8_T arg_radar_pubcan_562[8],
              uint8_T arg_radar_pubcan_1123[8], uint8_T arg_radar_pubcan_1130[8],
              uint8_T arg_radar_pubcan_588[8], uint8_T arg_radar_pubcan_1009[8],
              uint8_T arg_radar_pubcan_404[8], uint8_T arg_radar_pubcan_572[8],
              uint8_T arg_radar_pubcan_554[8], uint8_T arg_radar_pubcan_355[8],
              uint8_T arg_radar_pubcan_508[8], uint8_T arg_radar_pubcan_241[8],
              uint8_T arg_radar_pubcan_361[8], uint8_T arg_radar_pubcan_590[8],
              uint8_T arg_radar_pubcan_593[8], uint8_T arg_radar_pubcan_485[8],
              uint8_T arg_radar_pubcan_407[8], uint8_T arg_radar_pubcan_851[8],
              uint8_T arg_radar_pubcan_1345[8], uint8_T arg_radar_pubcan_201[8],
              uint8_T arg_radar_pubcan_1027[8], uint8_T arg_radar_pubcan_893[8],
              uint8_T arg_radar_pubcan_431[8], uint8_T arg_radar_pubcan_389[8],
              uint8_T arg_radar_pubcan_758[8], uint8_T arg_radar_pubcan_190[8],
              uint8_T arg_radar_pubcan_489[8], uint8_T arg_radar_pubcan_977[8],
              uint8_T arg_radar_pubcan_497[8], uint8_T arg_radar_pubcan_540[8],
              uint8_T arg_radar_pubcan_1146[8], uint8_T arg_radar_pubcan_398[8],
              uint8_T arg_radar_pubcan_251[8], uint8_T arg_radar_pubcan_1225[8],
              uint8_T arg_radar_pubcan_560[8], uint8_T arg_radar_pubcan_451[8],
              uint8_T arg_radar_pubcan_707[8], uint8_T arg_radar_pubcan_498[8],
              uint8_T arg_radar_pubcan_541[8], uint8_T arg_radar_pubcan_886[8],
              uint8_T arg_radar_pubcan_479[8], uint8_T arg_radar_pubcan_1344[8],
              uint8_T arg_radar_pubcan_795[8], uint8_T arg_Cam_can_492[8],
              uint8_T arg_Cam_can_516[8], real32_T arg_lateralPlan_laneWidth,
              real32_T arg_lateralPlan_lProb, real32_T arg_lateralPlan_rProb,
              real32_T arg_lateralPlan_dProb, real32_T
              arg_lateralPlan_rawCurvature, real32_T
              arg_lateralPlan_rawCurvatureRate, real32_T
              arg_lateralPlan_curvature, real32_T arg_lateralPlan_curvatureRate,
              real32_T arg_lateralPlan_pathCof_C3, real32_T
              arg_lateralPlan_pathCof_C2, real32_T arg_lateralPlan_pathCof_C1,
              real32_T arg_lateralPlan_pathCof_C0, boolean_T
              arg_lateralPlan_valid, boolean_T arg_lateralPlan_ctrlType,
              real32_T arg_lateralPlan_yPts[17], real32_T
              arg_lateralPlan_headPts[17], real32_T arg_Obj_01_Prob, real32_T
              arg_Obj_01_dx, real32_T arg_Obj_01_dy, real32_T arg_Obj_01_v,
              real32_T arg_Obj_01_a)
{
  real_T tFEBig[61];
  real_T tFEMid[41];
  real_T tFESml[21];
  real_T rtb_Add12;
  real_T rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg;
  real_T tmp_4;
  real_T tmp_5;
  real_T tmp_6;
  int32_T i_0;
  int32_T s1239_iter;
  int32_T tmp;
  real32_T x[61];
  real32_T b_x[41];
  real32_T c_x[21];
  real32_T rtb_Reshape[6];
  real32_T Add1_tmp[4];
  real32_T Add1_tmp_0[4];
  real32_T rtb_MatrixConcatenate[4];
  real32_T rtb_MatrixConcatenate1[4];
  real32_T rtb_MatrixConcatenate1_0[4];
  real32_T LmtViolt_SubIterm[3];
  real32_T MultiportSwitch[3];
  real32_T Add1_tmp_1[2];
  real32_T rtb_Switch1_g[2];
  real32_T tmp_0[2];
  real32_T Ax_Extrem1;
  real32_T Ax_Extrem1_b;
  real32_T Ax_Extrem1_n;
  real32_T Ax_Extrem1_ny;
  real32_T Ax_Extrem1_o;
  real32_T Ax_Extrem2;
  real32_T Ax_Extrem2_e;
  real32_T Ax_Extrem2_f;
  real32_T Ax_Extrem2_i;
  real32_T Ax_Extrem2_j;
  real32_T DFIn_a_EstdVSELongtAccel_sg;
  real32_T DataTypeConversion28;
  real32_T Jerk_Extrem;
  real32_T LimitationViolate;
  real32_T Longt_Spd_C0;
  real32_T Longt_Spd_C1;
  real32_T Merge3;
  real32_T Opt;
  real32_T Switch;
  real32_T a_traj_real_Spd_PrdtOneStp;
  real32_T ax_Max_Traj;
  real32_T c3;
  real32_T c4;
  real32_T c5;
  real32_T j_traj_real_Spd;
  real32_T nDLookupTable1;
  real32_T rtb_ACC_t_FTCDsrdDistLv1_sg;
  real32_T rtb_ACC_t_FTCDsrdDistLv2_sg;
  real32_T rtb_ACC_v_ACCSetSpd_sg;
  real32_T rtb_ARB_F_PCTWhlDrvnToq_sg;
  real32_T rtb_Add1_fd;
  real32_T rtb_Add2_fb;
  real32_T rtb_Add2_l;
  real32_T rtb_Add2_o;
  real32_T rtb_Add2_pgh;
  real32_T rtb_Add8;
  real32_T rtb_Add_g0;
  real32_T rtb_DFIn_a_EstdLongtAccelMnFilt_sg;
  real32_T rtb_Divide1;
  real32_T rtb_Divide4_aa;
  real32_T rtb_Divide4_b;
  real32_T rtb_Divide4_b0;
  real32_T rtb_Divide4_h1;
  real32_T rtb_Gain1_az;
  real32_T rtb_Gain1_bg;
  real32_T rtb_Gain1_jl;
  real32_T rtb_Gain1_pv;
  real32_T rtb_Gain5_i;
  real32_T rtb_Gain9_b;
  real32_T rtb_Gain9_e;
  real32_T rtb_Gain9_kp;
  real32_T rtb_Gain9_m;
  real32_T rtb_JerkSqIntg_t_end_fq;
  real32_T rtb_JerkSqIntg_t_end_or;
  real32_T rtb_KTt_a;
  real32_T rtb_KTt_af;
  real32_T rtb_KTt_b;
  real32_T rtb_KTt_h;
  real32_T rtb_KTt_m0;
  real32_T rtb_K_OsV_Os_au;
  real32_T rtb_K_OsV_Os_b;
  real32_T rtb_K_OsV_Os_bx;
  real32_T rtb_K_OsV_Os_c;
  real32_T rtb_K_OsV_Os_l;
  real32_T rtb_Lim_Violation_New_ck;
  real32_T rtb_MinMax1_p;
  real32_T rtb_MinMax_a0;
  real32_T rtb_Min_h;
  real32_T rtb_Min_l;
  real32_T rtb_Min_lp;
  real32_T rtb_Min_p;
  real32_T rtb_Product1_a4;
  real32_T rtb_Product1_da;
  real32_T rtb_Product1_ei;
  real32_T rtb_Product1_hd;
  real32_T rtb_Product1_j2z;
  real32_T rtb_Product1_n3;
  real32_T rtb_Product2_hzb;
  real32_T rtb_Product2_jb;
  real32_T rtb_Product2_jd;
  real32_T rtb_Product2_m2;
  real32_T rtb_Product2_mv;
  real32_T rtb_Product2_pl1;
  real32_T rtb_Product4_aq;
  real32_T rtb_Product4_dp;
  real32_T rtb_Product4_e5;
  real32_T rtb_Product4_ge;
  real32_T rtb_Product4_j;
  real32_T rtb_Product4_jc;
  real32_T rtb_Product4_k0;
  real32_T rtb_Product4_lc;
  real32_T rtb_Product4_no;
  real32_T rtb_Product4_p;
  real32_T rtb_Product_eqe;
  real32_T rtb_Product_iz;
  real32_T rtb_Product_lk;
  real32_T rtb_Subtract5;
  real32_T rtb_Switch_ai;
  real32_T rtb_Switch_ddv;
  real32_T rtb_Switch_hv;
  real32_T rtb_Switch_i;
  real32_T rtb_Switch_ik;
  real32_T rtb_Switch_ki;
  real32_T rtb_Switch_l5;
  real32_T rtb_Sx_Extrem1_New_c;
  real32_T rtb_Sx_Extrem1_New_g;
  real32_T rtb_Sx_Extrem2_New;
  real32_T rtb_Sx_Extrem2_New_i0;
  real32_T rtb_Sx_Extrem2_New_l;
  real32_T rtb_Vx_Extrem1_New_i;
  real32_T rtb_Vx_Extrem1_New_mr;
  real32_T rtb_Vx_Extrem2_New_a;
  real32_T rtb_Vx_Extrem2_New_bwb;
  real32_T rtb_Vx_Extrem2_New_ej;
  real32_T rtb_a_Max_Modify;
  real32_T rtb_a_Min_Modify;
  real32_T rtb_a_traj_FEMid;
  real32_T rtb_c3_f3;
  real32_T rtb_c3_kk;
  real32_T rtb_c3_ks;
  real32_T rtb_c4_ef;
  real32_T rtb_t24;
  real32_T rtb_t_Vx_Extrem1_New_go;
  real32_T rtb_t_Vx_Extrem2_New_ks;
  real32_T rtb_t_Vx_Extrem2_New_pk;
  real32_T rtb_t_min;
  real32_T rtb_uDLookupTable;
  real32_T rtb_uDLookupTable5_h;
  real32_T s_traj_real_Spd;
  real32_T t_Ax_Extrem1;
  real32_T t_Ax_Extrem1_e;
  real32_T t_Ax_Extrem1_f;
  real32_T t_Ax_Extrem1_j;
  real32_T t_Ax_Extrem1_k;
  real32_T t_Ax_Extrem2;
  real32_T t_Ax_Extrem2_a;
  real32_T t_Ax_Extrem2_e;
  real32_T t_Ax_Extrem2_g;
  real32_T t_Ax_Extrem2_l;
  real32_T t_Jerk_Extrem;
  real32_T t_end;
  real32_T v_traj_real_Spd;
  uint32_T qY;
  uint16_T DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
  uint16_T rtb_Divide_cd;
  int8_T i;
  uint8_T DataTypeConversion2;
  uint8_T Merge2_a;
  uint8_T P_ACC_V_MaxCrsSpdThrs_u8;
  uint8_T Traj_Numb;
  uint8_T rtb_ACC_indx_HMISeldDistLvl_u8;
  uint8_T rtb_DataTypeConversion2_i;
  uint8_T rtb_out_cond_n3;
  uint8_T tmp_1;
  uint8_T tmp_2;
  uint8_T tmp_3;
  boolean_T LogicalOperator;
  boolean_T rtb_Collision_New_dt;
  boolean_T rtb_Collision_New_k;
  boolean_T rtb_Compare_hj;
  boolean_T rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m;
  boolean_T rtb_DFIn_is_AEBPStsDsbl_bl;
  boolean_T rtb_DFIn_is_AEBStsDsbl_bl;
  boolean_T rtb_DFIn_is_APAStsDsbl_bl;
  boolean_T rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;
  boolean_T rtb_DFIn_is_CCFM_BntStsDsbl_bl_l;
  boolean_T rtb_DFIn_is_CCFM_BntStsDsbl_bl_p;
  boolean_T rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o;
  boolean_T rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;
  boolean_T rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d;
  boolean_T rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f;
  boolean_T rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p;
  boolean_T rtb_DFIn_is_CCFM_TCSStsFlt_bl_d;
  boolean_T rtb_DFIn_is_CCFM_VSEStsFlt_bl_d;
  boolean_T rtb_DFIn_is_EPBAppcnStsApp_bl;
  boolean_T rtb_DFIn_is_EPBCCCanclDsbl_bl;
  boolean_T rtb_DFIn_is_NRCDStsDsbl_bl;
  boolean_T rtb_LogicalOperator10_mo;
  boolean_T rtb_LogicalOperator1_d2;
  boolean_T rtb_LogicalOperator1_pr;
  boolean_T rtb_LogicalOperator2_e5;
  boolean_T rtb_LogicalOperator2_fg;
  boolean_T rtb_LogicalOperator2_hk;
  boolean_T rtb_LogicalOperator2_hs;
  boolean_T rtb_LogicalOperator2_kx;
  boolean_T rtb_LogicalOperator3_d;
  boolean_T rtb_LogicalOperator3_ht;
  boolean_T rtb_LogicalOperator3_n0p;
  boolean_T rtb_LogicalOperator3_ox;
  boolean_T rtb_LogicalOperator4_ec;
  boolean_T rtb_LogicalOperator4_jt;
  boolean_T rtb_LogicalOperator5_m;
  boolean_T rtb_LogicalOperator9_a;
  boolean_T rtb_LogicalOperator9_kf;
  boolean_T rtb_LogicalOperator9_o;
  boolean_T rtb_OR_cr;
  boolean_T rtb_OR_f;
  boolean_T rtb_OR_p;
  boolean_T rtb_Out;
  boolean_T rtb_Out_a;
  boolean_T rtb_Out_bg;
  boolean_T rtb_Out_dl;
  boolean_T rtb_Out_h5;
  boolean_T rtb_Out_i;
  boolean_T rtb_Out_j;
  boolean_T rtb_Out_k;
  boolean_T rtb_Out_oy;
  boolean_T rtb_Out_p;
  boolean_T rtb_RelationalOperator7_oa;
  boolean_T rtb_RelationalOperator_io;
  boolean_T rtb_SeatBeltOn_o;
  boolean_T rtb_Switch_bh;
  boolean_T rtb_Switch_ev;
  boolean_T rtb_Switch_gf;
  boolean_T rtb_Switch_gy;
  boolean_T rtb_Switch_ha;
  boolean_T rtb_Switch_jp;
  boolean_T rtb_Switch_mg;
  boolean_T rtb_Switch_o3;
  boolean_T rtb_Switch_os;
  boolean_T rtb_Switch_otx;
  boolean_T rtb_Traj_Valid_New_e;
  boolean_T rtb_Traj_Valid_New_jh;
  E_ACCAccReqSts_t rtb_DataTypeConversion3;
  ZCEventType zcEvent;
  eBPL_BrkPdlApl DataTypeConversion30;
  eCCR_ACCCancelReq rtb_DA_OUT_indx_ACCSysCanclReq_u8;
  eCDL_ACCDistLvl rtb_DA_OUT_indx_ACCDetObjDistLvl_u8;
  eCPR_PTCruzResp rtb_DataTypeConversion64;
  eCSRP_SCSReqRsp rtb_DataTypeConversion63;
  eDOS_DoorOpenSts rtb_DataTypeConversion6_m;
  eDSL_DrvrSetLvl rtb_ACC_indx_DISTmDist_en;
  eFLT_SysFltSts rtb_ACC_indx_HMISysFltStsHMI_u8;
  eHDC_HDCSysSts rtb_DataTypeConversion17;
  eMS_MotionState rtb_Switch_jk;
  ePWR_PwrMd DataTypeConversion19;
  eTCSS_TCSSts rtb_DataTypeConversion14;
  eTGR_TrmGear rtb_DataTypeConversion37;
  eTLP_ShftLvrPos rtb_DataTypeConversion8;
  eTRP_TrShftPtrn DataTypeConversion50;
  eVLD_ValidSts rtb_Switch4;
  eVSES_VSESts rtb_DataTypeConversion15;
  eVSL_StdStlSts rtb_DataTypeConversion45;
  UNUSED_PARAMETER(arg_radar_pubcan_1046);
  UNUSED_PARAMETER(arg_radar_pubcan_175);
  UNUSED_PARAMETER(arg_radar_pubcan_1123);
  UNUSED_PARAMETER(arg_radar_pubcan_1009);
  UNUSED_PARAMETER(arg_radar_pubcan_572);
  UNUSED_PARAMETER(arg_radar_pubcan_554);
  UNUSED_PARAMETER(arg_radar_pubcan_508);
  UNUSED_PARAMETER(arg_radar_pubcan_241);
  UNUSED_PARAMETER(arg_radar_pubcan_361);
  UNUSED_PARAMETER(arg_radar_pubcan_407);
  UNUSED_PARAMETER(arg_radar_pubcan_1345);
  UNUSED_PARAMETER(arg_radar_pubcan_1027);
  UNUSED_PARAMETER(arg_radar_pubcan_893);
  UNUSED_PARAMETER(arg_radar_pubcan_431);
  UNUSED_PARAMETER(arg_radar_pubcan_758);
  UNUSED_PARAMETER(arg_radar_pubcan_190);
  UNUSED_PARAMETER(arg_radar_pubcan_977);
  UNUSED_PARAMETER(arg_radar_pubcan_1146);
  UNUSED_PARAMETER(arg_radar_pubcan_398);
  UNUSED_PARAMETER(arg_radar_pubcan_1225);
  UNUSED_PARAMETER(arg_radar_pubcan_451);
  UNUSED_PARAMETER(arg_radar_pubcan_498);
  UNUSED_PARAMETER(arg_radar_pubcan_541);
  UNUSED_PARAMETER(arg_radar_pubcan_886);
  UNUSED_PARAMETER(arg_radar_pubcan_1344);
  UNUSED_PARAMETER(arg_radar_pubcan_795);
  UNUSED_PARAMETER(arg_lateralPlan_laneWidth);
  UNUSED_PARAMETER(arg_lateralPlan_rawCurvatureRate);
  UNUSED_PARAMETER(arg_lateralPlan_curvature);
  UNUSED_PARAMETER(arg_lateralPlan_curvatureRate);
  UNUSED_PARAMETER(arg_lateralPlan_valid);
  UNUSED_PARAMETER(arg_lateralPlan_yPts);
  UNUSED_PARAMETER(arg_lateralPlan_headPts);
  UNUSED_PARAMETER(arg_Obj_01_dy);

  /* MinMax: '<S1060>/MinMax' incorporates:
   *  S-Function (sfix_udelay): '<S1060>/Tapped Delay'
   */
  rtb_Divide1 = app_DW.TappedDelay_X[0];
  for (i_0 = 0; i_0 < 9; i_0++) {
    rtb_Divide1 = fminf(rtb_Divide1, app_DW.TappedDelay_X[(int32_T)(i_0 + 1)]);
  }

  /* Sum: '<S1060>/Sum of Elements' incorporates:
   *  S-Function (sfix_udelay): '<S1060>/Tapped Delay'
   */
  DFIn_a_EstdVSELongtAccel_sg = -0.0F;
  for (i_0 = 0; i_0 < 10; i_0++) {
    DFIn_a_EstdVSELongtAccel_sg += app_DW.TappedDelay_X[i_0];
  }

  /* MinMax: '<S1060>/MinMax1' incorporates:
   *  S-Function (sfix_udelay): '<S1060>/Tapped Delay'
   */
  rtb_Switch_l5 = app_DW.TappedDelay_X[0];
  for (i_0 = 0; i_0 < 9; i_0++) {
    rtb_Switch_l5 = fmaxf(rtb_Switch_l5, app_DW.TappedDelay_X[(int32_T)(i_0 + 1)]);
  }

  /* Product: '<S1060>/Divide4' incorporates:
   *  Constant: '<S1060>/2 wheels3'
   *  Constant: '<S1060>/P_VDC_FSCAccelCmftUpRt_sg'
   *  MinMax: '<S1060>/MinMax'
   *  MinMax: '<S1060>/MinMax1'
   *  Product: '<S1060>/Divide5'
   *  Product: '<S1060>/Divide6'
   *  Sum: '<S1060>/Add'
   *  Sum: '<S1060>/Subtract'
   *  Sum: '<S1060>/Sum of Elements'
   */
  rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg = (real_T)((DFIn_a_EstdVSELongtAccel_sg -
    rtb_Divide1) - rtb_Switch_l5) / (P_DFIn_cntr_VIDPEgoSpdAvgFltr_d *
    0.0099999997764825821 / 0.019999999552965164 - 2.0);

  /* Sum: '<S1060>/Add12' incorporates:
   *  UnitDelay: '<S1060>/spdD3'
   */
  rtb_Add12 = rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg - app_DW.spdD3_DSTATE;

  /* Sum: '<S1060>/Add13' incorporates:
   *  Abs: '<S1060>/Abs6'
   *  Abs: '<S1060>/Abs7'
   *  Constant: '<S1060>/2 wheels4'
   *  Lookup_n-D: '<S1060>/LookupTable'
   *  Lookup_n-D: '<S1060>/LookupTable4'
   *  MinMax: '<S1060>/Min'
   *  Product: '<S1060>/Divide4'
   *  Product: '<S1060>/Product4'
   *  Product: '<S1060>/Product6'
   *  Sum: '<S1060>/Add11'
   *  UnitDelay: '<S1060>/Unit Delay2'
   *  UnitDelay: '<S1060>/spdD3'
   */
  app_DW.spdD3_DSTATE += fmin(look2_binlcpw(fabs(rtb_Add12), fabs
    (rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg - app_DW.UnitDelay2_DSTATE),
    app_ConstP.LookupTable4_bp01Data, app_ConstP.LookupTable4_bp02Data,
    app_ConstP.LookupTable4_tableData, app_ConstP.LookupTable4_maxIndex, 5U) *
    look1_binlcpw(rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg,
                  app_ConstP.LookupTable_bp01Data,
                  app_ConstP.LookupTable_tableData, 4U), 1.0) * rtb_Add12;

  /* BusCreator: '<S25>/Bus Creator' incorporates:
   *  Constant: '<S25>/Constant'
   *  Constant: '<S25>/Constant1'
   *  Constant: '<S25>/Constant2'
   *  Constant: '<S25>/Constant3'
   *  Constant: '<S25>/Constant4'
   *  Constant: '<S25>/Constant5'
   *  Inport: '<Root>/radar_pubcan_858'
   */
  app_B.BusCreator.Extended = 0U;
  app_B.BusCreator.Length = 8U;
  app_B.BusCreator.Remote = 0U;
  app_B.BusCreator.Error = 0U;
  app_B.BusCreator.ID = 858U;
  app_B.BusCreator.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator.Data[i_0] = arg_radar_pubcan_858[i_0];
  }

  /* End of BusCreator: '<S25>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack27' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack27' */
    if ((8 == app_B.BusCreator.Length) && (app_B.BusCreator.ID != INVALID_CAN_ID)
        ) {
      if ((858 == app_B.BusCreator.ID) && (0U == app_B.BusCreator.Extended) ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 40
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator.Data[5]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_ClstrDspdVehSpd = result;
            }
          }
        }
      }
    }
  }

  /* Switch: '<S1061>/Switch' incorporates:
   *  Constant: '<S1061>/Constant'
   */
  if (P_ACC_is_VIDPIPKSpdUseEstdVal_bl) {
    /* DataTypeConversion: '<S1061>/Data Type Conversion' incorporates:
     *  Abs: '<S1061>/Abs'
     *  Constant: '<S1061>/Constant4'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Gain: '<S1061>/UnitChange2kph4'
     *  Product: '<S1061>/Divide7'
     *  UnitDelay: '<S1060>/spdD3'
     *
     * Block description for '<S1061>/Constant4':
     *  C_system_step = 0.01s.
     *  DFIn_V_EgoAvgVehSpd * IPK ratio
     */
    DFIn_a_EstdVSELongtAccel_sg = roundf(3.6F * fabsf((real32_T)
      app_DW.spdD3_DSTATE) * C_ADS_Gx_ActuSpdToIPKSpd_sg);
    if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg) || rtIsInfF
        (DFIn_a_EstdVSELongtAccel_sg)) {
      DFIn_a_EstdVSELongtAccel_sg = 0.0F;
    } else {
      DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
    }

    /* Switch: '<S1061>/Switch' incorporates:
     *  DataTypeConversion: '<S1061>/Data Type Conversion'
     */
    DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)(DFIn_a_EstdVSELongtAccel_sg <
      0.0F ? (int32_T)(uint16_T)(int32_T)-(int32_T)(int16_T)(uint16_T)
      -DFIn_a_EstdVSELongtAccel_sg : (int32_T)(uint16_T)
      DFIn_a_EstdVSELongtAccel_sg);
  } else {
    /* DataTypeConversion: '<S1061>/Data Type Conversion1' incorporates:
     *  DataTypeConversion: '<S5>/Data Type Conversion12'
     */
    DFIn_a_EstdVSELongtAccel_sg = roundf((real32_T)app_B.IPK_ClstrDspdVehSpd);
    if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg) || rtIsInfF
        (DFIn_a_EstdVSELongtAccel_sg)) {
      DFIn_a_EstdVSELongtAccel_sg = 0.0F;
    } else {
      DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
    }

    /* Switch: '<S1061>/Switch' incorporates:
     *  DataTypeConversion: '<S1061>/Data Type Conversion1'
     */
    DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)(DFIn_a_EstdVSELongtAccel_sg <
      0.0F ? (int32_T)(uint16_T)(int32_T)-(int32_T)(int16_T)(uint16_T)
      -DFIn_a_EstdVSELongtAccel_sg : (int32_T)(uint16_T)
      DFIn_a_EstdVSELongtAccel_sg);
  }

  /* End of Switch: '<S1061>/Switch' */

  /* BusAssignment: '<S5>/Bus Assignment' incorporates:
   *  Constant: '<S8>/Constant'
   *  DataTypeConversion: '<S5>/Data Type Conversion111'
   *  Inport: '<Root>/Obj_01_Prob'
   *  RelationalOperator: '<S8>/Compare'
   */
  rtb_out_cond_n3 = (uint8_T)(arg_Obj_01_Prob > 0.5F);

  /* Saturate: '<S5>/Saturation' incorporates:
   *  Bias: '<S5>/Bias'
   *  Inport: '<Root>/Obj_01_dx'
   */
  if (arg_Obj_01_dx + -2.0F > 150.0F) {
    /* BusAssignment: '<S5>/Bus Assignment' */
    rtb_uDLookupTable = 150.0F;
  } else if (arg_Obj_01_dx + -2.0F < 0.0F) {
    /* BusAssignment: '<S5>/Bus Assignment' */
    rtb_uDLookupTable = 0.0F;
  } else {
    /* BusAssignment: '<S5>/Bus Assignment' */
    rtb_uDLookupTable = arg_Obj_01_dx + -2.0F;
  }

  /* End of Saturate: '<S5>/Saturation' */

  /* BusCreator: '<S51>/Bus Creator' incorporates:
   *  Constant: '<S51>/Constant'
   *  Constant: '<S51>/Constant1'
   *  Constant: '<S51>/Constant2'
   *  Constant: '<S51>/Constant3'
   *  Constant: '<S51>/Constant4'
   *  Constant: '<S51>/Constant5'
   *  Inport: '<Root>/radar_pubcan_497'
   */
  app_B.BusCreator_e.Extended = 0U;
  app_B.BusCreator_e.Length = 8U;
  app_B.BusCreator_e.Remote = 0U;
  app_B.BusCreator_e.Error = 0U;
  app_B.BusCreator_e.ID = 497U;
  app_B.BusCreator_e.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_e.Data[i_0] = arg_radar_pubcan_497[i_0];
  }

  /* End of BusCreator: '<S51>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack' */
    if ((8 == app_B.BusCreator_e.Length) && (app_B.BusCreator_e.ID !=
         INVALID_CAN_ID) ) {
      if ((497 == app_B.BusCreator_e.ID) && (0U == app_B.BusCreator_e.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 2
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[0]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_PwrMdMstrAccryA = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[0]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_PwrMdMstrRunCrk = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 4
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[0]) & (uint8_T)(0x70U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_SysOpnlMd = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 0
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[0]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_SysPwrMd_h1 = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_SysVolMdV = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 57
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[7]) & (uint8_T)(0x6U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_SysVolMd = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 32
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_e.Data[4]) & (uint8_T)(0x1U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_SysVolV = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 40
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.1
           *  offset                  = 3.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_e.Data[5]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.1) + 3.0;
              app_B.BCM_SysVol = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion85' */
  rtb_Add12 = floor(app_B.BCM_SysPwrMd_h1);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion19' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion85'
   */
  DataTypeConversion19 = (ePWR_PwrMd)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* RelationalOperator: '<S1019>/Compare' incorporates:
   *  BusAssignment: '<S5>/Bus Assignment'
   *  Constant: '<S1019>/Constant'
   */
  long_out_isLeadVehDtct = ((int32_T)rtb_out_cond_n3 != 0);

  /* BusCreator: '<S30>/Bus Creator' incorporates:
   *  Constant: '<S30>/Constant'
   *  Constant: '<S30>/Constant1'
   *  Constant: '<S30>/Constant2'
   *  Constant: '<S30>/Constant3'
   *  Constant: '<S30>/Constant4'
   *  Constant: '<S30>/Constant5'
   *  Inport: '<Root>/radar_pubcan_355'
   */
  app_B.BusCreator_i.Extended = 0U;
  app_B.BusCreator_i.Length = 8U;
  app_B.BusCreator_i.Remote = 0U;
  app_B.BusCreator_i.Error = 0U;
  app_B.BusCreator_i.ID = 355U;
  app_B.BusCreator_i.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_i.Data[i_0] = arg_radar_pubcan_355[i_0];
  }

  /* End of BusCreator: '<S30>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack42' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack42' */
    if ((8 == app_B.BusCreator_i.Length) && (app_B.BusCreator_i.ID !=
         INVALID_CAN_ID) ) {
      if ((355 == app_B.BusCreator_i.ID) && (0U == app_B.BusCreator_i.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 10
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i.Data[1]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SDM_AirBagDplInvsn = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 11
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i.Data[1]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SDM_AirbagDpl = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 13
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i.Data[1]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SDM_DrvrSbltAtcV = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 12
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i.Data[1]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SDM_DrvrSbltAtc = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 0
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_i.Data[0]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SDM_SDMRC = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion99' */
  rtb_Add12 = floor(app_B.SDM_AirBagDplInvsn);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* Logic: '<S953>/Logical Operator2' incorporates:
   *  Constant: '<S953>/FW_P_ACC_is_CCFM_AirbagStsIN_bl_1'
   *  Constant: '<S953>/TRUE_BL1'
   *  DataTypeConversion: '<S5>/Data Type Conversion61'
   *  DataTypeConversion: '<S5>/Data Type Conversion62'
   *  DataTypeConversion: '<S5>/Data Type Conversion99'
   *  Logic: '<S953>/Logical Operator1'
   *  RelationalOperator: '<S953>/Relational Operator1'
   */
  rtb_LogicalOperator2_hk = ((app_B.SDM_AirbagDpl != 0.0) && ((eADI_AirBagDplIvn)
    (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)
              (uint8_T)-rtb_Add12 : (int32_T)(uint8_T)rtb_Add12) ==
    ADI_Airbag_Deployed) && P_ACC_is_CCFM_AirbagStsIN_bl);

  /* Logic: '<S952>/Logical Operator9' incorporates:
   *  Constant: '<S952>/FW_P_ACC_is_CCFM_APAActvIN_bl_1'
   */
  rtb_DFIn_is_APAStsDsbl_bl = (app_ConstB.DFIn_is_APAStsDsbl_bl &&
    P_ACC_is_CCFM_APAActvIN_bl);

  /* Logic: '<S952>/Logical Operator6' incorporates:
   *  Constant: '<S952>/FW_P_ACC_is_CCFM_NRCDActvIN_bl_1'
   */
  rtb_DFIn_is_NRCDStsDsbl_bl = (app_ConstB.DFIn_is_NRCDStsDsbl_bl &&
    P_ACC_is_CCFM_NRCDActvIN_bl);

  /* BusCreator: '<S35>/Bus Creator' incorporates:
   *  Constant: '<S35>/Constant'
   *  Constant: '<S35>/Constant1'
   *  Constant: '<S35>/Constant2'
   *  Constant: '<S35>/Constant3'
   *  Constant: '<S35>/Constant4'
   *  Constant: '<S35>/Constant5'
   *  Inport: '<Root>/radar_pubcan_593'
   */
  app_B.BusCreator_a.Extended = 0U;
  app_B.BusCreator_a.Length = 8U;
  app_B.BusCreator_a.Remote = 0U;
  app_B.BusCreator_a.Error = 0U;
  app_B.BusCreator_a.ID = 593U;
  app_B.BusCreator_a.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_a.Data[i_0] = arg_radar_pubcan_593[i_0];
  }

  /* End of BusCreator: '<S35>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack41' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack41' */
    if ((8 == app_B.BusCreator_a.Length) && (app_B.BusCreator_a.ID !=
         INVALID_CAN_ID) ) {
      if ((593 == app_B.BusCreator_a.ID) && (0U == app_B.BusCreator_a.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 17
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[2]) & (uint8_T)(0x1EU)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChACCAEBAlvRlngCtr_Radar_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_a.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChACCAEBChksm_Radar_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 3
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[0]) & (uint8_T)(0x38U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChACCAccReqResp_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 14
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[1]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChACCReqFlrSts_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 8
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[1]) & (uint8_T)(0x7U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChAEBBrkJerkReqResp = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 21
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[2]) & (uint8_T)(0xE0U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChAEBDclReqResp = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 0
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[0]) & (uint8_T)(0x7U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChAEBHydBrkAstReqResp = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 11
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[1]) & (uint8_T)(0x38U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ChAEBPrflReqResp = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 6
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a.Data[0]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VehSdslSts_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 24
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.05
           *  offset                  = -7.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_a.Data[3]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.05) + -7.0;
              app_B.SCS_VehTrgtLongtAcc_Safety = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion100' */
  rtb_Add12 = floor(app_B.SCS_ChACCAccReqResp_Safety);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion63' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion100'
   */
  rtb_DataTypeConversion63 = (eCSRP_SCSReqRsp)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* Logic: '<S942>/Logical Operator5' incorporates:
   *  Constant: '<S950>/FW_P_ACC_is_CCFM_AccRepLArbEnIN_bl_1'
   *  Constant: '<S950>/FW_P_ACC_is_CCFM_AccRepPCndEnIN_bl_1'
   *  Constant: '<S962>/Constant2'
   *  Constant: '<S962>/Constant6'
   *  Logic: '<S942>/Logical Operator2'
   *  Logic: '<S942>/Logical Operator3'
   *  Logic: '<S942>/Logical Operator4'
   *  Logic: '<S952>/Logical Operator3'
   *  Logic: '<S952>/Logical Operator5'
   *  Logic: '<S953>/Logical Operator9'
   *  Logic: '<S965>/Logical Operator10'
   *  Logic: '<S965>/Logical Operator11'
   *  Logic: '<S965>/Logical Operator12'
   *  Logic: '<S965>/Logical Operator13'
   *  RelationalOperator: '<S962>/Relational Operator5'
   *  RelationalOperator: '<S962>/Relational Operator7'
   *
   * Block description for '<S952>/Logical Operator3':
   *
   *
   * Block description for '<S952>/Logical Operator5':
   *
   *
   * Block description for '<S953>/Logical Operator9':
   *
   *
   * Block description for '<S965>/Logical Operator10':
   *
   *
   * Block description for '<S965>/Logical Operator13':
   *
   */
  m_ACC_is_FSMEnbl01_bl = ((!rtb_LogicalOperator2_hk) &&
    (!rtb_DFIn_is_APAStsDsbl_bl) && (!rtb_DFIn_is_NRCDStsDsbl_bl) &&
    ((rtb_DataTypeConversion63 != CSRP_PreCondition_Not_Satisfied) ||
     (!P_ACC_is_CCFM_AccRepPCndEnIN_bl)) && ((rtb_DataTypeConversion63 !=
    CSRP_Lost_Arbitration) || (!P_ACC_is_CCFM_AccRepLArbEnIN_bl)));

  /* BusCreator: '<S55>/Bus Creator' incorporates:
   *  Constant: '<S55>/Constant'
   *  Constant: '<S55>/Constant1'
   *  Constant: '<S55>/Constant2'
   *  Constant: '<S55>/Constant3'
   *  Constant: '<S55>/Constant4'
   *  Constant: '<S55>/Constant5'
   *  Inport: '<Root>/radar_pubcan_251'
   */
  app_B.BusCreator_i1.Extended = 0U;
  app_B.BusCreator_i1.Length = 8U;
  app_B.BusCreator_i1.Remote = 0U;
  app_B.BusCreator_i1.Error = 0U;
  app_B.BusCreator_i1.ID = 251U;
  app_B.BusCreator_i1.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_i1.Data[i_0] = arg_radar_pubcan_251[i_0];
  }

  /* End of BusCreator: '<S55>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack16' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack16' */
    if ((8 == app_B.BusCreator_i1.Length) && (app_B.BusCreator_i1.ID !=
         INVALID_CAN_ID) ) {
      if ((251 == app_B.BusCreator_i1.ID) && (0U == app_B.BusCreator_i1.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 19
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i1.Data[2]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_AccelOvrd = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 40
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_i1.Data[5]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtACCToqReqRespPV_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 2
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i1.Data[0]) & (uint8_T)(0x1CU)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtACCToqReqResp_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 44
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_i1.Data[5]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtADASAlvRC_Safety = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion101' */
  rtb_Add12 = floor(app_B.ECM_PtACCToqReqResp_Safety);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion64' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion101'
   */
  rtb_DataTypeConversion64 = (eCPR_PTCruzResp)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* BusCreator: '<S70>/Bus Creator' incorporates:
   *  Constant: '<S70>/Constant'
   *  Constant: '<S70>/Constant1'
   *  Constant: '<S70>/Constant2'
   *  Constant: '<S70>/Constant3'
   *  Constant: '<S70>/Constant4'
   *  Constant: '<S70>/Constant5'
   *  Inport: '<Root>/radar_pubcan_588'
   */
  app_B.BusCreator_ic.Extended = 0U;
  app_B.BusCreator_ic.Length = 8U;
  app_B.BusCreator_ic.Remote = 0U;
  app_B.BusCreator_ic.Error = 0U;
  app_B.BusCreator_ic.ID = 588U;
  app_B.BusCreator_ic.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_ic.Data[i_0] = arg_radar_pubcan_588[i_0];
  }

  /* End of BusCreator: '<S70>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack39' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack39' */
    if ((8 == app_B.BusCreator_ic.Length) && (app_B.BusCreator_ic.ID !=
         INVALID_CAN_ID) ) {
      if ((588 == app_B.BusCreator_ic.ID) && (0U == app_B.BusCreator_ic.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 6
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_BrkDiscTemSts = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 12
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[1]) & (uint8_T)(0x30U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_BrkPdlDrvrAppdPrsAlvRC = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_BrkPdlDrvrAppdPrsV = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 16
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 75.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_ic.Data[2]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 75.0;
              app_B.SCS_BrkPdlDrvrAppdPrs = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 14
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[1]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_LDrvnWhlRotlDircn = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 1
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x6U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_RDrvnWhlRotlDircn = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 5
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlBrkPrsSts = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_ic.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelDrvnChksm = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 8
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[1]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelDrvnRC = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelLDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 48
           *  length                  = 14
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.03125
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_ic.Data[6]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_ic.Data[5]) & (uint16_T)(0x3FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.03125;
              app_B.SCS_WhlGndVelLDrvn = result;
            }
          }

          /* --------------- START Unpacking signal 11 ------------------
           *  startBit                = 4
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ic.Data[0]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelRDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 12 ------------------
           *  startBit                = 32
           *  length                  = 14
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.03125
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_ic.Data[4]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_ic.Data[3]) & (uint16_T)(0x3FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.03125;
              app_B.SCS_WhlGndVelRDrvn = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion102' */
  rtb_Add12 = floor(app_B.SCS_BrkDiscTemSts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* Logic: '<S954>/Logical Operator4' incorporates:
   *  Constant: '<S954>/FW_P_ACC_is_CCFM_BrkDicTemHIN_bl_1'
   *  Constant: '<S954>/TRUE_BL1'
   *  DataTypeConversion: '<S5>/Data Type Conversion102'
   *  DataTypeConversion: '<S5>/Data Type Conversion65'
   *  RelationalOperator: '<S954>/Relational Operator1'
   */
  rtb_LogicalOperator4_ec = (((eBDT_BrkDiscTm)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12) == BDT_Temperature_Too_High) &&
    P_ACC_is_CCFM_BrkDicTemHIN_bl);

  /* Logic: '<S956>/Logical Operator4' incorporates:
   *  Constant: '<S956>/FW_P_ACC_is_CCFM_EPBAppIN_bl_1'
   */
  rtb_DFIn_is_EPBAppcnStsApp_bl = (app_ConstB.DFIn_is_EPBAppcnStsApp_bl &&
    P_ACC_is_CCFM_EPBAppIN_bl);

  /* BusCreator: '<S57>/Bus Creator' incorporates:
   *  Constant: '<S57>/Constant'
   *  Constant: '<S57>/Constant1'
   *  Constant: '<S57>/Constant2'
   *  Constant: '<S57>/Constant3'
   *  Constant: '<S57>/Constant4'
   *  Constant: '<S57>/Constant5'
   *  Inport: '<Root>/radar_pubcan_560'
   */
  app_B.BusCreator_ir.Extended = 0U;
  app_B.BusCreator_ir.Length = 8U;
  app_B.BusCreator_ir.Remote = 0U;
  app_B.BusCreator_ir.Error = 0U;
  app_B.BusCreator_ir.ID = 560U;
  app_B.BusCreator_ir.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_ir.Data[i_0] = arg_radar_pubcan_560[i_0];
  }

  /* End of BusCreator: '<S57>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack31' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack31' */
    if ((8 == app_B.BusCreator_ir.Length) && (app_B.BusCreator_ir.ID !=
         INVALID_CAN_ID) ) {
      if ((560 == app_B.BusCreator_ir.ID) && (0U == app_B.BusCreator_ir.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 28
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ir.Data[3]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_EPBCCCanclReqd = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 12
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ir.Data[1]) & (uint8_T)(0x30U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_EPBSts = result;
            }
          }
        }
      }
    }
  }

  /* Logic: '<S956>/Logical Operator2' incorporates:
   *  Constant: '<S956>/FW_P_ACC_is_CCFM_EPBCCCanclIN_bl_1'
   *  DataTypeConversion: '<S5>/Data Type Conversion67'
   */
  rtb_DFIn_is_EPBCCCanclDsbl_bl = ((app_B.SCS_EPBCCCanclReqd != 0.0) &&
    P_ACC_is_CCFM_EPBCCCanclIN_bl);

  /* Logic: '<S942>/Logical Operator7' incorporates:
   *  Constant: '<S949>/Constant1'
   *  Constant: '<S949>/Constant6'
   *  Constant: '<S949>/FW_P_ACC_is_CCFM_ToqRepLArbEnIN_bl_1'
   *  Constant: '<S949>/FW_P_ACC_is_CCFM_ToqRepPCndEnIN_bl_1'
   *  Logic: '<S942>/Logical Operator10'
   *  Logic: '<S942>/Logical Operator12'
   *  Logic: '<S942>/Logical Operator6'
   *  Logic: '<S942>/Logical Operator8'
   *  Logic: '<S949>/Logical Operator10'
   *  Logic: '<S949>/Logical Operator11'
   *  Logic: '<S949>/Logical Operator12'
   *  Logic: '<S949>/Logical Operator13'
   *  Logic: '<S954>/Logical Operator9'
   *  Logic: '<S956>/Logical Operator1'
   *  Logic: '<S956>/Logical Operator9'
   *  RelationalOperator: '<S949>/Relational Operator1'
   *  RelationalOperator: '<S949>/Relational Operator4'
   *
   * Block description for '<S949>/Logical Operator10':
   *
   *
   * Block description for '<S949>/Logical Operator13':
   *
   *
   * Block description for '<S954>/Logical Operator9':
   *
   *
   * Block description for '<S956>/Logical Operator1':
   *
   *
   * Block description for '<S956>/Logical Operator9':
   *
   */
  m_ACC_is_FSMEnbl02_bl = (m_ACC_is_FSMEnbl01_bl && ((rtb_DataTypeConversion64
    != CPR_Precondition_Not_Satisfied) || (!P_ACC_is_CCFM_ToqRepPCndEnIN_bl)) &&
    ((rtb_DataTypeConversion64 != CPR_Lost_Arbitration) ||
     (!P_ACC_is_CCFM_ToqRepLArbEnIN_bl)) && (!rtb_LogicalOperator4_ec) &&
    (!rtb_DFIn_is_EPBAppcnStsApp_bl) && (!rtb_DFIn_is_EPBCCCanclDsbl_bl));

  /* BusCreator: '<S36>/Bus Creator' incorporates:
   *  Constant: '<S36>/Constant'
   *  Constant: '<S36>/Constant1'
   *  Constant: '<S36>/Constant2'
   *  Constant: '<S36>/Constant3'
   *  Constant: '<S36>/Constant4'
   *  Constant: '<S36>/Constant5'
   *  Inport: '<Root>/radar_pubcan_677'
   */
  app_B.BusCreator_h.Extended = 0U;
  app_B.BusCreator_h.Length = 8U;
  app_B.BusCreator_h.Remote = 0U;
  app_B.BusCreator_h.Error = 0U;
  app_B.BusCreator_h.ID = 677U;
  app_B.BusCreator_h.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_h.Data[i_0] = arg_radar_pubcan_677[i_0];
  }

  /* End of BusCreator: '<S36>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack44' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack44' */
    if ((8 == app_B.BusCreator_h.Length) && (app_B.BusCreator_h.ID !=
         INVALID_CAN_ID) ) {
      if ((677 == app_B.BusCreator_h.ID) && (0U == app_B.BusCreator_h.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 44
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_h.Data[5]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.TCM_TrCCCanclReq = result;
            }
          }
        }
      }
    }
  }

  /* Logic: '<S957>/Logical Operator1' incorporates:
   *  Constant: '<S957>/FW_P_ACC_is_CCFM_TrCCCanclIN_bl_1'
   *  DataTypeConversion: '<S5>/Data Type Conversion68'
   */
  rtb_LogicalOperator1_d2 = ((app_B.TCM_TrCCCanclReq != 0.0) &&
    P_ACC_is_CCFM_TrCCCanclIN_bl);

  /* Logic: '<S951>/Logical Operator6' incorporates:
   *  Constant: '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_2'
   *  Logic: '<S951>/Logical Operator8'
   */
  rtb_LogicalOperator2_kx = (app_ConstB.DFIn_is_ACCAccelMinus_bl ||
    P_ACC_is_CCFM_AEBVActvExitIN_bl);

  /* Logic: '<S951>/Logical Operator1' incorporates:
   *  Constant: '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_1'
   *  Logic: '<S951>/Logical Operator4'
   *  Logic: '<S951>/Logical Operator6'
   */
  rtb_DFIn_is_AEBStsDsbl_bl = (app_ConstB.DFIn_is_AEBStsDsbl_bl &&
    rtb_LogicalOperator2_kx && P_ACC_is_CCFM_AEBVActvIN_bl);

  /* Logic: '<S951>/Logical Operator3' incorporates:
   *  Constant: '<S951>/FW_P_ACC_is_CCFM_AEBPActvIN_bl_1'
   *  Logic: '<S951>/Logical Operator5'
   */
  rtb_DFIn_is_AEBPStsDsbl_bl = (app_ConstB.DFIn_is_AEBPedStrnStsDsbl_bl &&
    rtb_LogicalOperator2_kx && P_ACC_is_CCFM_AEBPActvIN_bl);

  /* Logic: '<S943>/Logical Operator9' incorporates:
   *  Constant: '<S943>/FW_P_ACC_is_CCFM_VSEMdOffIN_bl_1'
   */
  rtb_LogicalOperator9_kf = (app_ConstB.RelationalOperator10 &&
    P_ACC_is_CCFM_VSEMdOffIN_bl);

  /* BusCreator: '<S34>/Bus Creator' incorporates:
   *  Constant: '<S34>/Constant'
   *  Constant: '<S34>/Constant1'
   *  Constant: '<S34>/Constant2'
   *  Constant: '<S34>/Constant3'
   *  Constant: '<S34>/Constant4'
   *  Constant: '<S34>/Constant5'
   *  Inport: '<Root>/radar_pubcan_590'
   */
  app_B.BusCreator_g.Extended = 0U;
  app_B.BusCreator_g.Length = 8U;
  app_B.BusCreator_g.Remote = 0U;
  app_B.BusCreator_g.Error = 0U;
  app_B.BusCreator_g.ID = 590U;
  app_B.BusCreator_g.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_g.Data[i_0] = arg_radar_pubcan_590[i_0];
  }

  /* End of BusCreator: '<S34>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack40' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack40' */
    if ((8 == app_B.BusCreator_g.Length) && (app_B.BusCreator_g.ID !=
         INVALID_CAN_ID) ) {
      if ((590 == app_B.BusCreator_g.ID) && (0U == app_B.BusCreator_g.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 16
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[2]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_LNonDrvnWhlRotlDircn = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 8
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[1]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_RNonDrvnWhlRotlDircn = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 18
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[2]) & (uint8_T)(0x1CU)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_TCSOpngMd = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 21
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[2]) & (uint8_T)(0xE0U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_TCSOpngSts = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 10
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[1]) & (uint8_T)(0x1CU)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSEMd = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 13
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[1]) & (uint8_T)(0xE0U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSESts = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 30
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[3]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelLNonDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 48
           *  length                  = 14
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.03125
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_g.Data[6]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_g.Data[5]) & (uint16_T)(0x3FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.03125;
              app_B.SCS_WhlGndVelLNonDrvn = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_g.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelNonDrvnChksm = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 4
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[0]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelNonDrvnRC = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 31
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_g.Data[3]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_WhlGndVelRNonDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 11 ------------------
           *  startBit                = 32
           *  length                  = 14
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.03125
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_g.Data[4]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_g.Data[3]) & (uint16_T)(0x3FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.03125;
              app_B.SCS_WhlGndVelRNonDrvn = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion73' */
  rtb_Add12 = floor(app_B.SCS_TCSOpngMd);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* Logic: '<S943>/Logical Operator3' incorporates:
   *  Constant: '<S943>/FW_P_ACC_is_CCFM_TCSOpMdOffIN_bl_1'
   *  Constant: '<S943>/TCSOpngStsActive3'
   *  DataTypeConversion: '<S5>/Data Type Conversion1'
   *  DataTypeConversion: '<S5>/Data Type Conversion73'
   *  RelationalOperator: '<S943>/Relational Operator7'
   */
  rtb_LogicalOperator3_ox = (((eTCSM_TCSMode)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12) == TCSM_Off) && P_ACC_is_CCFM_TCSOpMdOffIN_bl);

  /* Logic: '<S942>/Logical Operator17' incorporates:
   *  Logic: '<S942>/Logical Operator14'
   *  Logic: '<S942>/Logical Operator15'
   *  Logic: '<S942>/Logical Operator16'
   *  Logic: '<S942>/Logical Operator9'
   *  Logic: '<S943>/Logical Operator1'
   *  Logic: '<S943>/Logical Operator2'
   *  Logic: '<S951>/Logical Operator2'
   *  Logic: '<S951>/Logical Operator9'
   *  Logic: '<S957>/Logical Operator9'
   *
   * Block description for '<S943>/Logical Operator1':
   *
   *
   * Block description for '<S943>/Logical Operator2':
   *
   *
   * Block description for '<S951>/Logical Operator2':
   *
   *
   * Block description for '<S951>/Logical Operator9':
   *
   *
   * Block description for '<S957>/Logical Operator9':
   *
   */
  m_ACC_is_FSMEnbl03_bl = (m_ACC_is_FSMEnbl02_bl && (!rtb_LogicalOperator1_d2) &&
    (!rtb_DFIn_is_AEBStsDsbl_bl) && (!rtb_DFIn_is_AEBPStsDsbl_bl) &&
    (!rtb_LogicalOperator9_kf) && (!rtb_LogicalOperator3_ox));

  /* DataTypeConversion: '<S5>/Data Type Conversion93' */
  rtb_Add12 = floor(app_B.SCS_VehSdslSts_Safety);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion45' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion93'
   */
  rtb_DataTypeConversion45 = (eVSL_StdStlSts)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* RelationalOperator: '<S934>/Relational Operator' incorporates:
   *  Constant: '<S990>/Constant'
   */
  m_ACC_is_VehSdslSts_bl = (rtb_DataTypeConversion45 == VSL_Standstill);

  /* Chart: '<S945>/DFIn_TmCntrSF_TRUE1' incorporates:
   *  Constant: '<S945>/C_system_step_2'
   *  Constant: '<S945>/P_ACC_cnt_OAFReActvThrs_u2'
   *  DataTypeConversion: '<S5>/Data Type Conversion2'
   *  Logic: '<S945>/Logical Operator15'
   *  Product: '<S945>/Divide2'
   *  RelationalOperator: '<S945>/Relational Operator8'
   *
   * Block description for '<S945>/DFIn_TmCntrSF_TRUE1':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   *
   * Block description for '<S945>/C_system_step_2':
   *  /+ C_system_step = 0.01s.+/
   *
   * Block description for '<S945>/P_ACC_cnt_OAFReActvThrs_u2':
   *  CALI PARA.
   *  ACC Torque Request Responce no Request Hysteresis time threshold,
   *  when DA_IN_indx_ACCAccReqResp_u8 no Request time length is larger than this para,
   *  the system will not support ACC and TJA.
   */
  app_DFIn_TmCntrSF_TRUE1((!(app_B.SDM_DrvrSbltAtc != 0.0)) &&
    m_ACC_is_VehSdslSts_bl, P_DFIn_t_DrvrSbltAtcHys_sg / 0.02F, &app_B.OutPut_f,
    &app_DW.sf_DFIn_TmCntrSF_TRUE1);

  /* RelationalOperator: '<S945>/Relational Operator6' */
  rtb_LogicalOperator2_kx = !m_ACC_is_VehSdslSts_bl;

  /* Logic: '<S945>/Logical Operator1' incorporates:
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_SafyBltStsIN_bl_1'
   *  DataTypeConversion: '<S5>/Data Type Conversion2'
   *  Logic: '<S945>/Logical Operator13'
   *  Logic: '<S945>/Logical Operator16'
   */
  rtb_SeatBeltOn_o = ((((!(app_B.SDM_DrvrSbltAtc != 0.0)) &&
                        rtb_LogicalOperator2_kx) || app_B.OutPut_f) &&
                      P_ACC_is_CCFM_SafyBltStsIN_bl);

  /* Logic: '<S945>/Logical Operator5' */
  m_ACC_is_SafyBltFstn_bl = !rtb_SeatBeltOn_o;

  /* BusCreator: '<S69>/Bus Creator' incorporates:
   *  Constant: '<S69>/Constant'
   *  Constant: '<S69>/Constant1'
   *  Constant: '<S69>/Constant2'
   *  Constant: '<S69>/Constant3'
   *  Constant: '<S69>/Constant4'
   *  Constant: '<S69>/Constant5'
   *  Inport: '<Root>/radar_pubcan_1130'
   */
  app_B.BusCreator_hd.Extended = 0U;
  app_B.BusCreator_hd.Length = 8U;
  app_B.BusCreator_hd.Remote = 0U;
  app_B.BusCreator_hd.Error = 0U;
  app_B.BusCreator_hd.ID = 1130U;
  app_B.BusCreator_hd.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_hd.Data[i_0] = arg_radar_pubcan_1130[i_0];
  }

  /* End of BusCreator: '<S69>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack4' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack4' */
    if ((8 == app_B.BusCreator_hd.Length) && (app_B.BusCreator_hd.ID !=
         INVALID_CAN_ID) ) {
      if ((1130 == app_B.BusCreator_hd.ID) && (0U ==
           app_B.BusCreator_hd.Extended) ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 44
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[5]) & (uint8_T)(0x30U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_BntOpenSts = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 63
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[7]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_DipdBeamLghtOn = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 59
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[7]) & (uint8_T)(0x18U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_DircnIndLampSwSts = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 46
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[5]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_DrvrDoorOpenSts = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 62
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[7]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_FrtFogLghtOn = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 42
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[5]) & (uint8_T)(0xCU)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_FrtPsgDoorOpenSts = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 37
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[4]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_LDircnIO = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 32
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[4]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_LdspcOpenSts = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 36
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[4]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_MainBeamLghtOn = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 38
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[4]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_RDircnIO = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 40
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[5]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_RRDoorOpenSts = result;
            }
          }

          /* --------------- START Unpacking signal 11 ------------------
           *  startBit                = 39
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[4]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_RrFogLghtOn = result;
            }
          }

          /* --------------- START Unpacking signal 12 ------------------
           *  startBit                = 51
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hd.Data[6]) & (uint8_T)(0x18U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_VehSideLghtSts = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion74' */
  rtb_Add12 = floor(app_B.BCM_DrvrDoorOpenSts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion3' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion74'
   */
  rtb_DataTypeConversion6_m = (eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* Chart: '<S945>/DFIn_TmCntrSF_TRUE2' incorporates:
   *  Constant: '<S945>/C_system_step_3'
   *  Constant: '<S945>/Constant6'
   *  Constant: '<S945>/P_ACC_cnt_OAFReActvThrs_u1'
   *  Logic: '<S945>/Logical Operator17'
   *  Product: '<S945>/Divide1'
   *  RelationalOperator: '<S945>/Relational Operator11'
   *  RelationalOperator: '<S945>/Relational Operator12'
   *
   * Block description for '<S945>/DFIn_TmCntrSF_TRUE2':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   *
   * Block description for '<S945>/C_system_step_3':
   *  /+ C_system_step = 0.01s.+/
   *
   * Block description for '<S945>/P_ACC_cnt_OAFReActvThrs_u1':
   *  CALI PARA.
   *  ACC Torque Request Responce no Request Hysteresis time threshold,
   *  when DA_IN_indx_ACCAccReqResp_u8 no Request time length is larger than this para,
   *  the system will not support ACC and TJA.
   */
  app_DFIn_TmCntrSF_TRUE1((rtb_DataTypeConversion6_m != DOS_Closed) &&
    m_ACC_is_VehSdslSts_bl, P_DFIn_t_DrvrSbltAtcHys_sg / 0.02F, &app_B.OutPut_n,
    &app_DW.sf_DFIn_TmCntrSF_TRUE2);

  /* Logic: '<S945>/Logical Operator9' incorporates:
   *  Constant: '<S945>/Constant5'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_DrvDoorIN_bl_1'
   *  Logic: '<S945>/Logical Operator14'
   *  Logic: '<S945>/Logical Operator18'
   *  RelationalOperator: '<S945>/Relational Operator9'
   */
  rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = ((((rtb_DataTypeConversion6_m != DOS_Closed)
    && rtb_LogicalOperator2_kx) || app_B.OutPut_n) && P_ACC_is_CCFM_DrvDoorIN_bl);

  /* Switch: '<S945>/Switch' incorporates:
   *  Constant: '<S945>/Constant3'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_FrDoorIN_bl_1'
   *  Constant: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u6'
   *  DataTypeConversion: '<S5>/Data Type Conversion4'
   *  DataTypeConversion: '<S5>/Data Type Conversion75'
   *  Logic: '<S945>/Logical Operator21'
   *  Logic: '<S945>/Logical Operator4'
   *  RelationalOperator: '<S945>/Relational Operator3'
   */
  if (P_DFIn_is_CCFM_FrDoorStdstlExit_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion75' */
    rtb_Add12 = floor(app_B.BCM_FrtPsgDoorOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_FrDoorIN_bl);
  } else {
    /* DataTypeConversion: '<S5>/Data Type Conversion75' */
    rtb_Add12 = floor(app_B.BCM_FrtPsgDoorOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_FrDoorIN_bl &&
      rtb_LogicalOperator2_kx);
  }

  /* End of Switch: '<S945>/Switch' */

  /* Switch: '<S945>/Switch1' incorporates:
   *  Constant: '<S945>/Constant1'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_RLDoorIN_bl_1'
   *  Constant: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u8'
   *  DataTypeConversion: '<S5>/Data Type Conversion5'
   *  DataTypeConversion: '<S5>/Data Type Conversion76'
   *  Logic: '<S945>/Logical Operator10'
   *  Logic: '<S945>/Logical Operator22'
   *  RelationalOperator: '<S945>/Relational Operator1'
   */
  if (P_DFIn_is_CCFM_RLDoorStdstlExit_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion76' */
    rtb_Add12 = floor(app_B.BCM_RRDoorOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_RLDoorIN_bl);
  } else {
    /* DataTypeConversion: '<S5>/Data Type Conversion76' */
    rtb_Add12 = floor(app_B.BCM_RRDoorOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_RLDoorIN_bl &&
      rtb_LogicalOperator2_kx);
  }

  /* End of Switch: '<S945>/Switch1' */

  /* BusCreator: '<S52>/Bus Creator' incorporates:
   *  Constant: '<S52>/Constant'
   *  Constant: '<S52>/Constant1'
   *  Constant: '<S52>/Constant2'
   *  Constant: '<S52>/Constant3'
   *  Constant: '<S52>/Constant4'
   *  Constant: '<S52>/Constant5'
   *  Inport: '<Root>/radar_pubcan_540'
   */
  app_B.BusCreator_m.Extended = 0U;
  app_B.BusCreator_m.Length = 8U;
  app_B.BusCreator_m.Remote = 0U;
  app_B.BusCreator_m.Error = 0U;
  app_B.BusCreator_m.ID = 540U;
  app_B.BusCreator_m.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_m.Data[i_0] = arg_radar_pubcan_540[i_0];
  }

  /* End of BusCreator: '<S52>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack5' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack5' */
    if ((8 == app_B.BusCreator_m.Length) && (app_B.BusCreator_m.ID !=
         INVALID_CAN_ID) ) {
      if ((540 == app_B.BusCreator_m.ID) && (0U == app_B.BusCreator_m.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 46
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_m.Data[5]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_FrtWiperSwSts = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 21
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_m.Data[2]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_LDircnIndLghtF = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 17
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_m.Data[2]) & (uint8_T)(0x2U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_RDircnIndLghtF = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 62
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_m.Data[7]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.BCM_RrDoorsOpenSts = result;
            }
          }
        }
      }
    }
  }

  /* Switch: '<S945>/Switch2' incorporates:
   *  Constant: '<S945>/Constant2'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_RRDoorIN_bl_1'
   *  Constant: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u10'
   *  DataTypeConversion: '<S5>/Data Type Conversion6'
   *  DataTypeConversion: '<S5>/Data Type Conversion77'
   *  Logic: '<S945>/Logical Operator11'
   *  Logic: '<S945>/Logical Operator25'
   *  RelationalOperator: '<S945>/Relational Operator2'
   */
  if (P_DFIn_is_CCFM_RRDoorStdstlExit_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion77' */
    rtb_Add12 = floor(app_B.BCM_RrDoorsOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_RRDoorIN_bl);
  } else {
    /* DataTypeConversion: '<S5>/Data Type Conversion77' */
    rtb_Add12 = floor(app_B.BCM_RrDoorsOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p = (((eDOS_DoorOpenSts)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != DOS_Closed) && P_ACC_is_CCFM_RRDoorIN_bl &&
      rtb_LogicalOperator2_kx);
  }

  /* End of Switch: '<S945>/Switch2' */

  /* Logic: '<S942>/Logical Operator22' incorporates:
   *  Logic: '<S942>/Logical Operator11'
   *  Logic: '<S942>/Logical Operator13'
   *  Logic: '<S942>/Logical Operator18'
   *  Logic: '<S942>/Logical Operator19'
   *  Logic: '<S945>/Logical Operator2'
   *  Logic: '<S945>/Logical Operator3'
   *  Logic: '<S945>/Logical Operator7'
   *  Logic: '<S945>/Logical Operator8'
   */
  m_ACC_is_FSMEnbl04_bl = (m_ACC_is_FSMEnbl03_bl && m_ACC_is_SafyBltFstn_bl && (
    !rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) && (!rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) &&
    (!rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) && (!rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p));

  /* Switch: '<S945>/Switch3' incorporates:
   *  Constant: '<S945>/Constant4'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_BntStsIN_bl_1'
   *  Constant: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u11'
   *  DataTypeConversion: '<S5>/Data Type Conversion7'
   *  DataTypeConversion: '<S5>/Data Type Conversion78'
   *  Logic: '<S945>/Logical Operator12'
   *  Logic: '<S945>/Logical Operator27'
   *  RelationalOperator: '<S945>/Relational Operator4'
   */
  if (P_DFIn_is_CCFM_BntStsStdstlExit_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion78' */
    rtb_Add12 = floor(app_B.BCM_BntOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (((eBOS_BntOpen)(uint8_T)(rtb_Add12 < 0.0
      ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != BOS_Bonnet_Closed) &&
      P_ACC_is_CCFM_BntStsIN_bl);
  } else {
    /* DataTypeConversion: '<S5>/Data Type Conversion78' */
    rtb_Add12 = floor(app_B.BCM_BntOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (((eBOS_BntOpen)(uint8_T)(rtb_Add12 < 0.0
      ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != BOS_Bonnet_Closed) &&
      P_ACC_is_CCFM_BntStsIN_bl && rtb_LogicalOperator2_kx);
  }

  /* End of Switch: '<S945>/Switch3' */

  /* Switch: '<S945>/Switch4' incorporates:
   *  Constant: '<S945>/Constant7'
   *  Constant: '<S945>/FW_P_ACC_is_CCFM_BntStsIN_bl_2'
   *  Constant: '<S945>/P_VDC_ACC_v_MinCrsSpdThrs_u13'
   *  DataTypeConversion: '<S5>/Data Type Conversion80'
   *  DataTypeConversion: '<S5>/Data Type Conversion9'
   *  Logic: '<S945>/Logical Operator19'
   *  Logic: '<S945>/Logical Operator29'
   *  RelationalOperator: '<S945>/Relational Operator13'
   */
  if (P_DFIn_is_CCFM_LdSpcStsStdstlExit_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion80' */
    rtb_Add12 = floor(app_B.BCM_LdspcOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_BntStsDsbl_bl_p = (((eLOS_LdSpcOpen)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != LOS_Load_Space_Closed) &&
      P_ACC_is_CCFM_LdSpcStsIN_bl);
  } else {
    /* DataTypeConversion: '<S5>/Data Type Conversion80' */
    rtb_Add12 = floor(app_B.BCM_LdspcOpenSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_DFIn_is_CCFM_BntStsDsbl_bl_p = (((eLOS_LdSpcOpen)(uint8_T)(rtb_Add12 <
      0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
      (int32_T)(uint8_T)rtb_Add12) != LOS_Load_Space_Closed) &&
      P_ACC_is_CCFM_LdSpcStsIN_bl && rtb_LogicalOperator2_kx);
  }

  /* End of Switch: '<S945>/Switch4' */

  /* BusCreator: '<S26>/Bus Creator' incorporates:
   *  Constant: '<S26>/Constant'
   *  Constant: '<S26>/Constant1'
   *  Constant: '<S26>/Constant2'
   *  Constant: '<S26>/Constant3'
   *  Constant: '<S26>/Constant4'
   *  Constant: '<S26>/Constant5'
   *  Inport: '<Root>/radar_pubcan_404'
   */
  app_B.BusCreator_hn.Extended = 0U;
  app_B.BusCreator_hn.Length = 8U;
  app_B.BusCreator_hn.Remote = 0U;
  app_B.BusCreator_hn.Error = 0U;
  app_B.BusCreator_hn.ID = 404U;
  app_B.BusCreator_hn.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_hn.Data[i_0] = arg_radar_pubcan_404[i_0];
  }

  /* End of BusCreator: '<S26>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack12' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack12' */
    if ((8 == app_B.BusCreator_hn.Length) && (app_B.BusCreator_hn.ID !=
         INVALID_CAN_ID) ) {
      if ((404 == app_B.BusCreator_hn.ID) && (0U == app_B.BusCreator_hn.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 8
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[1]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_AutocTrCmddGear = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 55
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[6]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_ClPosV = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.39216
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_hn.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.39216;
              app_B.ECM_ClPos = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 38
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[4]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_ClStSwAV = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 37
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[4]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_ClStSwA = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 4
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[0]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrEstdGearV = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 0
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[0]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrEstdGear = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 28
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[3]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrShftLvrPosV = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 24
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[3]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrShftLvrPos = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 42
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[5]) & (uint8_T)(0x1CU)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrShftPtrnASts = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 40
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_hn.Data[5]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_TrTapUpTapDwnMdSts = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion79' */
  rtb_Add12 = floor(app_B.ECM_TrShftLvrPos);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion8' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion79'
   */
  rtb_DataTypeConversion8 = (eTLP_ShftLvrPos)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* Logic: '<S944>/Logical Operator1' incorporates:
   *  Constant: '<S944>/Constant1'
   *  Constant: '<S944>/FW_P_ACC_is_CCFM_ShftPosPkIN_bl_1'
   *  RelationalOperator: '<S944>/Relational Operator1'
   */
  rtb_LogicalOperator1_pr = ((rtb_DataTypeConversion8 == TLP_Park_Range) &&
    P_ACC_is_CCFM_ShftPosPkIN_bl);

  /* Logic: '<S944>/Logical Operator3' incorporates:
   *  Constant: '<S944>/Constant2'
   *  Constant: '<S944>/FW_P_ACC_is_CCFM_ShftPosReIN_bl_1'
   *  RelationalOperator: '<S944>/Relational Operator2'
   */
  rtb_LogicalOperator3_d = ((rtb_DataTypeConversion8 == TLP_Reverse_Range) &&
    P_ACC_is_CCFM_ShftPosReIN_bl);

  /* Logic: '<S944>/Logical Operator4' incorporates:
   *  Constant: '<S944>/Constant3'
   *  Constant: '<S944>/FW_P_ACC_is_CCFM_ShftPosNeIN_bl_1'
   *  RelationalOperator: '<S944>/Relational Operator3'
   */
  rtb_LogicalOperator4_jt = ((rtb_DataTypeConversion8 == TLP_Neutral_Range) &&
    P_ACC_is_CCFM_ShftPosNeIN_bl);

  /* Logic: '<S942>/Logical Operator26' incorporates:
   *  Logic: '<S942>/Logical Operator24'
   *  Logic: '<S942>/Logical Operator25'
   *  Logic: '<S942>/Logical Operator30'
   *  Logic: '<S942>/Logical Operator31'
   *  Logic: '<S944>/Logical Operator2'
   *  Logic: '<S944>/Logical Operator6'
   *  Logic: '<S944>/Logical Operator7'
   *  Logic: '<S945>/Logical Operator20'
   *  Logic: '<S945>/Logical Operator6'
   */
  m_ACC_is_FSMEnbl05_bl = (m_ACC_is_FSMEnbl04_bl &&
    (!rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) && (!rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) &&
    (!rtb_LogicalOperator1_pr) && (!rtb_LogicalOperator3_d) &&
    (!rtb_LogicalOperator4_jt));

  /* Logic: '<S944>/Logical Operator5' incorporates:
   *  Constant: '<S944>/Constant10'
   *  Constant: '<S944>/FW_P_ACC_is_CCFM_ShftPosBtIN_bl_1'
   *  RelationalOperator: '<S944>/Relational Operator4'
   */
  rtb_LogicalOperator5_m = ((rtb_DataTypeConversion8 == TLP_Between_Ranges) &&
    P_ACC_is_CCFM_ShftPosBtIN_bl);

  /* Logic: '<S944>/Logical Operator10' incorporates:
   *  Constant: '<S944>/Constant4'
   *  Constant: '<S944>/FW_P_ACC_is_CCFM_ShftPosUkIN_bl_1'
   *  RelationalOperator: '<S944>/Relational Operator5'
   */
  rtb_LogicalOperator10_mo = ((rtb_DataTypeConversion8 ==
    TLP_Lever_Position_Unknown) && P_ACC_is_CCFM_ShftPosUkIN_bl);

  /* DataTypeConversion: '<S5>/Data Type Conversion89' */
  rtb_Add12 = floor(app_B.SCS_RDrvnWhlRotlDircn);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion91' */
  tmp_4 = floor(app_B.SCS_LDrvnWhlRotlDircn);
  if (rtIsNaN(tmp_4) || rtIsInf(tmp_4)) {
    tmp_4 = 0.0;
  } else {
    tmp_4 = fmod(tmp_4, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion90' */
  tmp_5 = floor(app_B.SCS_RNonDrvnWhlRotlDircn);
  if (rtIsNaN(tmp_5) || rtIsInf(tmp_5)) {
    tmp_5 = 0.0;
  } else {
    tmp_5 = fmod(tmp_5, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion92' */
  tmp_6 = floor(app_B.SCS_LNonDrvnWhlRotlDircn);
  if (rtIsNaN(tmp_6) || rtIsInf(tmp_6)) {
    tmp_6 = 0.0;
  } else {
    tmp_6 = fmod(tmp_6, 256.0);
  }

  /* Logic: '<S1037>/Logical Operator2' incorporates:
   *  Constant: '<S1037>/Constant1'
   *  Constant: '<S1037>/Constant10'
   *  Constant: '<S1037>/Constant2'
   *  Constant: '<S1037>/Constant3'
   *  DataTypeConversion: '<S5>/Data Type Conversion41'
   *  DataTypeConversion: '<S5>/Data Type Conversion42'
   *  DataTypeConversion: '<S5>/Data Type Conversion43'
   *  DataTypeConversion: '<S5>/Data Type Conversion44'
   *  DataTypeConversion: '<S5>/Data Type Conversion89'
   *  DataTypeConversion: '<S5>/Data Type Conversion90'
   *  DataTypeConversion: '<S5>/Data Type Conversion91'
   *  DataTypeConversion: '<S5>/Data Type Conversion92'
   *  Logic: '<S1037>/Logical Operator'
   *  Logic: '<S1037>/Logical Operator1'
   *  RelationalOperator: '<S1037>/Relational Operator1'
   *  RelationalOperator: '<S1037>/Relational Operator2'
   *  RelationalOperator: '<S1037>/Relational Operator3'
   *  RelationalOperator: '<S1037>/Relational Operator5'
   */
  rtb_LogicalOperator2_kx = (((eWRD_WhlRotDirc)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12) == WRD_Backward) && ((eWRD_WhlRotDirc)(uint8_T)(tmp_4 <
    0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-tmp_4 :
    (int32_T)(uint8_T)tmp_4) == WRD_Backward) && ((eWRD_WhlRotDirc)(uint8_T)
    (tmp_5 < 0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-tmp_5 :
     (int32_T)(uint8_T)tmp_5) == WRD_Backward) && ((eWRD_WhlRotDirc)(uint8_T)
    (tmp_6 < 0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-tmp_6 :
     (int32_T)(uint8_T)tmp_6) == WRD_Backward));

  /* Logic: '<S948>/Logical Operator9' incorporates:
   *  Abs: '<S1037>/Abs'
   *  Constant: '<S1037>/Constant4'
   *  Constant: '<S948>/FW_P_ACC_is_CCFM_RolBckIN_bl_1'
   *  Logic: '<S1037>/Logical Operator3'
   *  RelationalOperator: '<S1037>/Relational Operator4'
   *  UnitDelay: '<S1037>/Unit Delay'
   */
  rtb_LogicalOperator9_a = (rtb_LogicalOperator2_kx && (fabsf
    (app_DW.UnitDelay_DSTATE_c) >= P_DFIn_v_RolBckVehSpdThrs_sg) &&
    P_ACC_is_CCFM_RolBckIN_bl);

  /* BusCreator: '<S41>/Bus Creator' incorporates:
   *  Constant: '<S41>/Constant'
   *  Constant: '<S41>/Constant1'
   *  Constant: '<S41>/Constant2'
   *  Constant: '<S41>/Constant3'
   *  Constant: '<S41>/Constant4'
   *  Constant: '<S41>/Constant5'
   *  Inport: '<Root>/radar_pubcan_201'
   */
  app_B.BusCreator_ek.Extended = 0U;
  app_B.BusCreator_ek.Length = 8U;
  app_B.BusCreator_ek.Remote = 0U;
  app_B.BusCreator_ek.Error = 0U;
  app_B.BusCreator_ek.ID = 201U;
  app_B.BusCreator_ek.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_ek.Data[i_0] = arg_radar_pubcan_201[i_0];
  }

  /* End of BusCreator: '<S41>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack8' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack8' */
    if ((8 == app_B.BusCreator_ek.Length) && (app_B.BusCreator_ek.ID !=
         INVALID_CAN_ID) ) {
      if ((201 == app_B.BusCreator_ek.ID) && (0U == app_B.BusCreator_ek.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 31
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[3]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_AccelActuPosV = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 32
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.39216
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_ek.Data[4]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.39216;
              app_B.ECM_AccelActuPos = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 30
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[3]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_CCA = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 29
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[3]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_CCEnbd = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_ek.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_FrP00_Chksm = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 48
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[6]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_FrP00_RC = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 53
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[6]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_En12VoltStrMotCmddOn = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 52
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[6]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnCtrlrRunCrkTrmlSts = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnRunA = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 28
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[3]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnSpdReqToTr = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 0
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnSpdSts = result;
            }
          }

          /* --------------- START Unpacking signal 11 ------------------
           *  startBit                = 16
           *  length                  = 16
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.25
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_ek.Data[2]);
                  tempValue = tempValue | (uint16_T)((uint16_T)
                    (app_B.BusCreator_ek.Data[1]) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.25;
              app_B.ECM_EnSpd = result;
            }
          }

          /* --------------- START Unpacking signal 12 ------------------
           *  startBit                = 41
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[5]) & (uint8_T)(0x2U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtBrkPdlDscrtInptStsV = result;
            }
          }

          /* --------------- START Unpacking signal 13 ------------------
           *  startBit                = 40
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[5]) & (uint8_T)(0x1U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtBrkPdlDscrtInptSts = result;
            }
          }

          /* --------------- START Unpacking signal 14 ------------------
           *  startBit                = 5
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtCrkAbotd = result;
            }
          }

          /* --------------- START Unpacking signal 15 ------------------
           *  startBit                = 4
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_PtRunAbotd = result;
            }
          }

          /* --------------- START Unpacking signal 16 ------------------
           *  startBit                = 55
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[6]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_RVSEnRunning = result;
            }
          }

          /* --------------- START Unpacking signal 17 ------------------
           *  startBit                = 2
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_RVSPtCrkAbotd = result;
            }
          }

          /* --------------- START Unpacking signal 18 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ek.Data[0]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_RVSPtRunAbotd = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S1031>/Data Type Conversion6' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion39'
   */
  rtb_Divide1 = fabsf((real32_T)app_B.ECM_EnSpd);
  if (rtb_Divide1 < 8.388608E+6F) {
    if (rtb_Divide1 >= 0.5F) {
      DFIn_a_EstdVSELongtAccel_sg = floorf((real32_T)app_B.ECM_EnSpd + 0.5F);
    } else {
      DFIn_a_EstdVSELongtAccel_sg = (real32_T)app_B.ECM_EnSpd * 0.0F;
    }
  } else {
    DFIn_a_EstdVSELongtAccel_sg = (real32_T)app_B.ECM_EnSpd;
  }

  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg) || rtIsInfF
      (DFIn_a_EstdVSELongtAccel_sg)) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
  }

  rtb_Divide_cd = (uint16_T)(DFIn_a_EstdVSELongtAccel_sg < 0.0F ? (int32_T)
    (uint16_T)(int32_T)-(int32_T)(int16_T)(uint16_T)-DFIn_a_EstdVSELongtAccel_sg
    : (int32_T)(uint16_T)DFIn_a_EstdVSELongtAccel_sg);

  /* End of DataTypeConversion: '<S1031>/Data Type Conversion6' */

  /* BusCreator: '<S64>/Bus Creator' incorporates:
   *  Constant: '<S64>/Constant'
   *  Constant: '<S64>/Constant1'
   *  Constant: '<S64>/Constant2'
   *  Constant: '<S64>/Constant3'
   *  Constant: '<S64>/Constant4'
   *  Constant: '<S64>/Constant5'
   *  Inport: '<Root>/radar_pubcan_479'
   */
  app_B.BusCreator_c.Extended = 0U;
  app_B.BusCreator_c.Length = 2U;
  app_B.BusCreator_c.Remote = 0U;
  app_B.BusCreator_c.Error = 0U;
  app_B.BusCreator_c.ID = 479U;
  app_B.BusCreator_c.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_c.Data[i_0] = arg_radar_pubcan_479[i_0];
  }

  /* End of BusCreator: '<S64>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack13' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack13' */
    if ((2 == app_B.BusCreator_c.Length) && (app_B.BusCreator_c.ID !=
         INVALID_CAN_ID) ) {
      if ((479 == app_B.BusCreator_c.ID) && (0U == app_B.BusCreator_c.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 0
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_c.Data[0]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnASSSta = result;
            }
          }
        }
      }
    }
  }

  /* Switch: '<S1031>/Switch' incorporates:
   *  Constant: '<S1031>/Constant1'
   *  Constant: '<S1031>/Constant3'
   *  Constant: '<S1031>/Constant4'
   *  DataTypeConversion: '<S5>/Data Type Conversion38'
   *  DataTypeConversion: '<S5>/Data Type Conversion40'
   *  DataTypeConversion: '<S5>/Data Type Conversion88'
   *  Logic: '<S1031>/Logical Operator2'
   *  Logic: '<S1031>/Logical Operator8'
   *  RelationalOperator: '<S1031>/Relational Operator6'
   */
  if (P_ADS_is_EnASSStaConfig_bl) {
    /* DataTypeConversion: '<S5>/Data Type Conversion88' */
    rtb_Add12 = floor(app_B.ECM_EnASSSta);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    rtb_LogicalOperator2_e5 = ((!(app_B.ECM_EnRunA != 0.0)) && ((eESS_EnASSSta)
      (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)
                (uint8_T)-rtb_Add12 : (int32_T)(uint8_T)rtb_Add12) !=
      ESS_Engine_Running));
  } else {
    rtb_LogicalOperator2_e5 = false;
  }

  /* End of Switch: '<S1031>/Switch' */

  /* Logic: '<S948>/Logical Operator2' incorporates:
   *  Constant: '<S1031>/Constant2'
   *  Constant: '<S1031>/Constant5'
   *  Constant: '<S1031>/P_DFIn_perc_AccelPosHysDelt_sg2'
   *  Constant: '<S948>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_1'
   *  DataTypeConversion: '<S5>/Data Type Conversion40'
   *  Logic: '<S1031>/Logical Operator1'
   *  Logic: '<S1031>/Logical Operator4'
   *  Logic: '<S1031>/Logical Operator7'
   *  Logic: '<S1031>/Logical Operator9'
   *  RelationalOperator: '<S1031>/Relational Operator1'
   *  RelationalOperator: '<S1031>/Relational Operator2'
   *
   * Block description for '<S1031>/Constant2':
   *  /+ Tunable Parameter.
   *      It shall be lower than engine idle speed for every project. +/
   *
   * Block description for '<S1031>/Constant5':
   *  /+ Tunable Parameter.
   *      It shall be lower than engine idle speed for every project. +/
   */
  rtb_LogicalOperator2_e5 = ((((!P_ADS_is_EngTypIsMotorConfig_bl) &&
    (((rtb_Divide_cd < P_DFIn_n_EngRunActvSpd_u16) || (!(app_B.ECM_EnRunA != 0.0)))
     && (!rtb_LogicalOperator2_e5))) || (rtb_Divide_cd >
    P_DFIn_n_EngRunActvMaxSpd_u16)) && P_ACC_is_CCFM_EnNoActvIN_bl);

  /* Logic: '<S947>/Logical Operator2' incorporates:
   *  Constant: '<S947>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_1'
   */
  rtb_LogicalOperator2_hs = (app_ConstB.RelationalOperator5_k &&
    P_ACC_is_CCFM_NonEmsnRltdIN_bl);

  /* Logic: '<S942>/Logical Operator32' incorporates:
   *  Logic: '<S942>/Logical Operator1'
   *  Logic: '<S942>/Logical Operator27'
   *  Logic: '<S942>/Logical Operator28'
   *  Logic: '<S942>/Logical Operator29'
   *  Logic: '<S944>/Logical Operator8'
   *  Logic: '<S944>/Logical Operator9'
   *  Logic: '<S947>/Logical Operator'
   *  Logic: '<S948>/Logical Operator'
   *  Logic: '<S948>/Logical Operator1'
   */
  m_ACC_is_FSMEnbl06_bl = (m_ACC_is_FSMEnbl05_bl && (!rtb_LogicalOperator5_m) &&
    (!rtb_LogicalOperator10_mo) && (!rtb_LogicalOperator9_a) &&
    (!rtb_LogicalOperator2_e5) && (!rtb_LogicalOperator2_hs));

  /* Logic: '<S947>/Logical Operator3' incorporates:
   *  Constant: '<S947>/FW_P_ACC_is_CCFM_EnNoActvIN_bl_2'
   */
  rtb_LogicalOperator3_n0p = (app_ConstB.RelationalOperator1_o &&
    P_ACC_is_CCFM_EmsnRltdIN_bl);

  /* Logic: '<S940>/Logical Operator9' incorporates:
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_FVCMBlkIN_bl_1'
   */
  rtb_LogicalOperator9_o = (app_ConstB.DFIn_is_FVCMBlk_bl &&
    P_ACC_is_CCFM_FVCMBlkIN_bl);

  /* DataTypeConversion: '<S5>/Data Type Conversion82' */
  rtb_Add12 = floor(app_B.SCS_TCSOpngSts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion14' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion82'
   */
  rtb_DataTypeConversion14 = (eTCSS_TCSSts)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* Logic: '<S940>/Logical Operator7' incorporates:
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_TCSStsFltIN_bl_1'
   *  Constant: '<S940>/TCSOpngStsActive4'
   *  RelationalOperator: '<S940>/Relational Operator4'
   */
  rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = ((rtb_DataTypeConversion14 == TCSS_Fault) &&
    P_ACC_is_CCFM_TCSStsFltIN_bl);

  /* DataTypeConversion: '<S5>/Data Type Conversion83' */
  rtb_Add12 = floor(app_B.SCS_VSESts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion15' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion83'
   */
  rtb_DataTypeConversion15 = (eVSES_VSESts)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* Logic: '<S940>/Logical Operator1' incorporates:
   *  Constant: '<S940>/Constant5'
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_VSEStsFltIN_bl_1'
   *  RelationalOperator: '<S940>/Relational Operator11'
   */
  rtb_DFIn_is_CCFM_VSEStsFlt_bl_d = ((rtb_DataTypeConversion15 == VSES_Fault) &&
    P_ACC_is_CCFM_VSEStsFltIN_bl);

  /* Logic: '<S940>/Logical Operator2' incorporates:
   *  Constant: '<S940>/Constant4'
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_ToqRespErrIN_bl_1'
   *  RelationalOperator: '<S940>/Relational Operator1'
   */
  rtb_LogicalOperator2_fg = ((rtb_DataTypeConversion64 == CPR_Error) &&
    P_ACC_is_CCFM_ToqRespErrIN_bl);

  /* Logic: '<S942>/Logical Operator23' incorporates:
   *  Logic: '<S940>/Logical Operator10'
   *  Logic: '<S940>/Logical Operator11'
   *  Logic: '<S940>/Logical Operator12'
   *  Logic: '<S940>/Logical Operator8'
   *  Logic: '<S942>/Logical Operator21'
   *  Logic: '<S942>/Logical Operator33'
   *  Logic: '<S942>/Logical Operator34'
   *  Logic: '<S942>/Logical Operator35'
   *  Logic: '<S947>/Logical Operator1'
   */
  m_ACC_is_FSMEnbl07_bl = (m_ACC_is_FSMEnbl06_bl && (!rtb_LogicalOperator3_n0p) &&
    (!rtb_LogicalOperator9_o) && (!rtb_DFIn_is_CCFM_TCSStsFlt_bl_d) &&
    (!rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) && (!rtb_LogicalOperator2_fg));

  /* Logic: '<S940>/Logical Operator3' incorporates:
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_DspdSpdIN_bl_1'
   *  RelationalOperator: '<S940>/Relational Operator2'
   */
  rtb_LogicalOperator3_ht = (((int32_T)DFIn_V_VIDPEstdEgoVehSpdIPK_u16 == 255) &&
    P_ACC_is_CCFM_DspdSpdIN_bl);

  /* BusCreator: '<S58>/Bus Creator' incorporates:
   *  Constant: '<S58>/Constant'
   *  Constant: '<S58>/Constant1'
   *  Constant: '<S58>/Constant2'
   *  Constant: '<S58>/Constant3'
   *  Constant: '<S58>/Constant4'
   *  Constant: '<S58>/Constant5'
   *  Inport: '<Root>/radar_pubcan_481'
   */
  app_B.BusCreator_es.Extended = 0U;
  app_B.BusCreator_es.Length = 7U;
  app_B.BusCreator_es.Remote = 0U;
  app_B.BusCreator_es.Error = 0U;
  app_B.BusCreator_es.ID = 481U;
  app_B.BusCreator_es.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_es.Data[i_0] = arg_radar_pubcan_481[i_0];
  }

  /* End of BusCreator: '<S58>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack25' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack25' */
    if ((7 == app_B.BusCreator_es.Length) && (app_B.BusCreator_es.ID !=
         INVALID_CAN_ID) ) {
      if ((481 == app_B.BusCreator_es.ID) && (0U == app_B.BusCreator_es.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 16
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[2]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsAlvRC_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsCanclSWA_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 18
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[2]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsDistDecSWA_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 19
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[2]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsDistIncSWA_Safety = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 6
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsOnSWA = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 8
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_es.Data[1]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsSWA = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 5
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsRsmSWA = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 4
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsSetSWA = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 2
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsSpdDecSWA = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsSpdIncSWA = result;
            }
          }

          /* --------------- START Unpacking signal 10 ------------------
           *  startBit                = 0
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_es.Data[0]) & (uint8_T)(0x3U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.IPK_CCSwStsSwDataIntgtySWA = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion81' */
  rtb_Add12 = floor(app_B.IPK_CCSwStsSwDataIntgtySWA);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* Logic: '<S940>/Logical Operator4' incorporates:
   *  Constant: '<S940>/Constant2'
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_CCSDataIngIN_bl_1'
   *  DataTypeConversion: '<S5>/Data Type Conversion13'
   *  DataTypeConversion: '<S5>/Data Type Conversion81'
   *  RelationalOperator: '<S940>/Relational Operator3'
   */
  rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o = (((eCSW_CCSwIntg)(uint8_T)(rtb_Add12 <
    0.0 ? (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 :
    (int32_T)(uint8_T)rtb_Add12) != CSW_Data_Valid) &&
    P_ACC_is_CCFM_CCSDataIngIN_bl);

  /* Logic: '<S940>/Logical Operator5' incorporates:
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_EPBStsUnkwIN_bl_1'
   */
  rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl =
    (app_ConstB.DFIn_is_CCFM_EPBStsUnknowFlt_bl && P_ACC_is_CCFM_EPBStsUnkwIN_bl);

  /* Logic: '<S940>/Logical Operator6' incorporates:
   *  Constant: '<S940>/Constant10'
   *  Constant: '<S940>/FW_P_ACC_is_CCFM_AccRespErrIN_bl_1'
   *  RelationalOperator: '<S940>/Relational Operator6'
   */
  rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = ((rtb_DataTypeConversion63 ==
    CSRP_Control_Not_Allowed_For_Error) && P_ACC_is_CCFM_AccRespErrIN_bl);

  /* Logic: '<S955>/Logical Operator3' incorporates:
   *  Constant: '<S955>/FW_P_ACC_is_CCFM_AEBPActvIN_bl_1'
   */
  rtb_RelationalOperator7_oa = (app_ConstB.RelationalOperator6_m &&
    P_ACC_is_CCFM_DrvngMdNoSuptIN_bl);

  /* Logic: '<S942>/Logical Operator39' incorporates:
   *  Logic: '<S940>/Logical Operator13'
   *  Logic: '<S940>/Logical Operator14'
   *  Logic: '<S940>/Logical Operator15'
   *  Logic: '<S940>/Logical Operator16'
   *  Logic: '<S942>/Logical Operator20'
   *  Logic: '<S942>/Logical Operator36'
   *  Logic: '<S942>/Logical Operator37'
   *  Logic: '<S942>/Logical Operator38'
   *  Logic: '<S955>/Logical Operator2'
   *
   * Block description for '<S955>/Logical Operator2':
   *
   */
  m_ACC_is_ACCFSMEnbl_bl = (m_ACC_is_FSMEnbl07_bl && (!rtb_LogicalOperator3_ht) &&
    (!rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) &&
    (!rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl) &&
    (!rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f) && (!rtb_RelationalOperator7_oa));

  /* BusCreator: '<S67>/Bus Creator' incorporates:
   *  Constant: '<S67>/Constant'
   *  Constant: '<S67>/Constant1'
   *  Constant: '<S67>/Constant2'
   *  Constant: '<S67>/Constant3'
   *  Constant: '<S67>/Constant4'
   *  Constant: '<S67>/Constant5'
   *  Inport: '<Root>/radar_pubcan_562'
   */
  app_B.BusCreator_ih.Extended = 0U;
  app_B.BusCreator_ih.Length = 8U;
  app_B.BusCreator_ih.Remote = 0U;
  app_B.BusCreator_ih.Error = 0U;
  app_B.BusCreator_ih.ID = 562U;
  app_B.BusCreator_ih.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_ih.Data[i_0] = arg_radar_pubcan_562[i_0];
  }

  /* End of BusCreator: '<S67>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack35' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack35' */
    if ((8 == app_B.BusCreator_ih.Length) && (app_B.BusCreator_ih.ID !=
         INVALID_CAN_ID) ) {
      if ((562 == app_B.BusCreator_ih.ID) && (0U == app_B.BusCreator_ih.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 53
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_ih.Data[6]) & (uint8_T)(0xE0U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_HDCSysSts = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion84' */
  rtb_Add12 = floor(app_B.SCS_HDCSysSts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion17' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion84'
   */
  rtb_DataTypeConversion17 = (eHDC_HDCSysSts)(uint8_T)(rtb_Add12 < 0.0 ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
    (uint8_T)rtb_Add12);

  /* BusCreator: '<S49>/Bus Creator' incorporates:
   *  Constant: '<S49>/Constant'
   *  Constant: '<S49>/Constant1'
   *  Constant: '<S49>/Constant2'
   *  Constant: '<S49>/Constant3'
   *  Constant: '<S49>/Constant4'
   *  Constant: '<S49>/Constant5'
   *  Inport: '<Root>/radar_pubcan_489'
   */
  app_B.BusCreator_iy.Extended = 0U;
  app_B.BusCreator_iy.Length = 8U;
  app_B.BusCreator_iy.Remote = 0U;
  app_B.BusCreator_iy.Error = 0U;
  app_B.BusCreator_iy.ID = 489U;
  app_B.BusCreator_iy.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_iy.Data[i_0] = arg_radar_pubcan_489[i_0];
  }

  /* End of BusCreator: '<S49>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack34' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack34' */
    if ((8 == app_B.BusCreator_iy.Length) && (app_B.BusCreator_iy.ID !=
         INVALID_CAN_ID) ) {
      if ((489 == app_B.BusCreator_iy.ID) && (0U == app_B.BusCreator_iy.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 52
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[6]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ABSAlvRC = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_iy.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ABSAChksm = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 30
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x40U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ABSA = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 29
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ABSF = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 31
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_ACCBrkngA = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 25
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x2U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_EnDragToqRducnA = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 28
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_TCSA = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 24
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[3]) & (uint8_T)(0x1U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSESysA = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 36
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_iy.Data[4]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VehDynYawRateV = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 40
           *  length                  = 12
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = SIGNED
           *  factor                  = 0.0625
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              int16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);
                int16_T* tempValuePtr = (int16_T*)&tempValue;

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_iy.Data[5]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_iy.Data[4]) & (uint16_T)(0xFU)) << 8);
                }

                unpackedValue = *tempValuePtr;
              }

              {
                uint16_T* tempRawValuePtr = (uint16_T*)&unpackedValue;
                uint16_T tempValue = *tempRawValuePtr;
                int16_T* tempValuePtr = (int16_T*)&tempValue;
                uint16_T bitValue = tempValue & (uint16_T)0x800U;
                if (bitValue != 0U) {
                  /* Extend sign bits */
                  tempValue = tempValue | (uint16_T)0xF000U;
                  unpackedValue = *tempValuePtr;
                }
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.0625;
              app_B.SCS_VehDynYawRate = result;
            }
          }
        }
      }
    }
  }

  /* Logic: '<S975>/Logical Operator3' incorporates:
   *  Constant: '<S976>/Constant1'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_ABSActvIN_bl_2'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_HDCActvIN_bl_2'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_TCSActvIN_bl_2'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_VSEActvIN_bl_2'
   *  Constant: '<S976>/TCSOpngMdoff2'
   *  Constant: '<S976>/TCSOpngStsActive1'
   *  DataTypeConversion: '<S5>/Data Type Conversion16'
   *  Logic: '<S975>/Logical Operator'
   *  Logic: '<S975>/Logical Operator2'
   *  Logic: '<S976>/Logical Operator16'
   *  Logic: '<S976>/Logical Operator17'
   *  Logic: '<S976>/Logical Operator18'
   *  Logic: '<S976>/Logical Operator20'
   *  Logic: '<S976>/Logical Operator21'
   *  Logic: '<S976>/Logical Operator22'
   *  Logic: '<S976>/Logical Operator23'
   *  Logic: '<S976>/Logical Operator25'
   *  RelationalOperator: '<S976>/Relational Operator1'
   *  RelationalOperator: '<S976>/Relational Operator2'
   *  RelationalOperator: '<S976>/Relational Operator5'
   *
   * Block description for '<S976>/Logical Operator16':
   *
   *
   * Block description for '<S976>/Logical Operator17':
   *
   *
   * Block description for '<S976>/Logical Operator18':
   *
   *
   * Block description for '<S976>/Logical Operator25':
   *
   */
  m_ACC_is_SSMEnbl01_bl = (((rtb_DataTypeConversion15 != VSES_Act) ||
    (!P_ACC_is_CCFM_VSEActvEnIN_bl)) && ((rtb_DataTypeConversion17 != HDC_Active)
    || (!P_ACC_is_CCFM_HDCActvEnIN_bl)) && ((!(app_B.SCS_ABSA != 0.0)) ||
    (!P_ACC_is_CCFM_ABSActvEnIN_bl)) && ((rtb_DataTypeConversion14 !=
    TCSS_Active) || (!P_ACC_is_CCFM_TCSActvEnIN_bl)));

  /* Logic: '<S979>/Logical Operator9' incorporates:
   *  Constant: '<S979>/Constant4'
   *  Constant: '<S979>/FW_P_ACC_is_CCFM_VehSpdOvrIN_bl_1'
   *  RelationalOperator: '<S979>/Relational Operator4'
   */
  rtb_OR_f = ((DFIn_V_VIDPEstdEgoVehSpdIPK_u16 > P_ACC_V_MaxACCActvSpd_u8) &&
              P_ACC_is_CCFM_VehSpdOvrIN_bl);

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter2'
   *
   * Block description for '<S906>/Chattering_Filter2':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion54' */
  rtb_Switch_otx = app_Chattering_Filter(app_B.IPK_CCSwStsCanclSWA_Safety != 0.0,
    &app_DW.Chattering_Filter2);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter2' */

  /* Outputs for Atomic SubSystem: '<S906>/Upedge_Detection'
   *
   * Block description for '<S906>/Upedge_Detection':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Upedge_Detection(rtb_Switch_otx, &LogicalOperator,
                       &app_DW.Upedge_Detection);

  /* End of Outputs for SubSystem: '<S906>/Upedge_Detection' */

  /* Logic: '<S977>/Logical Operator9' incorporates:
   *  Constant: '<S977>/FW_P_ACC_is_CCFM_ACCCanclIN_bl_1'
   */
  rtb_Compare_hj = (LogicalOperator && P_ACC_is_CCFM_ACCCanclIN_bl);

  /* Logic: '<S975>/Logical Operator8' incorporates:
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_MSRActvIN_bl_2'
   *  DataTypeConversion: '<S5>/Data Type Conversion18'
   *  Logic: '<S975>/Logical Operator4'
   *  Logic: '<S975>/Logical Operator6'
   *  Logic: '<S976>/Logical Operator19'
   *  Logic: '<S976>/Logical Operator24'
   *  Logic: '<S977>/Logical Operator10'
   *  Logic: '<S979>/Logical Operator10'
   *
   * Block description for '<S976>/Logical Operator19':
   *
   *
   * Block description for '<S977>/Logical Operator10':
   *
   *
   * Block description for '<S979>/Logical Operator10':
   *
   */
  m_ACC_is_ACCSSMEnbl_bl = (m_ACC_is_SSMEnbl01_bl &&
    ((!(app_B.SCS_EnDragToqRducnA != 0.0)) || (!P_ACC_is_CCFM_MSRActvEnIN_bl)) &&
    (!rtb_OR_f) && (!rtb_Compare_hj));

  /* Logic: '<S939>/Logical Operator4' incorporates:
   *  Logic: '<S939>/Logical Operator'
   *  Logic: '<S939>/Logical Operator2'
   *  Logic: '<S939>/Logical Operator3'
   */
  m_ACC_is_FSMDsbl01_bl = (rtb_LogicalOperator9_a || rtb_LogicalOperator2_e5 ||
    rtb_LogicalOperator2_hk || rtb_DFIn_is_APAStsDsbl_bl ||
    rtb_DFIn_is_NRCDStsDsbl_bl);

  /* DataTypeConversion: '<S93>/Data Type Conversion3' incorporates:
   *  UnitDelay: '<S93>/Unit Delay8'
   */
  rtb_DataTypeConversion3 = (E_ACCAccReqSts_t)app_DW.UnitDelay8_DSTATE;

  /* Logic: '<S928>/Logical Operator24' incorporates:
   *  Constant: '<S928>/TCSOpngStsActive10'
   *  Constant: '<S928>/TCSOpngStsActive11'
   *  Constant: '<S928>/TCSOpngStsActive7'
   *  Constant: '<S928>/TCSOpngStsActive8'
   *  Constant: '<S928>/TCSOpngStsActive9'
   *  Logic: '<S928>/Logical Operator'
   *  Logic: '<S928>/Logical Operator22'
   *  Logic: '<S928>/Logical Operator23'
   *  RelationalOperator: '<S928>/Relational Operator22'
   *  RelationalOperator: '<S928>/Relational Operator23'
   *  RelationalOperator: '<S928>/Relational Operator24'
   *  RelationalOperator: '<S928>/Relational Operator25'
   *  RelationalOperator: '<S928>/Relational Operator26'
   *  UnitDelay: '<S93>/Unit Delay34'
   */
  m_ACC_is_ACCActvGeneral_bl = ((app_DW.UnitDelay34_DSTATE == eACCReqStsActive) ||
    (app_DW.UnitDelay34_DSTATE == eACCReqStsActiveOverride) ||
    (app_DW.UnitDelay34_DSTATE == eACCReqStsBrkOnly) ||
    (app_DW.UnitDelay34_DSTATE == eStandStillActive) ||
    (app_DW.UnitDelay34_DSTATE == eStandStillWait));

  /* Outputs for Atomic SubSystem: '<S950>/Debounce_Module' */
  /* Logic: '<S962>/Logical Operator9' incorporates:
   *  Constant: '<S950>/Constant3'
   *  Constant: '<S950>/P_ACC_cnt_OAFReActvThrs_u2'
   *  Constant: '<S962>/Constant1'
   *  Constant: '<S962>/character2'
   *  Logic: '<S962>/Logical Operator6'
   *  RelationalOperator: '<S962>/Relational Operator3'
   *  RelationalOperator: '<S962>/Relational Operator9'
   *
   * Block description for '<S962>/Logical Operator9':
   *
   *
   * Block description for '<S950>/P_ACC_cnt_OAFReActvThrs_u2':
   *  CALI PARA.
   *  ACC Torque Request Responce no Request Hysteresis time threshold,
   *  when DA_IN_indx_ACCAccReqResp_u8 no Request time length is larger than this para,
   *  the system will not support ACC and TJA.
   *
   * Block description for '<S962>/character2':
   *  /+ +/
   *
   * Block description for '<S962>/Logical Operator6':
   *
   */
  rtb_Out_p = app_Debounce_Module_b((rtb_DataTypeConversion63 == CSRP_No_request)
    && (rtb_DataTypeConversion3 == eACCAccelReq) && m_ACC_is_ACCActvGeneral_bl,
    P_DFIn_t_ChACCAccReqRespNoReqHys_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_g, 0.02F,
    &app_DW.Debounce_Module_d);

  /* End of Outputs for SubSystem: '<S950>/Debounce_Module' */

  /* Outputs for Atomic SubSystem: '<S950>/Debounce_Module2' */
  /* Logic: '<S962>/Logical Operator3' incorporates:
   *  Constant: '<S950>/Constant2'
   *  Constant: '<S950>/P_ACC_cnt_OAFReActvThrs_u4'
   *  Constant: '<S962>/Constant3'
   *  RelationalOperator: '<S962>/Relational Operator2'
   *
   * Block description for '<S962>/Logical Operator3':
   *
   *
   * Block description for '<S950>/P_ACC_cnt_OAFReActvThrs_u4':
   *  CALI PARA.
   *  ACC Torque Request Responce no Request Hysteresis time threshold,
   *  when DA_IN_indx_ACCAccReqResp_u8 no Request time length is larger than this para,
   *  the system will not support ACC and TJA.
   */
  rtb_Out_bg = app_Debounce_Module_b((rtb_DataTypeConversion63 ==
    CSRP_Lost_Arbitration) && m_ACC_is_ACCActvGeneral_bl,
    P_DFIn_t_ChACCAccReqRespLosArb_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_k, 0.02F,
    &app_DW.Debounce_Module2);

  /* End of Outputs for SubSystem: '<S950>/Debounce_Module2' */

  /* Outputs for Atomic SubSystem: '<S949>/Debounce_Module1' */
  /* Logic: '<S949>/Logical Operator2' incorporates:
   *  Constant: '<S949>/Constant2'
   *  Constant: '<S949>/Constant8'
   *  Constant: '<S949>/P_ACC_cnt_OAFReActvThrs_u1'
   *  Constant: '<S949>/character47'
   *  DataTypeConversion: '<S93>/Data Type Conversion5'
   *  Logic: '<S949>/Logical Operator7'
   *  RelationalOperator: '<S949>/Relational Operator2'
   *  RelationalOperator: '<S949>/Relational Operator7'
   *  UnitDelay: '<S93>/Unit Delay7'
   *
   * Block description for '<S949>/Logical Operator2':
   *
   *
   * Block description for '<S949>/P_ACC_cnt_OAFReActvThrs_u1':
   *  CALI PARA.
   *  PtACC Torque Request Responce Lost arbitration Hysteresis time threshold,
   *  when DA_IN_indx_PtACCToqReqResp_u8 LostArb time length is larger than this para,
   *  the system will not support ACC and TJA.
   *
   * Block description for '<S949>/character47':
   *  /+ +/
   *
   * Block description for '<S949>/Logical Operator7':
   *
   */
  rtb_Out_k = app_Debounce_Module_b((rtb_DataTypeConversion64 == CPR_No_Request)
    && ((eCTR_ACCTorqReq)app_DW.UnitDelay7_DSTATE == CTR_TorqReq) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_ACCToqReqRespNoReqHys_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_d, 0.02F,
    &app_DW.Debounce_Module1);

  /* End of Outputs for SubSystem: '<S949>/Debounce_Module1' */

  /* DataTypeConversion: '<S5>/Data Type Conversion28' */
  DataTypeConversion28 = (real32_T)app_B.ECM_AccelActuPos;

  /* Logic: '<S932>/Logical Operator5' incorporates:
   *  Constant: '<S932>/ '
   *  Constant: '<S932>/1'
   *  Constant: '<S932>/TCSOpngStsActive1'
   *  Constant: '<S932>/TCSOpngStsActive10'
   *  Constant: '<S932>/TCSOpngStsActive11'
   *  Constant: '<S932>/TCSOpngStsActive2'
   *  Constant: '<S932>/TCSOpngStsActive3'
   *  Constant: '<S932>/TCSOpngStsActive7'
   *  Constant: '<S932>/character3'
   *  Constant: '<S932>/character4'
   *  DataTypeConversion: '<S5>/Data Type Conversion28'
   *  Logic: '<S932>/Logical Operator1'
   *  Logic: '<S932>/Logical Operator2'
   *  Logic: '<S932>/Logical Operator23'
   *  Logic: '<S932>/Logical Operator24'
   *  Logic: '<S932>/Logical Operator3'
   *  Logic: '<S932>/Logical Operator4'
   *  Logic: '<S932>/Logical Operator6'
   *  Logic: '<S932>/Logical Operator7'
   *  Logic: '<S932>/Logical Operator8'
   *  RelationalOperator: '<S932>/Relational Operator1'
   *  RelationalOperator: '<S932>/Relational Operator22'
   *  RelationalOperator: '<S932>/Relational Operator25'
   *  RelationalOperator: '<S932>/Relational Operator26'
   *  RelationalOperator: '<S932>/Relational Operator3'
   *  RelationalOperator: '<S932>/Relational Operator4'
   *  RelationalOperator: '<S932>/Relational Operator5'
   *  RelationalOperator: '<S932>/Relational Operator6'
   *  RelationalOperator: '<S932>/Relational Operator7'
   *  RelationalOperator: '<S932>/Relational Operator8'
   *  UnitDelay: '<S93>/Unit Delay34'
   *
   * Block description for '<S932>/character3':
   *  /+ +/
   *
   * Block description for '<S932>/character4':
   *  /+ +/
   */
  m_ACC_is_ACCOvrrdReq_bl = (((app_DW.UnitDelay34_DSTATE == eACCReqStsActive) ||
    (app_DW.UnitDelay34_DSTATE == eStandStillActive) ||
    (app_DW.UnitDelay34_DSTATE == eStandStillWait) || (app_DW.UnitDelay34_DSTATE
    == eACCReqStsStandby) || (app_DW.UnitDelay34_DSTATE ==
    eACCReqStsActiveOverride) || (app_DW.UnitDelay34_DSTATE == eACCReqStsBrkOnly))
    && (((rtb_DataTypeConversion3 == eACCAccelNoReq) && (((real32_T)
    app_B.ECM_AccelActuPos > P_DFIn_perc_AclActuPosOvrdLo_sg) ||
    app_ConstB.RelationalOperator2_g)) || ((rtb_DataTypeConversion3 ==
    eACCAccelReq) && ((real32_T)app_B.ECM_AccelActuPos >
                      P_DFIn_perc_AclActuPosOvrdHi_sg))));

  /* Outputs for Atomic SubSystem: '<S949>/Debounce_Module' */
  /* Logic: '<S949>/Logical Operator5' incorporates:
   *  Constant: '<S949>/Constant3'
   *  Constant: '<S949>/Constant7'
   *  Constant: '<S949>/P_ACC_cnt_OAFReActvThrs_u2'
   *  Logic: '<S949>/Logical Operator6'
   *  RelationalOperator: '<S949>/Relational Operator3'
   *  RelationalOperator: '<S949>/Relational Operator5'
   *
   * Block description for '<S949>/Logical Operator5':
   *
   *
   * Block description for '<S949>/P_ACC_cnt_OAFReActvThrs_u2':
   *  CALI PARA.
   *  PtACC Torque Request Responce Lost arbitration Hysteresis time threshold, when DA_IN_indx_PtACCToqReqResp_u8 LostArb time length is larger than this para, the system
   *  will not support ACC and TJA.
   *
   * Block description for '<S949>/Logical Operator6':
   *
   */
  rtb_Out_i = app_Debounce_Module_b((rtb_DataTypeConversion64 ==
    CPR_Lost_Arbitration) && (!m_ACC_is_ACCOvrrdReq_bl) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_ACCToqReqRespNoReqHys_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Modu, 0.02F,
    &app_DW.Debounce_Module_b);

  /* End of Outputs for SubSystem: '<S949>/Debounce_Module' */

  /* Logic: '<S939>/Logical Operator12' incorporates:
   *  Constant: '<S949>/FW_P_ACC_is_CCFM_ToqRespLArbIN_bl_1'
   *  Constant: '<S949>/FW_P_ACC_is_CCFM_ToqRespNReqIN_bl_1'
   *  Constant: '<S950>/FW_P_ACC_is_CCFM_AccRespLArbIN_bl_1'
   *  Constant: '<S950>/FW_P_ACC_is_CCFM_AccRespNReqIN_bl_1'
   *  Constant: '<S950>/FW_P_ACC_is_CCFM_AccRespPCndIN_bl_1'
   *  Constant: '<S962>/Constant4'
   *  Logic: '<S939>/Logical Operator10'
   *  Logic: '<S939>/Logical Operator5'
   *  Logic: '<S939>/Logical Operator6'
   *  Logic: '<S939>/Logical Operator8'
   *  Logic: '<S949>/Logical Operator4'
   *  Logic: '<S949>/Logical Operator8'
   *  Logic: '<S965>/Logical Operator5'
   *  Logic: '<S965>/Logical Operator7'
   *  Logic: '<S965>/Logical Operator8'
   *  RelationalOperator: '<S962>/Relational Operator4'
   */
  m_ACC_is_FSMDsbl02_bl = (m_ACC_is_FSMDsbl01_bl || (rtb_Out_p &&
    P_ACC_is_CCFM_AccRespNReqIN_bl) || (rtb_Out_bg &&
    P_ACC_is_CCFM_AccRespLArbIN_bl) || ((rtb_DataTypeConversion63 ==
    CSRP_PreCondition_Not_Satisfied) && P_ACC_is_CCFM_AccRespPCndIN_bl) ||
    (rtb_Out_k && P_ACC_is_CCFM_ToqRespNReqIN_bl) || (rtb_Out_i &&
    P_ACC_is_CCFM_ToqRespLArbIN_bl));

  /* Logic: '<S939>/Logical Operator16' incorporates:
   *  Constant: '<S949>/Constant5'
   *  Constant: '<S949>/FW_P_ACC_is_CCFM_ToqRespPCndIN_bl_1'
   *  Logic: '<S939>/Logical Operator14'
   *  Logic: '<S939>/Logical Operator15'
   *  Logic: '<S939>/Logical Operator7'
   *  Logic: '<S939>/Logical Operator9'
   *  Logic: '<S949>/Logical Operator9'
   *  RelationalOperator: '<S949>/Relational Operator6'
   */
  m_ACC_is_FSMDsbl03_bl = (m_ACC_is_FSMDsbl02_bl || ((rtb_DataTypeConversion64 ==
    CPR_Precondition_Not_Satisfied) && P_ACC_is_CCFM_ToqRespPCndIN_bl) ||
    rtb_LogicalOperator4_ec || rtb_DFIn_is_EPBAppcnStsApp_bl ||
    rtb_DFIn_is_EPBCCCanclDsbl_bl || rtb_LogicalOperator1_d2);

  /* Logic: '<S939>/Logical Operator13' incorporates:
   *  Logic: '<S939>/Logical Operator11'
   *  Logic: '<S939>/Logical Operator17'
   *  Logic: '<S939>/Logical Operator18'
   *  Logic: '<S939>/Logical Operator19'
   */
  m_ACC_is_FSMDsbl04_bl = (m_ACC_is_FSMDsbl03_bl || rtb_DFIn_is_AEBStsDsbl_bl ||
    rtb_DFIn_is_AEBPStsDsbl_bl || rtb_LogicalOperator9_kf ||
    rtb_LogicalOperator3_ox || rtb_SeatBeltOn_o);

  /* Logic: '<S939>/Logical Operator25' incorporates:
   *  Logic: '<S939>/Logical Operator22'
   *  Logic: '<S939>/Logical Operator24'
   *  Logic: '<S939>/Logical Operator30'
   *  Logic: '<S939>/Logical Operator31'
   */
  m_ACC_is_FSMDsbl05_bl = (m_ACC_is_FSMDsbl04_bl ||
    rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m || rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d ||
    rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f || rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p ||
    rtb_DFIn_is_CCFM_BntStsDsbl_bl_l);

  /* Logic: '<S939>/Logical Operator21' incorporates:
   *  Logic: '<S939>/Logical Operator26'
   *  Logic: '<S939>/Logical Operator27'
   *  Logic: '<S939>/Logical Operator28'
   *  Logic: '<S939>/Logical Operator29'
   */
  m_ACC_is_FSMDsbl06_bl = (m_ACC_is_FSMDsbl05_bl || rtb_LogicalOperator1_pr ||
    rtb_LogicalOperator3_d || rtb_LogicalOperator4_jt || rtb_LogicalOperator5_m ||
    rtb_LogicalOperator10_mo);

  /* Logic: '<S939>/Logical Operator32' incorporates:
   *  Logic: '<S939>/Logical Operator20'
   *  Logic: '<S939>/Logical Operator34'
   *  Logic: '<S939>/Logical Operator35'
   *  Logic: '<S939>/Logical Operator36'
   *  Logic: '<S939>/Logical Operator37'
   */
  m_ACC_is_FSMDsbl07_bl = (m_ACC_is_FSMDsbl06_bl || rtb_LogicalOperator2_hs ||
    rtb_LogicalOperator9_o || rtb_DFIn_is_CCFM_TCSStsFlt_bl_d ||
    rtb_DFIn_is_CCFM_VSEStsFlt_bl_d || rtb_LogicalOperator2_fg ||
    rtb_LogicalOperator3_ht);

  /* Logic: '<S939>/Logical Operator40' incorporates:
   *  Logic: '<S939>/Logical Operator1'
   *  Logic: '<S939>/Logical Operator23'
   *  Logic: '<S939>/Logical Operator33'
   *  Logic: '<S939>/Logical Operator38'
   *  Logic: '<S939>/Logical Operator39'
   */
  m_ACC_is_ACCFSMDsbl_bl = (m_ACC_is_FSMDsbl07_bl ||
    rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o ||
    rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl ||
    rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f || rtb_DFIn_is_CCFM_BntStsDsbl_bl_p ||
    rtb_LogicalOperator3_n0p || rtb_RelationalOperator7_oa);

  /* Outputs for Atomic SubSystem: '<S976>/Debounce_Module1' */
  /* Logic: '<S976>/Logical Operator3' incorporates:
   *  Constant: '<S976>/Constant2'
   *  Constant: '<S976>/Constant5'
   *  Constant: '<S976>/P_ACC_cnt_OAFReActvThrs_u16'
   *  RelationalOperator: '<S976>/Relational Operator11'
   *
   * Block description for '<S976>/Logical Operator3':
   *
   *
   * Block description for '<S976>/P_ACC_cnt_OAFReActvThrs_u16':
   *  CALI PARA.
   *  VDC aborton time threshold, when HDC active time length is larger than this para, the system
   *  will not support ACC and TJA.
   */
  rtb_Out_j = app_Debounce_Module_b((rtb_DataTypeConversion15 == VSES_Act) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_ESPActv_sg,
    app_ConstB.TmpSignalConversionAtDebounce_M_dw, 0.02F,
    &app_DW.Debounce_Module1_b);

  /* End of Outputs for SubSystem: '<S976>/Debounce_Module1' */

  /* Outputs for Atomic SubSystem: '<S976>/Debounce_Module2' */
  /* Logic: '<S976>/Logical Operator4' incorporates:
   *  Constant: '<S976>/Constant3'
   *  Constant: '<S976>/P_ACC_cnt_OAFReActvThrs_u3'
   *  Constant: '<S976>/TCSOpngMdoff1'
   *  RelationalOperator: '<S976>/Relational Operator9'
   *
   * Block description for '<S976>/Logical Operator4':
   *
   *
   * Block description for '<S976>/P_ACC_cnt_OAFReActvThrs_u3':
   *  /+CALI PARA.
   *  HDC aborton time threshold, when HDC active time length is larger than this para, the system
   *  will not support ACC and TJA.+/
   */
  rtb_Out_a = app_Debounce_Module_b((rtb_DataTypeConversion17 == HDC_Active) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_HDCActv_sg,
    app_ConstB.TmpSignalConversionAtDebounce_M_kw, 0.02F,
    &app_DW.Debounce_Module2_l);

  /* End of Outputs for SubSystem: '<S976>/Debounce_Module2' */

  /* Outputs for Atomic SubSystem: '<S976>/Debounce_Module3' */
  /* Logic: '<S976>/Logical Operator1' incorporates:
   *  Constant: '<S976>/Constant4'
   *  Constant: '<S976>/P_ACC_cnt_OAFReActvThrs_u2'
   *  DataTypeConversion: '<S5>/Data Type Conversion16'
   *
   * Block description for '<S976>/Logical Operator1':
   *
   *
   * Block description for '<S976>/P_ACC_cnt_OAFReActvThrs_u2':
   *  CALI PARA.
   *  ABS aborton time threshold, when HDC active time length is larger than this para, the system
   *  will not support ACC and TJA.
   */
  rtb_Out_h5 = app_Debounce_Module_b((app_B.SCS_ABSA != 0.0) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_ABSActv_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_o, 0.02F,
    &app_DW.Debounce_Module3);

  /* End of Outputs for SubSystem: '<S976>/Debounce_Module3' */

  /* Outputs for Atomic SubSystem: '<S976>/Debounce_Module4' */
  /* Logic: '<S976>/Logical Operator2' incorporates:
   *  Constant: '<S976>/Constant6'
   *  Constant: '<S976>/P_ACC_cnt_OAFReActvThrs_u1'
   *  Constant: '<S976>/TCSOpngStsActive4'
   *  RelationalOperator: '<S976>/Relational Operator4'
   *
   * Block description for '<S976>/Logical Operator2':
   *
   *
   * Block description for '<S976>/P_ACC_cnt_OAFReActvThrs_u1':
   *  CALI PARA.
   *  TCS aborton time threshold, when HDC active time length is larger than this para, the system
   *  will not support ACC and TJA.
   */
  rtb_Out_oy = app_Debounce_Module_b((rtb_DataTypeConversion14 == TCSS_Active) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_TCSActv_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_i, 0.02F,
    &app_DW.Debounce_Module4);

  /* End of Outputs for SubSystem: '<S976>/Debounce_Module4' */

  /* Logic: '<S974>/Logical Operator2' incorporates:
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_ABSActvIN_bl_1'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_HDCActvIN_bl_1'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_TCSActvIN_bl_1'
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_VSEActvIN_bl_1'
   *  Logic: '<S974>/Logical Operator1'
   *  Logic: '<S974>/Logical Operator5'
   *  Logic: '<S976>/Logical Operator11'
   *  Logic: '<S976>/Logical Operator12'
   *  Logic: '<S976>/Logical Operator13'
   *  Logic: '<S976>/Logical Operator14'
   */
  m_ACC_is_SSMDsbl01_bl = ((rtb_Out_j && P_ACC_is_CCFM_VSEActvIN_bl) ||
    (rtb_Out_a && P_ACC_is_CCFM_HDCActvIN_bl) || (rtb_Out_h5 &&
    P_ACC_is_CCFM_ABSActvIN_bl) || (rtb_Out_oy && P_ACC_is_CCFM_TCSActvIN_bl));

  /* Outputs for Atomic SubSystem: '<S976>/Debounce_Module5' */
  /* Logic: '<S976>/Logical Operator5' incorporates:
   *  Constant: '<S976>/Constant7'
   *  Constant: '<S976>/P_ACC_cnt_OAFReActvThrs_u4'
   *  DataTypeConversion: '<S5>/Data Type Conversion18'
   *
   * Block description for '<S976>/Logical Operator5':
   *
   *
   * Block description for '<S976>/P_ACC_cnt_OAFReActvThrs_u4':
   *  CALI PARA.
   *  VDC aborton time threshold, when HDC active time length is larger than this para, the system
   *  will not support ACC and TJA.
   */
  rtb_Out = app_Debounce_Module_b((app_B.SCS_EnDragToqRducnA != 0.0) &&
    m_ACC_is_ACCActvGeneral_bl, P_DFIn_t_ESPActv_sg,
    app_ConstB.TmpSignalConversionAtDebounce_Mo_j, 0.02F,
    &app_DW.Debounce_Module5);

  /* End of Outputs for SubSystem: '<S976>/Debounce_Module5' */

  /* Logic: '<S974>/Logical Operator7' incorporates:
   *  Constant: '<S976>/FW_P_ACC_is_CCFM_MSRActvIN_bl_1'
   *  Logic: '<S974>/Logical Operator3'
   *  Logic: '<S974>/Logical Operator6'
   *  Logic: '<S976>/Logical Operator15'
   */
  m_ACC_is_ACCSSMDsbl_bl = (m_ACC_is_SSMDsbl01_bl || (rtb_Out &&
    P_ACC_is_CCFM_MSRActvIN_bl) || rtb_OR_f || rtb_Compare_hj);

  /* Logic: '<S930>/Logical Operator7' incorporates:
   *  Constant: '<S930>/FW_P_ACC_is_CCFM_ISOCStfdIN_bl_2'
   *  Logic: '<S907>/Logical Operator8'
   */
  rtb_Compare_hj = (m_is_ACC_FaultBitlhbt_bl && P_ACC_is_CCFM_FaultBitIhbtIN_bl);

  /* Logic: '<S930>/Logical Operator4' incorporates:
   *  Constant: '<S930>/Constant1'
   *  Constant: '<S930>/Constant2'
   *  Constant: '<S930>/FW_P_ACC_is_CCFM_ACCReqFltIN_bl_1'
   *  Constant: '<S930>/FW_P_ACC_is_CCFM_ISOCStfdIN_bl_1'
   *  Constant: '<S930>/FW_P_ACC_is_CCFM_SSOCStfdIN_bl_1'
   *  Logic: '<S930>/Logical Operator1'
   *  Logic: '<S930>/Logical Operator13'
   *  Logic: '<S930>/Logical Operator14'
   *  Logic: '<S930>/Logical Operator3'
   *  Logic: '<S930>/Logical Operator6'
   *  Logic: '<S930>/Logical Operator7'
   *  Logic: '<S930>/Logical Operator9'
   *  RelationalOperator: '<S930>/Relational Operator1'
   *  RelationalOperator: '<S930>/Relational Operator5'
   */
  m_ACC_is_ACCReqDsbl_bl = ((rtb_Compare_hj || (m_ACC_is_ACCFSMDsbl_bl &&
    P_ACC_is_CCFM_ISOCStfdIN_bl) || (m_ACC_is_ACCSSMDsbl_bl &&
    ((rtb_DataTypeConversion63 != CSRP_Request_honored) &&
     (rtb_DataTypeConversion63 != CSRP_ReqReceived_NoFlt_NotHonored)) &&
    P_ACC_is_CCFM_SSOCStfdIN_bl)) && P_ACC_is_CCFM_ACCReqFltIN_bl);

  /* Logic: '<S930>/Logical Operator5' incorporates:
   *  Constant: '<S930>/FW_P_ACC_is_CCFM_ACCReqIN_bl_1'
   *  Logic: '<S930>/Logical Operator11'
   *  Logic: '<S930>/Logical Operator12'
   *  Logic: '<S930>/Logical Operator2'
   *  Logic: '<S930>/Logical Operator8'
   *
   * Block description for '<S930>/Logical Operator12':
   *
   *
   * Block description for '<S930>/Logical Operator8':
   *
   */
  m_ACC_is_ACCReqEnbl_bl = ((m_ACC_is_ACCFSMEnbl_bl && m_ACC_is_ACCSSMEnbl_bl &&
    (!m_ACC_is_ACCReqDsbl_bl)) || (!P_ACC_is_CCFM_ACCReqIN_bl));

  /* DataTypeConversion: '<S5>/Data Type Conversion86' */
  rtb_Add12 = floor(app_B.ECM_PtBrkPdlDscrtInptSts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion30' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion86'
   */
  DataTypeConversion30 = (eBPL_BrkPdlApl)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* Logic: '<S936>/Logical Operator3' incorporates:
   *  Constant: '<S936>/Constant1'
   *  Constant: '<S936>/Constant2'
   *  Constant: '<S936>/character2'
   *  Logic: '<S936>/Logical Operator1'
   *  Logic: '<S936>/Logical Operator2'
   *  RelationalOperator: '<S936>/Relational Operator1'
   *  RelationalOperator: '<S936>/Relational Operator2'
   *  RelationalOperator: '<S936>/Relational Operator5'
   *
   * Block description for '<S936>/character2':
   *  /+ +/
   */
  m_ACC_is_BrkOnlyEnbl_bl = (m_ACC_is_ACCSSMDsbl_bl && ((rtb_DataTypeConversion3
    == eACCAccelReq) || ((rtb_DataTypeConversion63 == CSRP_Request_honored) ||
    (rtb_DataTypeConversion63 == CSRP_ReqReceived_NoFlt_NotHonored))));

  /* BusCreator: '<S45>/Bus Creator' incorporates:
   *  Constant: '<S45>/Constant'
   *  Constant: '<S45>/Constant1'
   *  Constant: '<S45>/Constant2'
   *  Constant: '<S45>/Constant3'
   *  Constant: '<S45>/Constant4'
   *  Constant: '<S45>/Constant5'
   *  Inport: '<Root>/radar_pubcan_389'
   */
  app_B.BusCreator_a4.Extended = 0U;
  app_B.BusCreator_a4.Length = 8U;
  app_B.BusCreator_a4.Remote = 0U;
  app_B.BusCreator_a4.Error = 0U;
  app_B.BusCreator_a4.ID = 389U;
  app_B.BusCreator_a4.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_a4.Data[i_0] = arg_radar_pubcan_389[i_0];
  }

  /* End of BusCreator: '<S45>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack33' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack33' */
    if ((8 == app_B.BusCreator_a4.Length) && (app_B.BusCreator_a4.ID !=
         INVALID_CAN_ID) ) {
      if ((389 == app_B.BusCreator_a4.ID) && (0U == app_B.BusCreator_a4.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 48
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_a4.Data[6]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSEAlvRC = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_a4.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSEChksm = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a4.Data[0]) & (uint8_T)(0x8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSELatAccV = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 24
           *  length                  = 12
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = SIGNED
           *  factor                  = 0.015625
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              int16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);
                int16_T* tempValuePtr = (int16_T*)&tempValue;

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_a4.Data[3]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_a4.Data[2]) & (uint16_T)(0xFU)) << 8);
                }

                unpackedValue = *tempValuePtr;
              }

              {
                uint16_T* tempRawValuePtr = (uint16_T*)&unpackedValue;
                uint16_T tempValue = *tempRawValuePtr;
                int16_T* tempValuePtr = (int16_T*)&tempValue;
                uint16_T bitValue = tempValue & (uint16_T)0x800U;
                if (bitValue != 0U) {
                  /* Extend sign bits */
                  tempValue = tempValue | (uint16_T)0xF000U;
                  unpackedValue = *tempValuePtr;
                }
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.015625;
              app_B.SCS_VSELatAcc = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 2
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_a4.Data[0]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VSELongtAccV = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 8
           *  length                  = 10
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = SIGNED
           *  factor                  = 0.03
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              int16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);
                int16_T* tempValuePtr = (int16_T*)&tempValue;

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_a4.Data[1]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_a4.Data[0]) & (uint16_T)(0x3U)) << 8);
                }

                unpackedValue = *tempValuePtr;
              }

              {
                uint16_T* tempRawValuePtr = (uint16_T*)&unpackedValue;
                uint16_T tempValue = *tempRawValuePtr;
                int16_T* tempValuePtr = (int16_T*)&tempValue;
                uint16_T bitValue = tempValue & (uint16_T)0x200U;
                if (bitValue != 0U) {
                  /* Extend sign bits */
                  tempValue = tempValue | (uint16_T)0xFC00U;
                  unpackedValue = *tempValuePtr;
                }
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.03;
              app_B.SCS_VSELongtAcc = result;
            }
          }
        }
      }
    }
  }

  /* Product: '<S1040>/Divide1' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion24'
   */
  rtb_Divide1 = (real32_T)app_B.SCS_VSELongtAcc * app_ConstB.a;

  /* Sum: '<S1040>/Add1' incorporates:
   *  UnitDelay: '<S1040>/Unit Delay'
   *  UnitDelay: '<S1040>/Unit Delay1'
   */
  rtb_Gain5_i = (rtb_Divide1 + app_DW.UnitDelay_DSTATE_d) -
    app_DW.UnitDelay1_DSTATE_b;

  /* Outputs for Atomic SubSystem: '<S1035>/VehSpdVaild' */
  /* Gain: '<S1035>/Gain' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion20'
   *  DataTypeConversion: '<S5>/Data Type Conversion21'
   *  DataTypeConversion: '<S5>/Data Type Conversion22'
   *  DataTypeConversion: '<S5>/Data Type Conversion23'
   *  Gain: '<S1035>/Gain1'
   *  Gain: '<S1035>/Gain2'
   *  Gain: '<S1035>/Gain3'
   *  UnitDelay: '<S1035>/Unit Delay1'
   */
  app_VehSpdVaild(((real32_T)CV_kph2mps) * (real32_T)app_B.SCS_WhlGndVelLNonDrvn,
                  ((real32_T)CV_kph2mps) * (real32_T)app_B.SCS_WhlGndVelRNonDrvn,
                  ((real32_T)CV_kph2mps) * (real32_T)app_B.SCS_WhlGndVelLDrvn,
                  ((real32_T)CV_kph2mps) * (real32_T)app_B.SCS_WhlGndVelRDrvn,
                  app_DW.UnitDelay1_DSTATE_f, &rtb_Switch4, &rtb_Switch_l5,
                  &app_ConstB.VehSpdVaild, &app_DW.VehSpdVaild);

  /* End of Outputs for SubSystem: '<S1035>/VehSpdVaild' */

  /* Outputs for Atomic SubSystem: '<S1023>/EstdLongtAccel1' */
  /* DataTypeConversion: '<S1060>/Data Type Conversion7' incorporates:
   *  DataTypeConversion: '<S1023>/Data Type Conversion30'
   *  UnitDelay: '<S1060>/spdD3'
   */
  rtb_DFIn_a_EstdLongtAccelMnFilt_sg = app_EstdLongtAccel1(rtb_Switch_l5,
    (real32_T)app_DW.spdD3_DSTATE, &app_B.EstdLongtAccel1,
    &app_DW.EstdLongtAccel1);

  /* End of Outputs for SubSystem: '<S1023>/EstdLongtAccel1' */

  /* Outputs for Atomic SubSystem: '<S1023>/EstdVSELongtAccel' */
  app_EstdVSELongtAccel((real32_T)app_DW.spdD3_DSTATE,
                        rtb_DFIn_a_EstdLongtAccelMnFilt_sg, rtb_Gain5_i,
                        &DFIn_a_EstdVSELongtAccel_sg, &app_B.EstdVSELongtAccel,
                        &app_DW.EstdVSELongtAccel);

  /* End of Outputs for SubSystem: '<S1023>/EstdVSELongtAccel' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter'
   *
   * Block description for '<S906>/Chattering_Filter':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion52' */
  rtb_Switch_ha = app_Chattering_Filter(app_B.IPK_CCSwStsOnSWA != 0.0,
    &app_DW.Chattering_Filter);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter' */

  /* Switch: '<S926>/Switch' incorporates:
   *  Logic: '<S926>/Logical Operator'
   */
  app_B.Switch_g = rtb_Switch_ha;

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter3'
   *
   * Block description for '<S906>/Chattering_Filter3':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion55' */
  rtb_Switch_o3 = app_Chattering_Filter(app_B.IPK_CCSwStsRsmSWA != 0.0,
    &app_DW.Chattering_Filter3);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter3' */

  /* Outputs for Atomic SubSystem: '<S906>/Fallingedge_Detection1'
   *
   * Block description for '<S906>/Fallingedge_Detection1':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Fallingedge_Detection(rtb_Switch_o3, &app_B.LogicalOperator_a,
    &app_DW.Fallingedge_Detection1);

  /* End of Outputs for SubSystem: '<S906>/Fallingedge_Detection1' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter1'
   *
   * Block description for '<S906>/Chattering_Filter1':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion53' */
  rtb_Switch_gf = app_Chattering_Filter(app_B.IPK_CCSwStsSetSWA != 0.0,
    &app_DW.Chattering_Filter1);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter1' */

  /* Outputs for Atomic SubSystem: '<S906>/Fallingedge_Detection'
   *
   * Block description for '<S906>/Fallingedge_Detection':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Fallingedge_Detection(rtb_Switch_gf, &app_B.LogicalOperator_j,
    &app_DW.Fallingedge_Detection);

  /* End of Outputs for SubSystem: '<S906>/Fallingedge_Detection' */

  /* Logic: '<S907>/Logical Operator7' */
  rtb_Compare_hj = (app_ConstB.DFIn_is_CCFMRFltFSMWtSCS_bl || rtb_Compare_hj);

  /* Logic: '<S937>/Logical Operator3' incorporates:
   *  Constant: '<S935>/FW_P_ACC_is_CCFM_BrkPdlAppIN_bl_1'
   *  Constant: '<S935>/FW_P_ACC_is_CCFM_OvrrdReqIN_bl_1'
   *  Constant: '<S935>/FW_P_ACC_is_CCFM_VehSdslIN_bl_1'
   *  Constant: '<S938>/Constant1'
   *  Logic: '<S935>/Logical Operator1'
   *  Logic: '<S935>/Logical Operator2'
   *  Logic: '<S935>/Logical Operator9'
   *  Logic: '<S937>/Logical Operator1'
   *  Logic: '<S937>/Logical Operator10'
   *  Logic: '<S937>/Logical Operator11'
   *  Logic: '<S937>/Logical Operator12'
   *  Logic: '<S937>/Logical Operator13'
   *  Logic: '<S937>/Logical Operator14'
   *  Logic: '<S937>/Logical Operator15'
   *  Logic: '<S937>/Logical Operator16'
   *  Logic: '<S937>/Logical Operator17'
   *  Logic: '<S937>/Logical Operator18'
   *  Logic: '<S937>/Logical Operator19'
   *  Logic: '<S937>/Logical Operator2'
   *  Logic: '<S937>/Logical Operator5'
   *  Logic: '<S937>/Logical Operator6'
   *  Logic: '<S937>/Logical Operator7'
   *  Logic: '<S937>/Logical Operator8'
   *  Logic: '<S937>/Logical Operator9'
   *  RelationalOperator: '<S938>/Relational Operator2'
   */
  m_ACC_is_BrkOnlyExit_bl = (rtb_DFIn_is_EPBAppcnStsApp_bl ||
    rtb_LogicalOperator9_kf || rtb_LogicalOperator1_pr || rtb_LogicalOperator3_d
    || rtb_LogicalOperator4_jt || rtb_LogicalOperator5_m ||
    rtb_LogicalOperator10_mo || rtb_DFIn_is_AEBStsDsbl_bl ||
    rtb_DFIn_is_AEBPStsDsbl_bl || rtb_SeatBeltOn_o ||
    rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m || rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d ||
    rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f || rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p ||
    rtb_DFIn_is_CCFM_BntStsDsbl_bl_l || rtb_LogicalOperator2_e5 ||
    (m_ACC_is_ACCOvrrdReq_bl && P_ACC_is_CCFM_OvrrdReqIN_bl) ||
    (m_ACC_is_VehSdslSts_bl && P_ACC_is_CCFM_VehSdslIN_bl) ||
    ((DataTypeConversion30 == BPL_Brake_Applied) &&
     P_ACC_is_CCFM_BrkPdlBkOyIN_bl));

  /* Logic: '<S909>/Logical Operator1' incorporates:
   *  Constant: '<S93>/Constant7'
   */
  rtb_DFIn_is_EPBAppcnStsApp_bl = false;

  /* Product: '<S995>/Divide' incorporates:
   *  Constant: '<S909>/P_VDC_ACC_t_VehStdstlTmThrs_u8'
   *  Constant: '<S995>/Constant1'
   *
   * Block description for '<S909>/P_VDC_ACC_t_VehStdstlTmThrs_u8':
   *  The longest time for ESP hydraulic pressure holding.
   *  Take 3s for example
   *
   * Block description for '<S995>/Constant1':
   *  % C_system_step = 0.01s.
   */
  rtb_a_Min_Modify = P_ACC_t_FTCAutoGoTm_sg / C_ACC_SMR_System_step;

  /* Saturate: '<S995>/Saturation2_To_-4' */
  if (rtb_a_Min_Modify > 65530.0F) {
    rtb_a_Min_Modify = 65530.0F;
  } else {
    if (rtb_a_Min_Modify < 0.0F) {
      rtb_a_Min_Modify = 0.0F;
    }
  }

  /* End of Saturate: '<S995>/Saturation2_To_-4' */

  /* DataTypeConversion: '<S995>/Data Type Conversion11' */
  DFIn_a_EstdVSELongtAccel_sg = floorf(rtb_a_Min_Modify);
  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg)) {
    /* DataTypeConversion: '<S995>/Data Type Conversion11' */
    rtb_Divide_cd = 0U;
  } else {
    /* DataTypeConversion: '<S995>/Data Type Conversion11' */
    rtb_Divide_cd = (uint16_T)fmodf(DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
  }

  /* End of DataTypeConversion: '<S995>/Data Type Conversion11' */

  /* Product: '<S994>/Divide1' incorporates:
   *  Constant: '<S909>/P_VDC_ACC_BrkOnlyTmThrs_u8'
   *  Constant: '<S994>/Constant3'
   *
   * Block description for '<S909>/P_VDC_ACC_BrkOnlyTmThrs_u8':
   *  Afer BrkonlyTmThrs, the Brkonly state will end.
   *  For example, 3s.
   *
   * Block description for '<S994>/Constant3':
   *  % C_system_step = 0.01s.
   */
  rtb_a_Min_Modify = P_ACC_t_BrkOnlyTmThrs_sg / C_ACC_SMR_System_step;

  /* Saturate: '<S994>/Saturation2_To_-5' */
  if (rtb_a_Min_Modify > 65530.0F) {
    rtb_a_Min_Modify = 65530.0F;
  } else {
    if (rtb_a_Min_Modify < 0.0F) {
      rtb_a_Min_Modify = 0.0F;
    }
  }

  /* End of Saturate: '<S994>/Saturation2_To_-5' */

  /* DataTypeConversion: '<S994>/Data Type Conversion12' */
  DFIn_a_EstdVSELongtAccel_sg = floorf(rtb_a_Min_Modify);
  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg)) {
    /* DataTypeConversion: '<S994>/Data Type Conversion12' */
    app_B.P_ACC_cntr_BrkOnlyTmThrs_u16 = 0U;
  } else {
    /* DataTypeConversion: '<S994>/Data Type Conversion12' */
    app_B.P_ACC_cntr_BrkOnlyTmThrs_u16 = (uint16_T)fmodf
      (DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
  }

  /* End of DataTypeConversion: '<S994>/Data Type Conversion12' */

  /* DataTypeConversion: '<S993>/Data Type Conversion12' incorporates:
   *  Constant: '<S909>/P_VDC_ACC_OvrrdExitTmThrs_u8'
   *  Constant: '<S993>/Constant3'
   *  Product: '<S993>/Divide1'
   *
   * Block description for '<S909>/P_VDC_ACC_OvrrdExitTmThrs_u8':
   *  30s for example is Maximum time and after that the system will enter
   *  into standby state due to the long-time override
   *
   * Block description for '<S993>/Constant3':
   *  % C_system_step = 0.01s.
   */
  DFIn_a_EstdVSELongtAccel_sg = floorf(P_ACC_t_OvrrdExitTm_sg /
    C_ACC_SMR_System_step);
  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg) || rtIsInfF
      (DFIn_a_EstdVSELongtAccel_sg)) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg,
      4.2949673E+9F);
  }

  /* DataTypeConversion: '<S993>/Data Type Conversion12' */
  app_B.P_ACC_cntr_OvrrdExitTmThrs_u16 = DFIn_a_EstdVSELongtAccel_sg < 0.0F ?
    (uint32_T)(int32_T)-(int32_T)(uint32_T)-DFIn_a_EstdVSELongtAccel_sg :
    (uint32_T)DFIn_a_EstdVSELongtAccel_sg;

  /* Chart: '<S909>/DFIn_TmCntrSF_TRUE' incorporates:
   *  Constant: '<S909>/C_system_step_2'
   *  Constant: '<S909>/P_ACC_cnt_OAFReActvThrs_u2'
   *  Constant: '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg1'
   *  DataTypeConversion: '<S5>/Data Type Conversion28'
   *  Product: '<S909>/Divide2'
   *  RelationalOperator: '<S909>/Relational Operator8'
   *
   * Block description for '<S909>/DFIn_TmCntrSF_TRUE':
   *  /+This State machine is used as a time counter for measurement when the input is TRUE.
   *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
   *
   * Block description for '<S909>/C_system_step_2':
   *  /+ C_system_step = 0.01s.+/
   *
   * Block description for '<S909>/P_ACC_cnt_OAFReActvThrs_u2':
   *  CALI PARA.
   *  ACC Torque Request Responce no Request Hysteresis time threshold,
   *  when DA_IN_indx_ACCAccReqResp_u8 no Request time length is larger than this para,
   *  the system will not support ACC and TJA.
   *
   * Block description for '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg1':
   *  % modified from 0.7 to 0.9 to avoid the entering into Standby by
   *  maximum accelpedal
   */
  app_DFIn_TmCntrSF_TRUE1((real32_T)app_B.ECM_AccelActuPos >
    P_ACC_perc_SMRAccelPdlOvrrdExit_sg, P_ACC_t_AccelPdlOverrideExit_sg /
    C_ACC_SMR_System_step, &app_B.OutPut_g, &app_DW.sf_DFIn_TmCntrSF_TRUE);

  /* Chart: '<S909>/ACC_SSM' incorporates:
   *  Constant: '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg'
   *  Constant: '<S909>/P_ACC_t_SetSpdActvThrs_sg7'
   *  Constant: '<S909>/P_VDC_ACC_v_MinCrsSpdThrs_u1'
   *  DataTypeConversion: '<S1060>/Data Type Conversion7'
   *  DataTypeConversion: '<S5>/Data Type Conversion28'
   *  UnitDelay: '<S1060>/spdD3'
   *  UnitDelay: '<S909>/Unit Delay1'
   *
   * Block description for '<S909>/P_ACC_perc_AccelPdlOvrrdExit_sg':
   *  % modified from 0.7 to 0.9 to avoid the entering into Standby by
   *  maximum accelpedal
   */
  if ((uint32_T)app_DW.is_active_c88_app == 0U) {
    app_DW.is_active_c88_app = 1U;
    app_DW.is_c88_app = app_IN_ACC_Off;
    m_FSM_sts_ACCSMRSts_en = eACCReqStsOff;
    app_DW.ACC_is_FirstTmActvFlag_bl = false;
    app_DW.ACC_is_FirstTmRsm_bl = false;
  } else {
    switch (app_DW.is_c88_app) {
     case app_IN_ACC_Active:
      app_ACC_Active(&DataTypeConversion19, &DataTypeConversion28,
                     &DataTypeConversion30, &rtb_Compare_hj,
                     &rtb_DFIn_is_EPBAppcnStsApp_bl, &rtb_Divide_cd);
      break;

     case app_IN_ACC_Fault:
      if ((!app_B.Switch_g) || ((DataTypeConversion19 == PWR_Off) ||
           (DataTypeConversion19 == PWR_ACC))) {
        app_DW.is_ACC_Fault = 0;
        app_DW.is_c88_app = app_IN_ACC_Off;
        m_FSM_sts_ACCSMRSts_en = eACCReqStsOff;
        app_DW.ACC_is_FirstTmActvFlag_bl = false;
        app_DW.ACC_is_FirstTmRsm_bl = false;
      } else {
        switch (app_DW.is_ACC_Fault) {
         case app_IN_Failure_IRreversible:
          break;

         default:
          /* case IN_Failure_Reversible: */
          if (!rtb_Compare_hj) {
            app_DW.is_ACC_Fault = 0;
            app_DW.is_c88_app = app_IN_ACC_Standby;
            m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
          }
          break;
        }
      }
      break;

     case app_IN_ACC_Off:
      if (app_B.Switch_g && (DataTypeConversion19 == PWR_Run)) {
        app_DW.is_c88_app = app_IN_ACC_Standby;
        m_FSM_sts_ACCSMRSts_en = eACCReqStsStandby;
      }
      break;

     default:
      /* case IN_ACC_Standby: */
      if (rtb_Compare_hj) {
        app_DW.is_c88_app = app_IN_ACC_Fault;
        app_DW.is_ACC_Fault = app_IN_Failure_Reversible;
        m_FSM_sts_ACCSMRSts_en = eACCRevsFault;
      } else if ((!app_B.Switch_g) || ((DataTypeConversion19 == PWR_Off) ||
                  (DataTypeConversion19 == PWR_ACC))) {
        app_DW.is_c88_app = app_IN_ACC_Off;
        m_FSM_sts_ACCSMRSts_en = eACCReqStsOff;
        app_DW.ACC_is_FirstTmActvFlag_bl = false;
        app_DW.ACC_is_FirstTmRsm_bl = false;
      } else {
        /* 20191101 Add the condition to avoid ACCOvrd when ACCisDisable20191101 Add the logic to avoid ACC_Ovrd under 5kph at first time20200117 Add the logic to forbid full gas pedal to Override */
        if (m_ACC_is_ACCReqEnbl_bl && m_ACC_is_ACCOvrrdReq_bl && ((real32_T)
             app_DW.spdD3_DSTATE >= (real32_T)P_ACC_v_SMRMinCrsSpdThrs_u8) &&
            (app_B.LogicalOperator_j || (app_B.LogicalOperator_a &&
              app_DW.ACC_is_FirstTmRsm_bl)) && (DataTypeConversion30 !=
             BPL_Brake_Applied) && (((!app_DW.ACC_is_FirstTmActvFlag_bl) &&
              ((real32_T)DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >=
               P_ACC_V_FirstTmActvSpdThrs_sg)) ||
             app_DW.ACC_is_FirstTmActvFlag_bl) && (((real32_T)
              app_B.ECM_AccelActuPos < P_ACC_perc_SMRAccelPdlOvrrdExit_sg) &&
             P_ACC_is_FullGasPdlExitEnbl_bl)) {
          app_DW.is_c88_app = app_IN_ACC_Active;
          app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
          app_DW.is_ACC_Active = app_IN_ACC_Active_Override;
          m_FSM_sts_ACCSMRSts_en = eACCReqStsActiveOverride;
          app_DW.ACC_is_FirstTmActvFlag_bl = true;
          app_DW.ACC_is_FirstTmRsm_bl = true;

          /* 20191022 Add the Logic to delete SubStates */
          app_DW.ACC_cntr_ACCOvrd_u32 = 0U;
        } else {
          /* 20191025 Add the logic to avoid ACC Avtv under 5kph at first time20200117 Add the logic to forbid full gas pedal to Active */
          if (m_ACC_is_ACCReqEnbl_bl && ((real32_T)app_DW.spdD3_DSTATE >=
               (real32_T)P_ACC_v_SMRMinCrsSpdThrs_u8) &&
              (app_B.LogicalOperator_j || (app_B.LogicalOperator_a &&
                app_DW.ACC_is_FirstTmRsm_bl)) && (DataTypeConversion30 !=
               BPL_Brake_Applied) && (((!app_DW.ACC_is_FirstTmActvFlag_bl) &&
                ((real32_T)DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >=
                 P_ACC_V_FirstTmActvSpdThrs_sg)) ||
               app_DW.ACC_is_FirstTmActvFlag_bl) && (((real32_T)
                app_B.ECM_AccelActuPos < P_ACC_perc_SMRAccelPdlOvrrdExit_sg) &&
               P_ACC_is_FullGasPdlExitEnbl_bl)) {
            app_DW.is_c88_app = app_IN_ACC_Active;
            app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
            app_DW.is_ACC_Active = app_IN_ACC_ACTIVE_Cruise;
            app_DW.ACC_is_FirstTmActvFlag_bl = true;
            app_DW.ACC_is_FirstTmRsm_bl = true;

            /* Changed at 1104. Since the Previous Entry_Distance is just used for cal the minimum Braking distan
               which is too short and may cause a later entry with uncomfortable drving experience. For example, the vehicle
               need to stay in CCC for a longtime until reaching the ACC_Entry Distance which may lead to a much higher vehicle in the
               CCCstage.
             */
            if (long_out_isLeadVehDtct) {
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_ACC_Approaching;
              m_FSM_sts_ACCSMRSts_en = eCruiseACCApproaching;
            } else {
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_Cruise_CCC;
              m_FSM_sts_ACCSMRSts_en = eCruiseCCC;

              /* The following code is added in Sep12 to avoid the false exit when SetSpd = 0
                 which may happen when the state is transfered from StandStill to CC */
              app_DW.ACC_cntr_IsCCSetSpdActv_u8 = 0U;
            }
          } else {
            /*  20180723
               add OR condition about the ACC_V_MemSpd to add the function start from
               ZERO speed when the standby state is not entered into from ACC OFF.  /$changed based on CRD aptiv Aug.7 2019$/ */
            if (m_ACC_is_ACCReqEnbl_bl && m_ACC_is_VehSdslSts_bl &&
                (app_DW.UnitDelay1_DSTATE > 0.0F) && (app_B.LogicalOperator_j ||
                 app_B.LogicalOperator_a) && (DataTypeConversion30 ==
                 BPL_Brake_Applied)) {
              /* /$delete rundant cond (DFIn_is_ACCSwOnSw_bl == 1)...$/ */
              app_DW.is_c88_app = app_IN_ACC_Active;
              app_DW.ACC_cntr_IsSetSpdActv_u8 = 0U;
              app_DW.is_ACC_Active = app_IN_ACC_ACTIVE_Cruise;
              app_DW.ACC_is_FirstTmActvFlag_bl = true;
              app_DW.ACC_is_FirstTmRsm_bl = true;
              app_DW.is_ACC_ACTIVE_Cruise = app_IN_eStandStillWait;
              m_FSM_sts_ACCSMRSts_en = eStandStillWait;

              /* ACCSysSts_RadarHSC2 = ACCReqSts_t.eStandStillWait */
              app_DW.ACC_cntr_VehACCStdStill_u16 = 0U;
            }
          }
        }
      }
      break;
    }
  }

  /* End of Chart: '<S909>/ACC_SSM' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter6'
   *
   * Block description for '<S906>/Chattering_Filter6':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion56' */
  rtb_Switch_ev = app_Chattering_Filter(app_B.IPK_CCSwStsSpdIncSWA != 0.0,
    &app_DW.Chattering_Filter6);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter6' */

  /* Chart: '<S906>/SpdInc' incorporates:
   *  Constant: '<S906>/C_system_step_1'
   *  Constant: '<S906>/C_system_step_4'
   *  Constant: '<S906>/P_DFIn_t_VSELongtAccelFilter'
   *  Constant: '<S906>/P_DFIn_t_VSELongtAccelFilter1'
   *  Product: '<S906>/Divide1'
   *  Product: '<S906>/Divide3'
   *
   * Block description for '<S906>/SpdInc':
   *  %ACCSwSpdIncSw has 2 state: PRESS or Hold.
   *  If the duration of High Level signal is less than K_Waitcounter_ACCSpdIncHoldCtrl_u16,
   *  Set the SwStatus as PRESS; otherwise, Hold.
   *  Every K_Waitcounter_ACCSpdIncHoldCtrl_u16, ACCSwSpdIncSwHldCmd is Set to ONE once.
   */
  if ((uint32_T)app_DW.is_active_c82_app == 0U) {
    app_DW.is_active_c82_app = 1U;
    app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_Initial_Condition_l0;
    app_B.ACCSpdIncSwPressSts = false;
    app_DW.ACCSpdIncSwMode_counter = 0U;
  } else {
    switch (app_DW.is_ACCSpdIncSwPressSts_HldSts) {
     case app_IN_HoldSts:
      if (!rtb_Switch_ev) {
        if ((int32_T)app_DW.is_HoldSts == 2) {
          app_DW.is_HoldSts = 0;
        } else {
          app_DW.is_HoldSts = 0;
        }

        app_B.ACCSpdIncSwHldCmd = false;
        app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_Initial_Condition_l0;
        app_B.ACCSpdIncSwPressSts = false;
        app_DW.ACCSpdIncSwMode_counter = 0U;
      } else if ((int32_T)app_DW.is_HoldSts == 1) {
        if (app_DW.L_DFIn_is_SpdIncHldCmdflag_bl) {
          app_DW.is_HoldSts = app_IN_Sampling;
          app_B.ACCSpdIncSwHldCmd = false;
          app_DW.ACCSpdIncSwHldCmd_counter = 0U;
        }
      } else {
        /* case IN_Sampling: */
        if ((real32_T)app_DW.ACCSpdIncSwHldCmd_counter >=
            P_DFIn_t_ACCSpdIncHldCmdFrq_sg / 0.02F) {
          app_B.ACCSpdIncSwHldCmd = true;
          app_DW.is_HoldSts = app_IN_Initial_Condition_m;
          app_DW.L_DFIn_is_SpdIncHldCmdflag_bl = true;
        } else {
          i_0 = (int32_T)((int32_T)app_DW.ACCSpdIncSwHldCmd_counter + 1);
          if ((int32_T)((int32_T)app_DW.ACCSpdIncSwHldCmd_counter + 1) > 65535)
          {
            i_0 = 65535;
          }

          app_DW.ACCSpdIncSwHldCmd_counter = (uint16_T)i_0;
        }
      }
      break;

     case app_IN_Initial_Condition_l0:
      if (rtb_Switch_ev) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_Middle_Condition_cz;
        app_B.ACCSpdIncSwPressSts = false;
      }
      break;

     case app_IN_Middle_Condition_cz:
      if (!rtb_Switch_ev) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_PressSts;
        app_B.ACCSpdIncSwPressSts = true;
        app_DW.ACCSpdIncSwMode_counter = 0U;
      } else if ((real32_T)app_DW.ACCSpdIncSwMode_counter >=
                 P_DFIn_t_ACCSpdIncHldThrs_sg / 0.02F) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_HoldSts;
        app_B.ACCSpdIncSwPressSts = false;
        app_B.ACCSpdIncSwHldCmd = true;
        app_DW.ACCSpdIncSwMode_counter = 0U;

        /* Added 20191202 by WangBin: add the ex to reset the Hold command */
        app_DW.is_HoldSts = app_IN_Initial_Condition_m;
        app_DW.L_DFIn_is_SpdIncHldCmdflag_bl = true;
      } else {
        i_0 = (int32_T)((int32_T)app_DW.ACCSpdIncSwMode_counter + 1);
        if ((int32_T)((int32_T)app_DW.ACCSpdIncSwMode_counter + 1) > 65535) {
          i_0 = 65535;
        }

        app_DW.ACCSpdIncSwMode_counter = (uint16_T)i_0;
      }
      break;

     default:
      /* case IN_PressSts: */
      app_DW.is_ACCSpdIncSwPressSts_HldSts = app_IN_Initial_Condition_l0;
      app_B.ACCSpdIncSwPressSts = false;
      app_DW.ACCSpdIncSwMode_counter = 0U;
      break;
    }
  }

  /* End of Chart: '<S906>/SpdInc' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter7'
   *
   * Block description for '<S906>/Chattering_Filter7':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion57' */
  rtb_Switch_jp = app_Chattering_Filter(app_B.IPK_CCSwStsSpdDecSWA != 0.0,
    &app_DW.Chattering_Filter7);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter7' */

  /* Chart: '<S906>/SpdDec' incorporates:
   *  Constant: '<S906>/C_system_step_2'
   *  Constant: '<S906>/C_system_step_3'
   *  Constant: '<S906>/P_DFIn_t_VSELongtAccelFilter2'
   *  Constant: '<S906>/P_DFIn_t_VSELongtAccelFilter3'
   *  Product: '<S906>/Divide2'
   *  Product: '<S906>/Divide4'
   *
   * Block description for '<S906>/SpdDec':
   *  %ACCSwSpdIncSw has 2 state: PRESS or Hold.
   *  If the duration of High Level signal is less than K_Waitcounter_ACCSpdIncHoldCtrl_u16,
   *  Set the SwStatus as PRESS; otherwise, Hold.
   *  Every K_Waitcounter_ACCSpdIncHoldCtrl_u16, ACCSwSpdIncSwHldCmd is Set to ONE once.
   */
  if ((uint32_T)app_DW.is_active_c81_app == 0U) {
    app_DW.is_active_c81_app = 1U;
    app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_Initial_Condition_l0;
    app_B.ACCSpdIncSwPressSts_l = false;
    app_DW.ACCSpdIncSwMode_counter_d = 0U;
  } else {
    switch (app_DW.is_ACCSpdIncSwPressSts_HldSts_g) {
     case app_IN_HoldSts:
      if (!rtb_Switch_jp) {
        if ((int32_T)app_DW.is_HoldSts_i == 2) {
          app_DW.is_HoldSts_i = 0;
        } else {
          app_DW.is_HoldSts_i = 0;
        }

        app_B.ACCSpdIncSwHldCmd_m = false;
        app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_Initial_Condition_l0;
        app_B.ACCSpdIncSwPressSts_l = false;
        app_DW.ACCSpdIncSwMode_counter_d = 0U;
      } else if ((int32_T)app_DW.is_HoldSts_i == 1) {
        if (app_DW.L_DFIn_is_SpdIncHldCmdflag_bl_g) {
          app_DW.is_HoldSts_i = app_IN_Sampling;
          app_B.ACCSpdIncSwHldCmd_m = false;
          app_DW.ACCSpdIncSwHldCmd_counter_j = 0U;
        }
      } else {
        /* case IN_Sampling: */
        if ((real32_T)app_DW.ACCSpdIncSwHldCmd_counter_j >=
            P_DFIn_t_ACCSpdDecHldCmdFrq_sg / 0.02F) {
          app_B.ACCSpdIncSwHldCmd_m = true;
          app_DW.is_HoldSts_i = app_IN_Initial_Condition1;
          app_DW.L_DFIn_is_SpdIncHldCmdflag_bl_g = true;
        } else {
          i_0 = (int32_T)((int32_T)app_DW.ACCSpdIncSwHldCmd_counter_j + 1);
          if ((int32_T)((int32_T)app_DW.ACCSpdIncSwHldCmd_counter_j + 1) > 65535)
          {
            i_0 = 65535;
          }

          app_DW.ACCSpdIncSwHldCmd_counter_j = (uint16_T)i_0;
        }
      }
      break;

     case app_IN_Initial_Condition_l0:
      if (rtb_Switch_jp) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_Middle_Condition_cz;
        app_B.ACCSpdIncSwPressSts_l = false;
      }
      break;

     case app_IN_Middle_Condition_cz:
      if (!rtb_Switch_jp) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_PressSts;
        app_B.ACCSpdIncSwPressSts_l = true;
        app_DW.ACCSpdIncSwMode_counter_d = 0U;
      } else if ((real32_T)app_DW.ACCSpdIncSwMode_counter_d >=
                 P_DFIn_t_ACCSpdDecHldThrs_sg / 0.02F) {
        app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_HoldSts;
        app_B.ACCSpdIncSwPressSts_l = false;
        app_B.ACCSpdIncSwHldCmd_m = true;
        app_DW.ACCSpdIncSwMode_counter_d = 0U;

        /* Added 20191202 by WangBin: add the ex to reset the Hold command */
        app_DW.is_HoldSts_i = app_IN_Initial_Condition1;
        app_DW.L_DFIn_is_SpdIncHldCmdflag_bl_g = true;
      } else {
        i_0 = (int32_T)((int32_T)app_DW.ACCSpdIncSwMode_counter_d + 1);
        if ((int32_T)((int32_T)app_DW.ACCSpdIncSwMode_counter_d + 1) > 65535) {
          i_0 = 65535;
        }

        app_DW.ACCSpdIncSwMode_counter_d = (uint16_T)i_0;
      }
      break;

     default:
      /* case IN_PressSts: */
      app_DW.is_ACCSpdIncSwPressSts_HldSts_g = app_IN_Initial_Condition_l0;
      app_B.ACCSpdIncSwPressSts_l = false;
      app_DW.ACCSpdIncSwMode_counter_d = 0U;
      break;
    }
  }

  /* End of Chart: '<S906>/SpdDec' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter4'
   *
   * Block description for '<S906>/Chattering_Filter4':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion58' */
  rtb_Switch_os = app_Chattering_Filter(app_B.IPK_CCSwStsDistIncSWA_Safety !=
    0.0, &app_DW.Chattering_Filter4);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter4' */

  /* Outputs for Atomic SubSystem: '<S906>/Fallingedge_Detection2'
   *
   * Block description for '<S906>/Fallingedge_Detection2':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Fallingedge_Detection(rtb_Switch_os, &rtb_DFIn_is_EPBAppcnStsApp_bl,
    &app_DW.Fallingedge_Detection2);

  /* End of Outputs for SubSystem: '<S906>/Fallingedge_Detection2' */

  /* Outputs for Atomic SubSystem: '<S906>/Chattering_Filter5'
   *
   * Block description for '<S906>/Chattering_Filter5':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion59' */
  rtb_Switch_gy = app_Chattering_Filter(app_B.IPK_CCSwStsDistDecSWA_Safety !=
    0.0, &app_DW.Chattering_Filter5);

  /* End of Outputs for SubSystem: '<S906>/Chattering_Filter5' */

  /* Outputs for Atomic SubSystem: '<S906>/Fallingedge_Detection3'
   *
   * Block description for '<S906>/Fallingedge_Detection3':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Fallingedge_Detection(rtb_Switch_gy, &rtb_DFIn_is_AEBStsDsbl_bl,
    &app_DW.Fallingedge_Detection3);

  /* End of Outputs for SubSystem: '<S906>/Fallingedge_Detection3' */

  /* Outputs for Atomic SubSystem: '<S910>/DIS'
   *
   * Block description for '<S910>/DIS':
   *  Cruise System Control Elements
   */
  /* Logic: '<S999>/Logical Operator23' incorporates:
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg5'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg6'
   *  Constant: '<S999>/TCSOpngStsActive1'
   *  Constant: '<S999>/TCSOpngStsActive10'
   *  Constant: '<S999>/TCSOpngStsActive2'
   *  Constant: '<S999>/TCSOpngStsActive4'
   *  Logic: '<S999>/Logical Operator1'
   *  Logic: '<S999>/Logical Operator11'
   *  Logic: '<S999>/Logical Operator12'
   *  Logic: '<S999>/Logical Operator3'
   *  RelationalOperator: '<S999>/Relational Operator10'
   *  RelationalOperator: '<S999>/Relational Operator11'
   *  RelationalOperator: '<S999>/Relational Operator25'
   *  RelationalOperator: '<S999>/Relational Operator9'
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg5':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg6':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   */
  rtb_DFIn_is_AEBPStsDsbl_bl = ((m_FSM_sts_ACCSMRSts_en == eCruiseCCC) ||
    (m_FSM_sts_ACCSMRSts_en == eCruiseACCApproaching) ||
    ((m_FSM_sts_ACCSMRSts_en == eACCReqStsActiveOverride) &&
     P_ACC_is_HMIDISSetSpdChgEnOvrd_bl) || ((m_FSM_sts_ACCSMRSts_en ==
    eStandStillActive) && P_ACC_is_HMIDISSetSpdChgEnStslA_bl));

  /* Logic: '<S999>/Logical Operator6' incorporates:
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg7'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg8'
   *  Constant: '<S999>/TCSOpngStsActive3'
   *  Constant: '<S999>/TCSOpngStsActive5'
   *  Constant: '<S999>/TCSOpngStsActive6'
   *  Constant: '<S999>/TCSOpngStsActive7'
   *  Logic: '<S999>/Logical Operator10'
   *  Logic: '<S999>/Logical Operator5'
   *  Logic: '<S999>/Logical Operator7'
   *  Logic: '<S999>/Logical Operator9'
   *  RelationalOperator: '<S999>/Relational Operator13'
   *  RelationalOperator: '<S999>/Relational Operator5'
   *  RelationalOperator: '<S999>/Relational Operator6'
   *  RelationalOperator: '<S999>/Relational Operator7'
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg7':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg8':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   */
  rtb_LogicalOperator9_kf = ((m_FSM_sts_ACCSMRSts_en == eCruiseCCC) ||
    (m_FSM_sts_ACCSMRSts_en == eCruiseACCApproaching) ||
    ((m_FSM_sts_ACCSMRSts_en == eACCReqStsActiveOverride) &&
     P_ACC_is_HMIDISSetSpdSetEnOvrd_bl) || ((m_FSM_sts_ACCSMRSts_en ==
    eStandStillActive) && P_ACC_is_HMIDISSetSpdSetEnStslA_bl));

  /* Logic: '<S999>/Logical Operator4' incorporates:
   *  Constant: '<S999>/BrkPdlSw_on1'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg11'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg12'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg9'
   *  Constant: '<S999>/TCSOpngStsActive11'
   *  Constant: '<S999>/TCSOpngStsActive9'
   *  Logic: '<S999>/Logical Operator2'
   *  Logic: '<S999>/Logical Operator8'
   *  Logic: '<S999>/Logical Orator1'
   *  Logic: '<S999>/Logical Orator9'
   *  RelationalOperator: '<S999>/Relational Operator1'
   *  RelationalOperator: '<S999>/Relational Operator2'
   *  RelationalOperator: '<S999>/Relational Operator26'
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg11':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg12':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg9':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   */
  rtb_SeatBeltOn_o = (((m_FSM_sts_ACCSMRSts_en == eStandStillWait) &&
                       P_ACC_is_HMIDISMemSpdChgEnStslW_bl) ||
                      ((m_FSM_sts_ACCSMRSts_en == eACCReqStsBrkOnly) &&
                       P_ACC_is_HMIDISMemSpdChgEnBrkO_bl) ||
                      ((m_FSM_sts_ACCSMRSts_en == eACCReqStsStandby) &&
                       P_ACC_is_HMIDISMemSpdChgEnSdby_bl));

  /* Switch: '<S999>/Switch1' incorporates:
   *  Constant: '<S999>/P_ACC_v_MaxCrsSpdThrs_u1'
   *  Constant: '<S999>/P_ACC_v_MaxCrsSpdThrs_u2'
   *  Constant: '<S999>/P_ACC_v_MaxCrsSpdThrs_u3'
   *  Logic: '<S999>/Logical Operator14'
   */
  if (app_ConstB.RelationalOperator3_o && P_ACC_is_HMITJAMaxSpdConfigOpn_bl) {
    DFIn_a_EstdVSELongtAccel_sg = P_ACC_v_HMIMaxCrsSpdThrsLatActv_sg;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = P_ACC_v_HMIMaxCrsSpdThrs_sg;
  }

  /* End of Switch: '<S999>/Switch1' */

  /* DataTypeConversion: '<S999>/Data Type Conversion1' incorporates:
   *  Gain: '<S999>/UnitChange2kph1'
   */
  DFIn_a_EstdVSELongtAccel_sg = floorf(3.6F * DFIn_a_EstdVSELongtAccel_sg);
  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg) || rtIsInfF
      (DFIn_a_EstdVSELongtAccel_sg)) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 256.0F);
  }

  /* DataTypeConversion: '<S999>/Data Type Conversion1' */
  P_ACC_V_MaxCrsSpdThrs_u8 = (uint8_T)(DFIn_a_EstdVSELongtAccel_sg < 0.0F ?
    (int32_T)(uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)
    -DFIn_a_EstdVSELongtAccel_sg : (int32_T)(uint8_T)DFIn_a_EstdVSELongtAccel_sg);

  /* DataTypeConversion: '<S999>/Data Type Conversion2' incorporates:
   *  Constant: '<S999>/P_VDC_ACC_v_MinCrsSpdThrs_u3'
   *  Gain: '<S999>/UnitChange2kph5'
   *
   * Block description for '<S999>/P_VDC_ACC_v_MinCrsSpdThrs_u3':
   *  The minimum Activation Speed; only if larger than this value,
   *  can the system be activated.
   */
  DataTypeConversion2 = (uint8_T)(int32_T)(int32_T)(uint32_T)((uint32_T)(230U *
    (uint32_T)P_ACC_v_HMIMinCrsSpdThrs_u8) >> 6);

  /* Logic: '<S999>/Logical Operator15' incorporates:
   *  Constant: '<S999>/P_ACC_v_MaxCrsSpdThrs_u4'
   *  Constant: '<S999>/P_ACC_v_MaxCrsSpdThrs_u5'
   *  Gain: '<S999>/UnitChange2kph2'
   *  Logic: '<S999>/Logical Operator13'
   *  RelationalOperator: '<S999>/Relational Operator8'
   *  UnitDelay: '<S999>/Unit Delay'
   */
  rtb_Compare_hj = (app_ConstB.RelationalOperator4_o &&
                    (app_DW.UnitDelay_DSTATE_n > 3.6F *
                     P_ACC_v_HMIMaxCrsSpdThrsLatActv_sg) &&
                    P_ACC_is_HMITJAMaxSpdConfigOpn_bl);

  /* Chart: '<S999>/ACC_Control_Elements' incorporates:
   *  Constant: '<S999>/ACCSwitch_Off2'
   *  Constant: '<S999>/ACCSwitch_On2'
   *  Constant: '<S999>/P_ACC_V_MinCrsSetSpd_sg'
   *  Constant: '<S999>/P_ACC_perc_GoGasPdlThrs_sg10'
   *
   * Block description for '<S999>/P_ACC_perc_GoGasPdlThrs_sg10':
   *  0x0  set Spd in Ovrd OFF
   *  0x1  set Spd in Ovrd ON
   */
  if ((uint32_T)app_DW.is_active_c90_app == 0U) {
    app_DW.is_active_c90_app = 1U;
    app_DW.is_c90_app = app_IN_DISSts_OFF;
    app_B.ACC_V_ACCMemSpd_sg = 0.0F;
    app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
  } else {
    switch (app_DW.is_c90_app) {
     case app_IN_DISSts_Active:
      app_DISSts_Active(&DFIn_V_VIDPEstdEgoVehSpdIPK_u16, &LogicalOperator,
                        &rtb_DFIn_is_AEBPStsDsbl_bl, &rtb_LogicalOperator9_kf,
                        &P_ACC_V_MaxCrsSpdThrs_u8, &rtb_Compare_hj);
      break;

     case app_IN_DISSts_FirstStandby:
      if ((app_B.Switch_g == C_ACC_HMISwitch_Off_bl) || (m_FSM_sts_ACCSMRSts_en ==
           eACCReqStsOff)) {
        app_DW.is_MemorySpeed_Set = 0;
        app_DW.is_DISSts_FirstStandby = 0;
        app_DW.is_c90_app = app_IN_DISSts_OFF;
        app_B.ACC_V_ACCMemSpd_sg = 0.0F;
        app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
      } else if ((int32_T)app_DW.is_DISSts_FirstStandby == 1) {
        /* 20180715 based on ReqFile_
           withdraw delete &&(ACC_indx_ACCSysReqSts_en!=E_ACCReqSts_t.eACCReqStsBrkOnly)... */
        if (((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) ||
             ((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
              P_ACC_is_HMIRSMActvFstStdByConfig_bl)) && (m_FSM_sts_ACCSMRSts_en
             != eACCReqStsOff) && (m_FSM_sts_ACCSMRSts_en != eACCReqStsBrkOnly) &&
            (m_FSM_sts_ACCSMRSts_en != eACCReqStsStandby) &&
            (m_FSM_sts_ACCSMRSts_en != eStandStillActive) &&
            (m_FSM_sts_ACCSMRSts_en != eStandStillWait) &&
            (m_FSM_sts_ACCSMRSts_en != eACCRevsFault) && (m_FSM_sts_ACCSMRSts_en
             != eACCIRRevsFault) && (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >=
             DataTypeConversion2)) {
          app_DW.is_DISSts_FirstStandby = 0;
          app_DW.is_c90_app = app_IN_DISSts_Active;
          app_DW.ACCCrsSpdSet_Ctrl = 0.0;
          app_DW.is_DISSts_Active = app_IN_Initial_ACCSetSpeed;
          if (P_ACC_V_HMIMinCrsSetSpd_u8 > DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)
              P_ACC_V_HMIMinCrsSetSpd_u8;
          }

          if (P_ACC_V_MaxCrsSpdThrs_u8 < DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)P_ACC_V_MaxCrsSpdThrs_u8;
          } else {
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)
              DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
          }
        } else if ((app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) &&
                   (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >= DataTypeConversion2) &&
                   rtb_SeatBeltOn_o) {
          app_DW.is_DISSts_FirstStandby = app_IN_MemorySpeed_Set;
          if (P_ACC_V_HMIMinCrsSetSpd_u8 > DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)
              P_ACC_V_HMIMinCrsSetSpd_u8;
          }

          if (P_ACC_V_MaxCrsSpdThrs_u8 < DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
            app_B.ACC_V_ACCMemSpd_sg = (real32_T)P_ACC_V_MaxCrsSpdThrs_u8;
          } else {
            app_B.ACC_V_ACCMemSpd_sg = (real32_T)DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
          }

          app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeInc;
          app_MemSpdInc_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
        } else {
          if ((app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) &&
              (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >= DataTypeConversion2) &&
              rtb_SeatBeltOn_o) {
            app_DW.is_DISSts_FirstStandby = app_IN_MemorySpeed_Set;
            if (P_ACC_V_HMIMinCrsSetSpd_u8 > DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
              DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)
                P_ACC_V_HMIMinCrsSetSpd_u8;
            }

            if (P_ACC_V_MaxCrsSpdThrs_u8 < DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
              app_B.ACC_V_ACCMemSpd_sg = (real32_T)P_ACC_V_MaxCrsSpdThrs_u8;
            } else {
              app_B.ACC_V_ACCMemSpd_sg = (real32_T)
                DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
            }

            app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeDec;
            app_MemSpdDec_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
          }
        }
      } else {
        /* case IN_MemorySpeed_Set: */
        /* 20180715 based on ReqFile_
           withdraw delete &&(ACC_indx_ACCSysReqSts_en!=E_ACCReqSts_t.eACCReqStsBrkOnly)... */
        if ((app_B.LogicalOperator_a == C_ACC_HMISwitch_On_bl) &&
            P_ACC_is_HMIRSMActvFstStdByConfig_bl && (m_FSM_sts_ACCSMRSts_en !=
             eACCReqStsOff) && (m_FSM_sts_ACCSMRSts_en != eACCReqStsBrkOnly) &&
            (m_FSM_sts_ACCSMRSts_en != eACCReqStsStandby) &&
            (m_FSM_sts_ACCSMRSts_en != eStandStillActive) &&
            (m_FSM_sts_ACCSMRSts_en != eStandStillWait) &&
            (m_FSM_sts_ACCSMRSts_en != eACCRevsFault) && (m_FSM_sts_ACCSMRSts_en
             != eACCIRRevsFault) && (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >=
             DataTypeConversion2)) {
          /*  (ACC_indx_ACCSysReqSts_en!= E_ACCReqSts_t.eACCReqStsSleep)&&  */
          if ((app_B.LogicalOperator_j == C_ACC_HMISwitch_On_bl) &&
              ((m_FSM_sts_ACCSMRSts_en != eACCReqStsOff) &&
               (m_FSM_sts_ACCSMRSts_en != eACCReqStsBrkOnly)) &&
              (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 >= DataTypeConversion2)) {
            app_DW.is_MemorySpeed_Set = 0;
            app_DW.is_DISSts_FirstStandby = 0;
            app_DW.is_c90_app = app_IN_DISSts_Active;
            app_DW.ACCCrsSpdSet_Ctrl = 0.0;
            app_DW.is_DISSts_Active = app_IN_Initial_ACCSetSpeed;
            if (P_ACC_V_HMIMinCrsSetSpd_u8 > DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
              DFIn_V_VIDPEstdEgoVehSpdIPK_u16 = (uint16_T)
                P_ACC_V_HMIMinCrsSetSpd_u8;
            }

            if (P_ACC_V_MaxCrsSpdThrs_u8 < DFIn_V_VIDPEstdEgoVehSpdIPK_u16) {
              app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)
                P_ACC_V_MaxCrsSpdThrs_u8;
            } else {
              app_B.ACC_V_ACCSetSpdIPKRAW_sg = (real32_T)
                DFIn_V_VIDPEstdEgoVehSpdIPK_u16;
            }
          } else {
            app_DW.is_MemorySpeed_Set = 0;
            app_DW.is_DISSts_FirstStandby = 0;
            app_DW.is_c90_app = app_IN_DISSts_Active;
            app_DW.ACCCrsSpdSet_Ctrl = 0.0;
            app_DW.is_DISSts_Active = app_IN_ResumeSpeed;
            app_B.ACC_V_ACCSetSpdIPKRAW_sg = fminf((real32_T)
              P_ACC_V_MaxCrsSpdThrs_u8, app_B.ACC_V_ACCMemSpd_sg);
          }
        } else if (DFIn_V_VIDPEstdEgoVehSpdIPK_u16 < DataTypeConversion2) {
          app_DW.is_MemorySpeed_Set = 0;
          app_DW.is_DISSts_FirstStandby = app_IN_MemSpd_FstStdby;
          app_B.ACC_V_ACCMemSpd_sg = 0.0F;
        } else {
          switch (app_DW.is_MemorySpeed_Set) {
           case app_IN_MemSpd_LargeDec:
            if (app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) {
              app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeInc;
              app_MemSpdInc_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_MemorySpeed_Set = app_IN_Wait;
            }
            break;

           case app_IN_MemSpd_LargeInc:
            if (app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) {
              app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeDec;
              app_MemSpdDec_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              app_DW.is_MemorySpeed_Set = app_IN_Wait;
            }
            break;

           default:
            /* case IN_Wait: */
            if (app_B.ACCSpdIncSwPressSts == C_ACC_HMISwitch_On_bl) {
              app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeInc;
              app_MemSpdInc_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
            } else {
              if (app_B.ACCSpdIncSwPressSts_l == C_ACC_HMISwitch_On_bl) {
                app_DW.is_MemorySpeed_Set = app_IN_MemSpd_LargeDec;
                app_MemSpdDec_Large(&P_ACC_V_MaxCrsSpdThrs_u8);
              }
            }
            break;
          }
        }
      }
      break;

     case app_IN_DISSts_OFF:
      if (app_B.Switch_g == C_ACC_HMISwitch_On_bl) {
        app_DW.is_c90_app = app_IN_DISSts_FirstStandby;
        app_B.ACC_V_ACCSetSpdIPKRAW_sg = 0.0F;
        app_DW.is_DISSts_FirstStandby = app_IN_MemSpd_FstStdby;
        app_B.ACC_V_ACCMemSpd_sg = 0.0F;
      }
      break;

     default:
      /* case IN_DISSts_Standby_BrkOnly_StslWait_Fault: */
      DISSts_Standby_BrkOnly_StslWait_Fault(&DFIn_V_VIDPEstdEgoVehSpdIPK_u16,
        &DataTypeConversion28, &rtb_SeatBeltOn_o, &P_ACC_V_MaxCrsSpdThrs_u8);
      break;
    }
  }

  /* End of Chart: '<S999>/ACC_Control_Elements' */

  /* Switch: '<S998>/Switch1' incorporates:
   *  Constant: '<S998>/2 wheels2'
   *  Constant: '<S998>/TCSOpngStsActive3'
   *  Constant: '<S998>/TCSOpngStsActive5'
   *  Constant: '<S998>/TCSOpngStsActive6'
   *  Constant: '<S998>/TCSOpngStsActive7'
   *  Logic: '<S998>/Logical Operator5'
   *  Logic: '<S998>/Logical Operator7'
   *  Logic: '<S998>/Logical Operator8'
   *  Lookup_n-D: '<S998>/LookupTable'
   *  RelationalOperator: '<S998>/Relational Operator5'
   *  RelationalOperator: '<S998>/Relational Operator6'
   *  RelationalOperator: '<S998>/Relational Operator7'
   *  RelationalOperator: '<S998>/Relational Operator8'
   */
  if ((m_FSM_sts_ACCSMRSts_en == eCruiseCCC) || (m_FSM_sts_ACCSMRSts_en ==
       eCruiseACCApproaching) || (m_FSM_sts_ACCSMRSts_en ==
       eACCReqStsActiveOverride) || (m_FSM_sts_ACCSMRSts_en == eStandStillActive))
  {
    DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlcpw
      (app_B.ACC_V_ACCSetSpdIPKRAW_sg, P_TX_ACC_V_HMIDISSetSpdCmpCnst_sg,
       P_TY_ACC_V_HMIDISSetSpdCmpCnst_sg, 4U);
  } else {
    DFIn_a_EstdVSELongtAccel_sg = C_ACC_HMIZero_sg;
  }

  /* End of Switch: '<S998>/Switch1' */

  /* Gain: '<S998>/UnitChange2kph3' incorporates:
   *  Constant: '<S998>/Constant5'
   *  Product: '<S998>/Divide8'
   *  Sum: '<S998>/Add2'
   *
   * Block description for '<S998>/Constant5':
   *  C_system_step = 0.01s.
   *  DFIn_V_EgoAvgVehSpd * IPK ratio
   */
  rtb_ACC_v_ACCSetSpd_sg = (app_B.ACC_V_ACCSetSpdIPKRAW_sg +
    DFIn_a_EstdVSELongtAccel_sg) / C_ACC_Gx_HMIActuSpdToIPKSpd_sg * ((real32_T)
    CV_kph2mps);

  /* Saturate: '<S998>/VLC_VAC_ACCSetSpdRAW_d'
   *
   * Block description for '<S998>/VLC_VAC_ACCSetSpdRAW_d':
   *  Should be updated by Max and Min value.
   */
  if (rtb_ACC_v_ACCSetSpd_sg > P_ACC_v_HMISetSpdHiThrs_sg) {
    rtb_ACC_v_ACCSetSpd_sg = P_ACC_v_HMISetSpdHiThrs_sg;
  } else {
    if (rtb_ACC_v_ACCSetSpd_sg < P_ACC_v_HMISetSpdLoThrs_sg) {
      rtb_ACC_v_ACCSetSpd_sg = P_ACC_v_HMISetSpdLoThrs_sg;
    }
  }

  /* End of Saturate: '<S998>/VLC_VAC_ACCSetSpdRAW_d' */

  /* Saturate: '<S998>/VLC_VAC_ACCMemSpdRAW_d'
   *
   * Block description for '<S998>/VLC_VAC_ACCMemSpdRAW_d':
   *  Should be updated by Max and Min value.
   */
  if (app_B.ACC_V_ACCMemSpd_sg > P_ACC_V_HMIMemSpdHiThrs_sg) {
    app_DW.UnitDelay1_DSTATE = P_ACC_V_HMIMemSpdHiThrs_sg;
  } else if (app_B.ACC_V_ACCMemSpd_sg < P_ACC_V_HMIMemSpdLoThrs_sg) {
    app_DW.UnitDelay1_DSTATE = P_ACC_V_HMIMemSpdLoThrs_sg;
  } else {
    app_DW.UnitDelay1_DSTATE = app_B.ACC_V_ACCMemSpd_sg;
  }

  /* End of Saturate: '<S998>/VLC_VAC_ACCMemSpdRAW_d' */

  /* Logic: '<S1000>/Logical Operator4' incorporates:
   *  Logic: '<S1000>/Logical Operator'
   *  Logic: '<S1000>/Logical Operator1'
   *  Logic: '<S1000>/Logical Operator2'
   *  Logic: '<S1000>/Logical Operator3'
   */
  rtb_Compare_hj = (LogicalOperator || app_B.LogicalOperator_j ||
                    app_B.ACCSpdIncSwPressSts_l || app_B.ACCSpdIncSwHldCmd_m ||
                    app_B.ACCSpdIncSwHldCmd || app_B.ACCSpdIncSwPressSts);

  /* Chart: '<S1000>/ACCDistanceSwitch_SM' incorporates:
   *  Constant: '<S1000>/C_Switch_On'
   *  Constant: '<S1000>/P_DFIn_indx_ACCTmDist_u8'
   *  Switch: '<S1000>/Switch'
   *  Switch: '<S1000>/Switch1'
   *
   * Block description for '<S1000>/P_DFIn_indx_ACCTmDist_u8':
   *  /+Time Distance_1 means 1sec, 2 means 1.5sec
   *  and 3 means 2 secs+/
   */
  if ((uint32_T)app_DW.is_active_c91_app == 0U) {
    app_DW.is_active_c91_app = 1U;
    app_DW.is_Cruise_Distance_Level_Status =
      ap_IN_Cruise_Distance_Level_Ini_Status;
    app_B.ACC_indx_ACCTmDist_u8 = P_ACC_indx_HMIIniCruzTmDist_u8;
  } else {
    switch (app_DW.is_Cruise_Distance_Level_Status) {
     case IN_Cruise_Distance_Level_Decreased_Sta:
      app_DW.is_Cruise_Distance_Level_Status =
        a_IN_Cruise_Distance_Level_Wait_Status;

      /* ACC_indx_ACCTmDist_u8 =P_DFIn_indx_IniCruzTmDist_u8; */
      break;

     case IN_Cruise_Distance_Level_Increased_Sta:
      app_DW.is_Cruise_Distance_Level_Status =
        a_IN_Cruise_Distance_Level_Wait_Status;

      /* ACC_indx_ACCTmDist_u8 =P_DFIn_indx_IniCruzTmDist_u8; */
      break;

     case ap_IN_Cruise_Distance_Level_Ini_Status:
      if (app_B.Switch_g == C_ACC_HMISwitch_On_bl) {
        app_DW.is_Cruise_Distance_Level_Status =
          a_IN_Cruise_Distance_Level_Wait_Status;

        /* ACC_indx_ACCTmDist_u8 =P_DFIn_indx_IniCruzTmDist_u8; */
      }
      break;

     default:
      /* case IN_Cruise_Distance_Level_Wait_Status: */
      if (app_B.Switch_g != C_ACC_HMISwitch_On_bl) {
        app_DW.is_Cruise_Distance_Level_Status =
          ap_IN_Cruise_Distance_Level_Ini_Status;
        app_B.ACC_indx_ACCTmDist_u8 = P_ACC_indx_HMIIniCruzTmDist_u8;
      } else {
        if (rtb_Compare_hj) {
          /* Switch: '<S1000>/Switch' incorporates:
           *  Constant: '<S1000>/Constant2'
           */
          rtb_DFIn_is_EPBAppcnStsApp_bl = C_ACC_HMIZero_bl;
        }

        if (rtb_DFIn_is_EPBAppcnStsApp_bl == C_ACC_HMISwitch_On_bl) {
          app_DW.is_Cruise_Distance_Level_Status =
            IN_Cruise_Distance_Level_Increased_Sta;

          /* 20190812
             ACC_indx_ACCTmDist_u8 = max(3,ACC_indx_ACCTmDist_u8+1); */
          if (3 < (int32_T)((int32_T)app_B.ACC_indx_ACCTmDist_u8 + 1)) {
            app_B.ACC_indx_ACCTmDist_u8 = 3U;
          } else {
            app_B.ACC_indx_ACCTmDist_u8 = (uint8_T)(int32_T)((int32_T)
              app_B.ACC_indx_ACCTmDist_u8 + 1);
          }
        } else {
          if (rtb_Compare_hj) {
            /* Switch: '<S1000>/Switch1' incorporates:
             *  Constant: '<S1000>/Constant1'
             */
            rtb_DFIn_is_AEBStsDsbl_bl = C_ACC_HMIZero_bl;
          }

          if (rtb_DFIn_is_AEBStsDsbl_bl == C_ACC_HMISwitch_On_bl) {
            app_DW.is_Cruise_Distance_Level_Status =
              IN_Cruise_Distance_Level_Decreased_Sta;

            /* 20190812
               ACC_indx_ACCTmDist_u8 = min(1,max(0,ACC_indx_ACCTmDist_u8-1)); */
            if (0 > (int32_T)((int32_T)app_B.ACC_indx_ACCTmDist_u8 - 1)) {
              i_0 = 0;
            } else {
              i_0 = (int32_T)((int32_T)app_B.ACC_indx_ACCTmDist_u8 - 1);
            }

            if (1 > i_0) {
              app_B.ACC_indx_ACCTmDist_u8 = 1U;
            } else {
              app_B.ACC_indx_ACCTmDist_u8 = (uint8_T)i_0;
            }
          }
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1000>/ACCDistanceSwitch_SM' */

  /* DataTypeConversion: '<S1000>/Data Type Conversion3' */
  rtb_ACC_indx_DISTmDist_en = (eDSL_DrvrSetLvl)app_B.ACC_indx_ACCTmDist_u8;

  /* Update for UnitDelay: '<S999>/Unit Delay' */
  app_DW.UnitDelay_DSTATE_n = app_B.ACC_V_ACCSetSpdIPKRAW_sg;

  /* End of Outputs for SubSystem: '<S910>/DIS' */

  /* DataTypeConversion: '<S1>/Data Type Conversion' */
  longt_out_drvrSetTmDistLvl = (uint8_T)rtb_ACC_indx_DISTmDist_en;

  /* Outputs for Atomic SubSystem: '<S910>/DIS'
   *
   * Block description for '<S910>/DIS':
   *  Cruise System Control Elements
   */
  /* Switch: '<S998>/Switch16' incorporates:
   *  Constant: '<S998>/ACCReqSts_t.eCruiseACCStdStill1'
   *  Constant: '<S998>/ACCReqSts_t.eCruiseACCStdStill2'
   *  Constant: '<S998>/ACCReqSts_t.eCruiseACCStdStill3'
   *  Logic: '<S998>/Logical Operator1'
   *  Logic: '<S998>/Logical Operator6'
   *  RelationalOperator: '<S998>/Relational Operator1'
   *  RelationalOperator: '<S998>/Relational Operator19'
   *  RelationalOperator: '<S998>/Relational Operator4'
   */
  if ((m_FSM_sts_ACCSMRSts_en == eACCReqStsStandby) || (m_FSM_sts_ACCSMRSts_en ==
       eStandStillWait) || (m_FSM_sts_ACCSMRSts_en == eACCReqStsBrkOnly)) {
    /* SignalConversion: '<S1>/Signal Copy4' incorporates:
     *  UnitDelay: '<S909>/Unit Delay1'
     */
    longt_out_drvrSetIPKSpdV = app_DW.UnitDelay1_DSTATE;
  } else {
    /* SignalConversion: '<S1>/Signal Copy4' */
    longt_out_drvrSetIPKSpdV = app_B.ACC_V_ACCSetSpdIPKRAW_sg;
  }

  /* End of Switch: '<S998>/Switch16' */
  /* End of Outputs for SubSystem: '<S910>/DIS' */

  /* BusCreator: '<S60>/Bus Creator' incorporates:
   *  Constant: '<S60>/Constant'
   *  Constant: '<S60>/Constant1'
   *  Constant: '<S60>/Constant2'
   *  Constant: '<S60>/Constant3'
   *  Constant: '<S60>/Constant4'
   *  Constant: '<S60>/Constant5'
   *  Inport: '<Root>/radar_pubcan_707'
   */
  app_B.BusCreator_gq.Extended = 0U;
  app_B.BusCreator_gq.Length = 8U;
  app_B.BusCreator_gq.Remote = 0U;
  app_B.BusCreator_gq.Error = 0U;
  app_B.BusCreator_gq.ID = 707U;
  app_B.BusCreator_gq.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_gq.Data[i_0] = arg_radar_pubcan_707[i_0];
  }

  /* End of BusCreator: '<S60>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack14' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack14' */
    if ((8 == app_B.BusCreator_gq.Length) && (app_B.BusCreator_gq.ID !=
         INVALID_CAN_ID) ) {
      if ((707 == app_B.BusCreator_gq.ID) && (0U == app_B.BusCreator_gq.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_gq.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_RfP09_Chksm = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 48
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[6]) & (uint8_T)(0xFU));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_RfP09_ALVRC = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 21
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[2]) & (uint8_T)(0x20U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_ECODrvngSpdRutA = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 23
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[2]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EcoDrvngAIO = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 5
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[0]) & (uint8_T)(0x60U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EcoDrvngDspStsGearSIS = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 52
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[6]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EcoDrvngDspStsRcmndFG = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 4
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[0]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnToqMaxExtdRngV = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 8
           *  length                  = 12
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.5
           *  offset                  = -848.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_gq.Data[1]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_gq.Data[0]) & (uint16_T)(0xFU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.5) + -848.0;
              app_B.ECM_EnToqMaxExtdRng = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 20
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_gq.Data[2]) & (uint8_T)(0x10U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ECM_EnToqMinExtdRngV = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 24
           *  length                  = 12
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.5
           *  offset                  = -848.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_gq.Data[3]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_gq.Data[2]) & (uint16_T)(0xFU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.5) + -848.0;
              app_B.ECM_EnToqMinExtdRng = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion87' */
  rtb_Add12 = floor(app_B.ECM_TrEstdGear);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion37' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion87'
   */
  rtb_DataTypeConversion37 = (eTGR_TrmGear)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* DataTypeConversion: '<S5>/Data Type Conversion96' */
  rtb_Add12 = floor(app_B.ECM_TrShftLvrPosV);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion49' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion96'
   */
  rtb_Switch4 = (eVLD_ValidSts)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)
    (int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)rtb_Add12);

  /* DataTypeConversion: '<S5>/Data Type Conversion97' */
  rtb_Add12 = floor(app_B.ECM_TrShftPtrnASts);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S5>/Data Type Conversion50' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion97'
   */
  DataTypeConversion50 = (eTRP_TrShftPtrn)(uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
    (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
    rtb_Add12);

  /* BusCreator: '<S39>/Bus Creator' incorporates:
   *  Constant: '<S39>/Constant'
   *  Constant: '<S39>/Constant1'
   *  Constant: '<S39>/Constant2'
   *  Constant: '<S39>/Constant3'
   *  Constant: '<S39>/Constant4'
   *  Constant: '<S39>/Constant5'
   *  Inport: '<Root>/radar_pubcan_851'
   */
  app_B.BusCreator_n.Extended = 0U;
  app_B.BusCreator_n.Length = 8U;
  app_B.BusCreator_n.Remote = 0U;
  app_B.BusCreator_n.Error = 0U;
  app_B.BusCreator_n.ID = 851U;
  app_B.BusCreator_n.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_n.Data[i_0] = arg_radar_pubcan_851[i_0];
  }

  /* End of BusCreator: '<S39>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack37' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack37' */
    if ((8 == app_B.BusCreator_n.Length) && (app_B.BusCreator_n.ID !=
         INVALID_CAN_ID) ) {
      if ((851 == app_B.BusCreator_n.ID) && (0U == app_B.BusCreator_n.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_n.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VehSpdAvgDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 8
           *  length                  = 15
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.015625
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_n.Data[1]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_n.Data[0]) & (uint16_T)(0x7FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.015625;
              app_B.SCS_VehSpdAvgDrvn = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 39
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_n.Data[4]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SCS_VehSpdAvgNonDrvnV = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 40
           *  length                  = 15
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.015625
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_n.Data[5]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_n.Data[4]) & (uint16_T)(0x7FU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result * 0.015625;
              app_B.SCS_VehSpdAvgNonDrvn = result;
            }
          }
        }
      }
    }
  }

  /* BusCreator: '<S37>/Bus Creator' incorporates:
   *  Constant: '<S37>/Constant'
   *  Constant: '<S37>/Constant1'
   *  Constant: '<S37>/Constant2'
   *  Constant: '<S37>/Constant3'
   *  Constant: '<S37>/Constant4'
   *  Constant: '<S37>/Constant5'
   *  Inport: '<Root>/radar_pubcan_485'
   */
  app_B.BusCreator_c1.Extended = 0U;
  app_B.BusCreator_c1.Length = 8U;
  app_B.BusCreator_c1.Remote = 0U;
  app_B.BusCreator_c1.Error = 0U;
  app_B.BusCreator_c1.ID = 485U;
  app_B.BusCreator_c1.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_c1.Data[i_0] = arg_radar_pubcan_485[i_0];
  }

  /* End of BusCreator: '<S37>/Bus Creator' */

  /* S-Function (scanunpack): '<S6>/CAN Unpack30' */
  {
    /* S-Function (scanunpack): '<S6>/CAN Unpack30' */
    if ((8 == app_B.BusCreator_c1.Length) && (app_B.BusCreator_c1.ID !=
         INVALID_CAN_ID) ) {
      if ((485 == app_B.BusCreator_c1.ID) && (0U == app_B.BusCreator_c1.Extended)
          ) {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 28
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[3]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngAlvRC = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 48
           *  length                  = 16
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_c1.Data[6]);
                  tempValue = tempValue | (uint16_T)((uint16_T)
                    (app_B.BusCreator_c1.Data[5]) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngExtdPV = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 32
           *  length                  = 12
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = -2048.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_c1.Data[4]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_c1.Data[3]) & (uint16_T)(0xFU)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = result + -2048.0;
              app_B.SAS_StrgWhlAngGrd = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 5
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[0]) & (uint8_T)(0x60U)) >> 5);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngSnsrCalSts = result;
            }
          }

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 56
           *  length                  = 8
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)(app_B.BusCreator_c1.Data[7]);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngSnsrChksm = result;
            }
          }

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 0
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[0]) & (uint8_T)(0x1U));
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngSnstFlt = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 2
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[0]) & (uint8_T)(0x4U)) >> 2);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngSnsrInid = result;
            }
          }

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 1
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[0]) & (uint8_T)(0x2U)) >> 1);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngSnsrMultCapb = result;
            }
          }

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 7
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_c1.Data[0]) & (uint8_T)(0x80U)) >> 7);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.SAS_StrgWhlAngV = result;
            }
          }

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 16
           *  length                  = 16
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.0625
           *  offset                  = -2048.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_c1.Data[2]);
                  tempValue = tempValue | (uint16_T)((uint16_T)
                    (app_B.BusCreator_c1.Data[1]) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.0625) + -2048.0;
              app_B.SAS_StrgWhlAng = result;
            }
          }
        }
      }
    }
  }

  /* BusCreator: '<S73>/Bus Creator' incorporates:
   *  Constant: '<S73>/Constant'
   *  Constant: '<S73>/Constant1'
   *  Constant: '<S73>/Constant2'
   *  Constant: '<S73>/Constant3'
   *  Constant: '<S73>/Constant4'
   *  Constant: '<S73>/Constant5'
   *  Inport: '<Root>/Cam_can_516'
   */
  app_B.BusCreator_d.Extended = 0U;
  app_B.BusCreator_d.Length = 8U;
  app_B.BusCreator_d.Remote = 0U;
  app_B.BusCreator_d.Error = 0U;
  app_B.BusCreator_d.ID = 516U;
  app_B.BusCreator_d.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_d.Data[i_0] = arg_Cam_can_516[i_0];
  }

  /* End of BusCreator: '<S73>/Bus Creator' */

  /* S-Function (scanunpack): '<S73>/CAN Unpack1' */
  {
    /* S-Function (scanunpack): '<S73>/CAN Unpack1' */
    if ((8 == app_B.BusCreator_d.Length) && (app_B.BusCreator_d.ID !=
         INVALID_CAN_ID) ) {
      if ((516 == app_B.BusCreator_d.ID) && (0U == app_B.BusCreator_d.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 6
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_d.Data[0]) & (uint8_T)(0xC0U)) >> 6);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.CANUnpack1_o1 = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 4
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_d.Data[0]) & (uint8_T)(0x30U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.CANUnpack1_o2 = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 19
           *  length                  = 5
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_d.Data[2]) & (uint8_T)(0xF8U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.CANUnpack1_o3 = result;
            }
          }
        }
      }
    }
  }

  /* DataTypeConversion: '<S73>/Data Type Conversion' */
  rtb_Add12 = floor(app_B.CANUnpack1_o1);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S73>/Data Type Conversion' */
  m_VehCP_LeftBSD_Warnning_u8 = (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)
    (int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)rtb_Add12);

  /* DataTypeConversion: '<S73>/Data Type Conversion1' */
  rtb_Add12 = floor(app_B.CANUnpack1_o2);
  if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
    rtb_Add12 = 0.0;
  } else {
    rtb_Add12 = fmod(rtb_Add12, 256.0);
  }

  /* DataTypeConversion: '<S73>/Data Type Conversion1' */
  m_VehCP_RightBSD_Warnning_u8 = (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)
    (int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)rtb_Add12);

  /* BusCreator: '<S72>/Bus Creator' incorporates:
   *  Constant: '<S72>/Constant'
   *  Constant: '<S72>/Constant1'
   *  Constant: '<S72>/Constant2'
   *  Constant: '<S72>/Constant3'
   *  Constant: '<S72>/Constant4'
   *  Constant: '<S72>/Constant5'
   *  Inport: '<Root>/Cam_can_492'
   */
  app_B.BusCreator_l.Extended = 0U;
  app_B.BusCreator_l.Length = 8U;
  app_B.BusCreator_l.Remote = 0U;
  app_B.BusCreator_l.Error = 0U;
  app_B.BusCreator_l.ID = 492U;
  app_B.BusCreator_l.Timestamp = 0.0;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_B.BusCreator_l.Data[i_0] = arg_Cam_can_492[i_0];
  }

  /* End of BusCreator: '<S72>/Bus Creator' */

  /* S-Function (scanunpack): '<S72>/CAN Unpack' */
  {
    /* S-Function (scanunpack): '<S72>/CAN Unpack' */
    if ((8 == app_B.BusCreator_l.Length) && (app_B.BusCreator_l.ID !=
         INVALID_CAN_ID) ) {
      if ((492 == app_B.BusCreator_l.ID) && (0U == app_B.BusCreator_l.Extended) )
      {
        {
          /* --------------- START Unpacking signal 0 ------------------
           *  startBit                = 4
           *  length                  = 4
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_l.Data[0]) & (uint8_T)(0xF0U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.CANUnpack_o1 = result;
            }
          }

          /* --------------- START Unpacking signal 1 ------------------
           *  startBit                = 52
           *  length                  = 3
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_l.Data[6]) & (uint8_T)(0x70U)) >> 4);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.ChLKACtrlSts = result;
            }
          }

          /* --------------- START Unpacking signal 2 ------------------
           *  startBit                = 8
           *  length                  = 11
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.01
           *  offset                  = -10.24
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_l.Data[1]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_l.Data[0]) & (uint16_T)(0x7U)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.01) + -10.24;
              app_B.ChLKARespToq = result;
            }
          }

          /* --------------- START Unpacking signal 3 ------------------
           *  startBit                = 24
           *  length                  = 15
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          /*
           * Signal is not connected or connected to terminator.
           * No unpacking code generated.
           */

          /* --------------- START Unpacking signal 4 ------------------
           *  startBit                = 3
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          /*
           * Signal is not connected or connected to terminator.
           * No unpacking code generated.
           */

          /* --------------- START Unpacking signal 5 ------------------
           *  startBit                = 40
           *  length                  = 11
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 0.01
           *  offset                  = -10.24
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint16_T unpackedValue = 0;

              {
                uint16_T tempValue = (uint16_T) (0);

                {
                  tempValue = tempValue | (uint16_T)(app_B.BusCreator_l.Data[5]);
                  tempValue = tempValue | (uint16_T)((uint16_T)((uint16_T)
                    (app_B.BusCreator_l.Data[4]) & (uint16_T)(0x7U)) << 8);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              result = (result * 0.01) + -10.24;
              app_B.DrvrStrgDlvrdToq = result;
            }
          }

          /* --------------- START Unpacking signal 6 ------------------
           *  startBit                = 55
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          /*
           * Signal is not connected or connected to terminator.
           * No unpacking code generated.
           */

          /* --------------- START Unpacking signal 7 ------------------
           *  startBit                = 37
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          /*
           * Signal is not connected or connected to terminator.
           * No unpacking code generated.
           */

          /* --------------- START Unpacking signal 8 ------------------
           *  startBit                = 38
           *  length                  = 1
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          /*
           * Signal is not connected or connected to terminator.
           * No unpacking code generated.
           */

          /* --------------- START Unpacking signal 9 ------------------
           *  startBit                = 35
           *  length                  = 2
           *  desiredSignalByteLayout = BIGENDIAN
           *  dataType                = UNSIGNED
           *  factor                  = 1.0
           *  offset                  = 0.0
           * -----------------------------------------------------------------------*/
          {
            real64_T outValue = 0;

            {
              uint8_T unpackedValue = 0;

              {
                uint8_T tempValue = (uint8_T) (0);

                {
                  tempValue = tempValue | (uint8_T)((uint8_T)((uint8_T)
                    (app_B.BusCreator_l.Data[4]) & (uint8_T)(0x18U)) >> 3);
                }

                unpackedValue = tempValue;
              }

              outValue = (real64_T) (unpackedValue);
            }

            {
              real64_T result = (real64_T) outValue;
              app_B.StrgCustSetngDspCmd = result;
            }
          }
        }
      }
    }
  }

  /* Delay: '<S74>/Delay9' */
  if ((int32_T)app_DW.icLoad != 0) {
    for (i_0 = 0; i_0 < 9; i_0++) {
      app_DW.Delay9_DSTATE[i_0] = app_B.CANUnpack_o1;
    }
  }

  /* Delay: '<S74>/Delay8' */
  if ((int32_T)app_DW.icLoad_e != 0) {
    for (i_0 = 0; i_0 < 8; i_0++) {
      app_DW.Delay8_DSTATE[i_0] = app_B.CANUnpack_o1;
    }
  }

  /* Delay: '<S74>/Delay7' */
  if ((int32_T)app_DW.icLoad_h != 0) {
    for (i_0 = 0; i_0 < 7; i_0++) {
      app_DW.Delay7_DSTATE[i_0] = app_B.CANUnpack_o1;
    }
  }

  /* Delay: '<S74>/Delay6' */
  if ((int32_T)app_DW.icLoad_i != 0) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      app_DW.Delay6_DSTATE[i_0] = app_B.CANUnpack_o1;
    }
  }

  /* Delay: '<S74>/Delay5' */
  if ((int32_T)app_DW.icLoad_c != 0) {
    for (i_0 = 0; i_0 < 5; i_0++) {
      app_DW.Delay5_DSTATE[i_0] = app_B.CANUnpack_o1;
    }
  }

  /* Delay: '<S74>/Delay' */
  if ((int32_T)app_DW.icLoad_if != 0) {
    app_DW.Delay_DSTATE[0] = app_B.CANUnpack_o1;
    app_DW.Delay_DSTATE[1] = app_B.CANUnpack_o1;
    app_DW.Delay_DSTATE[2] = app_B.CANUnpack_o1;
    app_DW.Delay_DSTATE[3] = app_B.CANUnpack_o1;
  }

  /* Delay: '<S74>/Delay1' */
  if ((int32_T)app_DW.icLoad_ed != 0) {
    app_DW.Delay1_DSTATE[0] = app_B.CANUnpack_o1;
    app_DW.Delay1_DSTATE[1] = app_B.CANUnpack_o1;
    app_DW.Delay1_DSTATE[2] = app_B.CANUnpack_o1;
  }

  /* Delay: '<S74>/Delay2' */
  if ((int32_T)app_DW.icLoad_l != 0) {
    app_DW.Delay2_DSTATE[0] = app_B.CANUnpack_o1;
    app_DW.Delay2_DSTATE[1] = app_B.CANUnpack_o1;
  }

  /* Delay: '<S74>/Delay3' */
  if ((int32_T)app_DW.icLoad_ll != 0) {
    app_DW.Delay3_DSTATE = app_B.CANUnpack_o1;
  }

  /* Switch generated from: '<S72>/Switch' incorporates:
   *  Delay: '<S74>/Delay'
   *  Delay: '<S74>/Delay1'
   *  Delay: '<S74>/Delay2'
   *  Delay: '<S74>/Delay3'
   *  Delay: '<S74>/Delay5'
   *  Delay: '<S74>/Delay6'
   *  Delay: '<S74>/Delay7'
   *  Delay: '<S74>/Delay8'
   *  Delay: '<S74>/Delay9'
   *  Logic: '<S74>/Logical Operator'
   *  Logic: '<S74>/Logical Operator1'
   *  RelationalOperator: '<S74>/Relational Operator'
   *  RelationalOperator: '<S74>/Relational Operator1'
   *  RelationalOperator: '<S74>/Relational Operator2'
   *  RelationalOperator: '<S74>/Relational Operator3'
   *  RelationalOperator: '<S74>/Relational Operator4'
   *  RelationalOperator: '<S74>/Relational Operator5'
   *  RelationalOperator: '<S74>/Relational Operator6'
   *  RelationalOperator: '<S74>/Relational Operator7'
   *  RelationalOperator: '<S74>/Relational Operator8'
   */
  if ((!(app_DW.Delay9_DSTATE[0] == app_DW.Delay8_DSTATE[0])) ||
      (!(app_DW.Delay8_DSTATE[0] == app_DW.Delay7_DSTATE[0])) ||
      (!(app_DW.Delay7_DSTATE[0] == app_DW.Delay6_DSTATE[0])) ||
      (!(app_DW.Delay6_DSTATE[0] == app_DW.Delay5_DSTATE[0])) ||
      (!(app_DW.Delay5_DSTATE[0] == app_DW.Delay_DSTATE[0])) ||
      (!(app_DW.Delay_DSTATE[0] == app_DW.Delay1_DSTATE[0])) ||
      (!(app_DW.Delay1_DSTATE[0] == app_DW.Delay2_DSTATE[0])) ||
      (!(app_DW.Delay2_DSTATE[0] == app_DW.Delay3_DSTATE)) ||
      (!(app_DW.Delay3_DSTATE == app_B.CANUnpack_o1))) {
    /* DataTypeConversion: '<S72>/Data Type Conversion' */
    rtb_Add12 = floor(app_B.ChLKACtrlSts);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    /* DataTypeConversion: '<S72>/Data Type Conversion' */
    m_VehCP_n_ChLKACtrlSts_u8 = (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)(uint8_T)
      (int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)(uint8_T)
      rtb_Add12);

    /* DataTypeConversion: '<S72>/Data Type Conversion1' */
    m_VehCP_T_ChLKARespToq_sg = (real32_T)app_B.ChLKARespToq;

    /* DataTypeConversion: '<S72>/Data Type Conversion2' */
    m_VehCP_T_DrvrStrgDlvrdToq_sg = (real32_T)app_B.DrvrStrgDlvrdToq;

    /* DataTypeConversion: '<S72>/Data Type Conversion3' */
    rtb_Add12 = floor(app_B.StrgCustSetngDspCmd);
    if (rtIsNaN(rtb_Add12) || rtIsInf(rtb_Add12)) {
      rtb_Add12 = 0.0;
    } else {
      rtb_Add12 = fmod(rtb_Add12, 256.0);
    }

    /* DataTypeConversion: '<S72>/Data Type Conversion3' */
    m_VehCP_n_StrgCustSetngDspCmd_u8 = (uint8_T)(rtb_Add12 < 0.0 ? (int32_T)
      (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Add12 : (int32_T)
      (uint8_T)rtb_Add12);
  } else {
    /* DataTypeConversion: '<S72>/Data Type Conversion' incorporates:
     *  Constant: '<S72>/Constant6'
     */
    m_VehCP_n_ChLKACtrlSts_u8 = 0U;

    /* DataTypeConversion: '<S72>/Data Type Conversion1' incorporates:
     *  Constant: '<S72>/Constant7'
     */
    m_VehCP_T_ChLKARespToq_sg = 0.0F;

    /* DataTypeConversion: '<S72>/Data Type Conversion2' incorporates:
     *  Constant: '<S72>/Constant8'
     */
    m_VehCP_T_DrvrStrgDlvrdToq_sg = 0.0F;

    /* DataTypeConversion: '<S72>/Data Type Conversion3' incorporates:
     *  Constant: '<S72>/Constant9'
     */
    m_VehCP_n_StrgCustSetngDspCmd_u8 = 0U;
  }

  /* End of Switch generated from: '<S72>/Switch' */

  /* Delay: '<S84>/Delay' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion10'
   */
  if ((int32_T)app_DW.icLoad_n != 0) {
    app_DW.Delay_DSTATE_j = (real32_T)app_B.SCS_VehDynYawRate;
  }

  /* Sum: '<S84>/Sum' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion10'
   *  Delay: '<S84>/Delay'
   *  Product: '<S84>/Product'
   *  Product: '<S84>/Product1'
   */
  m_VehCP_yr_VehDynYawRate_sg = app_DW.Delay_DSTATE_j * app_ConstB.alpha +
    app_ConstB.ualpha * (real32_T)app_B.SCS_VehDynYawRate;

  /* SignalConversion: '<S75>/Signal Copy18' incorporates:
   *  Chart: '<S75>/Chart3'
   *  DataTypeConversion: '<S75>/Data Type Conversion19'
   *  RelationalOperator: '<S78>/FixPt Relational Operator'
   *  UnitDelay: '<S78>/Delay Input1'
   *
   * Block description for '<S78>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_Chart3((app_B.BCM_LDircnIO != 0.0) > (int32_T)app_DW.DelayInput1_DSTATE_k,
             &m_VehCP_is_LftStrgLmpOn_bl, &app_DW.sf_Chart3);

  /* SignalConversion: '<S75>/Signal Copy22' incorporates:
   *  Chart: '<S75>/Chart4'
   *  DataTypeConversion: '<S75>/Data Type Conversion23'
   *  RelationalOperator: '<S79>/FixPt Relational Operator'
   *  UnitDelay: '<S79>/Delay Input1'
   *
   * Block description for '<S79>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_Chart3((app_B.BCM_RDircnIO != 0.0) > (int32_T)app_DW.DelayInput1_DSTATE_e,
             &m_VehCP_is_RghtStrgLmpOn_bl, &app_DW.sf_Chart4);

  /* Delay: '<S81>/Delay' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion29'
   */
  if ((int32_T)app_DW.icLoad_j != 0) {
    app_DW.Delay_DSTATE_a = (real32_T)app_B.SAS_StrgWhlAng;
  }

  /* Sum: '<S81>/Sum' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion29'
   *  Delay: '<S81>/Delay'
   *  Product: '<S81>/Product'
   *  Product: '<S81>/Product1'
   */
  m_VehCP_angD_StrgWhlAng_sg = app_DW.Delay_DSTATE_a * app_ConstB.alpha_l +
    app_ConstB.ualpha_p * (real32_T)app_B.SAS_StrgWhlAng;

  /* Delay: '<S82>/Delay' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion30'
   */
  if ((int32_T)app_DW.icLoad_k != 0) {
    app_DW.Delay_DSTATE_jz = (real32_T)app_B.SCS_VehSpdAvgDrvn;
  }

  /* Sum: '<S82>/Sum' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion30'
   *  Delay: '<S82>/Delay'
   *  Product: '<S82>/Product'
   *  Product: '<S82>/Product1'
   */
  m_VehCP_V_VehSpdAvgDrvn_sg = app_DW.Delay_DSTATE_jz * app_ConstB.alpha_p +
    app_ConstB.ualpha_o * (real32_T)app_B.SCS_VehSpdAvgDrvn;

  /* Saturate: '<S75>/Saturation' */
  if (m_VehCP_V_VehSpdAvgDrvn_sg > 150.0F) {
    DataTypeConversion28 = 150.0F;
  } else if (m_VehCP_V_VehSpdAvgDrvn_sg < 0.5F) {
    DataTypeConversion28 = 0.5F;
  } else {
    DataTypeConversion28 = m_VehCP_V_VehSpdAvgDrvn_sg;
  }

  /* End of Saturate: '<S75>/Saturation' */

  /* Delay: '<S85>/Delay' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion34'
   */
  if ((int32_T)app_DW.icLoad_e0 != 0) {
    app_DW.Delay_DSTATE_k = (real32_T)app_B.SAS_StrgWhlAngGrd;
  }

  /* Sum: '<S85>/Sum' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion34'
   *  Delay: '<S85>/Delay'
   *  Product: '<S85>/Product'
   *  Product: '<S85>/Product1'
   */
  m_VehCP_W_StrgWhlAngGrd_sg = app_DW.Delay_DSTATE_k * app_ConstB.alpha_j +
    app_ConstB.ualpha_h * (real32_T)app_B.SAS_StrgWhlAngGrd;

  /* Chart: '<S3>/Chart' incorporates:
   *  Constant: '<S3>/Constant'
   */
  if ((int32_T)app_B.output_cnt >= (int32_T)(uint32_T)((uint32_T)app_DW.i8_flag
       + 1U)) {
    app_B.output_cnt = 0U;
    app_DW.i8_flag = !app_DW.i8_flag;
  } else {
    i_0 = (int32_T)(uint32_T)((uint32_T)app_B.output_cnt + 1U);
    if ((uint32_T)((uint32_T)app_B.output_cnt + 1U) > 255U) {
      i_0 = 255;
    }

    app_B.output_cnt = (uint8_T)i_0;
  }

  /* End of Chart: '<S3>/Chart' */

  /* Switch: '<S94>/Switch' incorporates:
   *  Constant: '<S1020>/Constant'
   *  Constant: '<S1021>/Constant'
   *  Logic: '<S94>/OR'
   *  RelationalOperator: '<S94>/Equal'
   *  RelationalOperator: '<S94>/Equal1'
   */
  longt_out_isCtrlEngage = ((m_FSM_sts_ACCSMRSts_en == eCruiseCCC) ||
    (m_FSM_sts_ACCSMRSts_en == eCruiseACCApproaching));

  /* Switch: '<S95>/Switch' incorporates:
   *  Constant: '<S1022>/Constant'
   *  RelationalOperator: '<S95>/Equal'
   */
  rtb_DFIn_is_EPBAppcnStsApp_bl = (m_FSM_sts_ACCSMRSts_en ==
    eACCReqStsActiveOverride);

  /* Outputs for Triggered SubSystem: '<S3>/Subsystem' incorporates:
   *  TriggerPort: '<S92>/Trigger'
   */
  /* DataTypeConversion: '<S3>/Data Type Conversion2' */
  zcEvent = rt_R32ZCFcn(FALLING_ZERO_CROSSING,&app_PrevZCX.Subsystem_Trig_ZCE,
                        ((real32_T)app_B.output_cnt));
  if (zcEvent != NO_ZCEVENT) {
    /* Outputs for Atomic SubSystem: '<S157>/SfD'
     *
     * Block description for '<S157>/SfD':
     *  Safe Divide
     */
    /* Product: '<S157>/Product' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  DataTypeConversion: '<S5>/Data Type Conversion29'
     *  Gain: '<S3>/Gain'
     *  UnitDelay: '<S1060>/spdD3'
     */
    app_SfD((real32_T)app_DW.spdD3_DSTATE * (0.0174532924F * (real32_T)
             app_B.SCS_VehDynYawRate), &rtb_t_min, &app_ConstB.SfD, 0.01F);

    /* End of Outputs for SubSystem: '<S157>/SfD' */

    /* Lookup_n-D: '<S155>/1-D Lookup Table' incorporates:
     *  Lookup_n-D: '<S156>/1-D Lookup Table'
     *  Product: '<S239>/Product3'
     */
    rtb_a_Max_Modify = look1_iflf_binlxpw(rtb_t_min, app_ConstP.pooled80,
      app_ConstP.pooled79, 6U);

    /* Gain: '<S155>/Gain' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Gain: '<S156>/Gain'
     *  Gain: '<S182>/Gain2'
     *  Switch: '<S192>/Switch'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_t_min = 3.6F * (real32_T)app_DW.spdD3_DSTATE;

    /* Product: '<S155>/Product' incorporates:
     *  Constant: '<S92>/Constant3'
     *  Gain: '<S155>/Gain'
     *  Lookup_n-D: '<S155>/1-D Lookup Table'
     *  Lookup_n-D: '<S155>/2-D Lookup Table'
     */
    rtb_Add_g0 = look2_iflf_binlxpw(1.0F, rtb_t_min, app_ConstP.pooled78,
      app_ConstP.pooled43, app_ConstP.uDLookupTable_tableData,
      app_ConstP.pooled117, 3U) * rtb_a_Max_Modify;

    /* Outputs for Atomic SubSystem: '<S497>/LowPass_Filter' */
    app_LowPass_Filter(app_ConstB.Abs2, &rtb_ARB_F_PCTWhlDrvnToq_sg,
                       &app_DW.LowPass_Filter_k, 0.1F, 20.0F);

    /* End of Outputs for SubSystem: '<S497>/LowPass_Filter' */

    /* Outputs for Atomic SubSystem: '<S497>/SfD'
     *
     * Block description for '<S497>/SfD':
     *  Safe Divide
     */
    /* Lookup_n-D: '<S497>/1-D Lookup Table' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  UnitDelay: '<S1060>/spdD3'
     */
    app_SfD_i(look1_iflf_binlxpw((real32_T)app_DW.spdD3_DSTATE,
               app_ConstP.uDLookupTable_bp01Data,
               app_ConstP.uDLookupTable_tableData_h, 15U),
              rtb_ARB_F_PCTWhlDrvnToq_sg, &rtb_ARB_F_PCTWhlDrvnToq_sg, 1.0E-5F);

    /* End of Outputs for SubSystem: '<S497>/SfD' */

    /* Sqrt: '<S497>/Sqrt' incorporates:
     *  Abs: '<S497>/Abs1'
     */
    DFIn_a_EstdVSELongtAccel_sg = sqrtf(fabsf(rtb_ARB_F_PCTWhlDrvnToq_sg));

    /* Saturate: '<S497>/Saturation' */
    if (DFIn_a_EstdVSELongtAccel_sg > 41.6666679F) {
      DFIn_a_EstdVSELongtAccel_sg = 41.6666679F;
    }

    /* End of Saturate: '<S497>/Saturation' */

    /* RelationalOperator: '<S497>/Relational Operator' */
    rtb_Compare_hj = (DFIn_a_EstdVSELongtAccel_sg < rtb_ACC_v_ACCSetSpd_sg);

    /* Switch: '<S497>/Switch' */
    if (rtb_Compare_hj) {
      /* Switch: '<S497>/Switch' */
      Switch = DFIn_a_EstdVSELongtAccel_sg;
    } else {
      /* Switch: '<S497>/Switch' */
      Switch = rtb_ACC_v_ACCSetSpd_sg;
    }

    /* End of Switch: '<S497>/Switch' */

    /* Sum: '<S495>/Minus' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Sum: '<S499>/Minus1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    nDLookupTable1 = (real32_T)app_DW.spdD3_DSTATE - Switch;

    /* Switch: '<S497>/Switch2' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Logic: '<S497>/Logical Operator'
     *  RelationalOperator: '<S497>/Relational Operator1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_DFIn_is_AEBPStsDsbl_bl = ((rtb_ACC_v_ACCSetSpd_sg >= (real32_T)
      app_DW.spdD3_DSTATE) && rtb_Compare_hj);

    /* Product: '<S156>/Product' incorporates:
     *  Constant: '<S92>/Constant3'
     *  Lookup_n-D: '<S156>/2-D Lookup Table'
     */
    rtb_Product_iz = look2_iflf_binlxpw(1.0F, rtb_t_min, app_ConstP.pooled78,
      app_ConstP.pooled43, app_ConstP.uDLookupTable_tableData_o,
      app_ConstP.pooled117, 3U) * rtb_a_Max_Modify;

    /* Switch: '<S495>/Switch' incorporates:
     *  Constant: '<S92>/Constant20'
     *  Constant: '<S92>/Constant22'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Gain: '<S155>/Gain2'
     *  Gain: '<S156>/Gain1'
     *  Gain: '<S495>/Gain'
     *  Gain: '<S495>/Gain1'
     *  Gain: '<S495>/Gain2'
     *  Lookup_n-D: '<S495>/n-D Lookup Table'
     *  Lookup_n-D: '<S495>/n-D Lookup Table1'
     *  Lookup_n-D: '<S495>/n-D Lookup Table2'
     *  MinMax: '<S155>/MinMax'
     *  MinMax: '<S156>/MinMax'
     *  MinMax: '<S495>/Max1'
     *  MinMax: '<S495>/Min1'
     *  Product: '<S495>/Product'
     *  Sum: '<S495>/Minus'
     *  Switch: '<S495>/Switch1'
     *  UnaryMinus: '<S495>/Unary Minus1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    if (rtb_DFIn_is_AEBPStsDsbl_bl) {
      rtb_a_Min_Modify = fmaxf(fmaxf(0.5F * rtb_Add_g0, -5.0F),
        look1_iflf_binlcpw(((real32_T)CV_mps2kph) * -nDLookupTable1,
                           app_ConstP.pooled52,
                           app_ConstP.nDLookupTable_tableData, 15U));
      rtb_a_Max_Modify = fminf(fminf(0.5F * rtb_Product_iz, 3.0F),
        look1_iflf_binlcpw(((real32_T)CV_mps2kph) * -nDLookupTable1,
                           app_ConstP.pooled52,
                           app_ConstP.nDLookupTable1_tableData, 15U) *
        look1_iflf_binlcpw(((real32_T)CV_mps2kph) * (real32_T)
                           app_DW.spdD3_DSTATE, app_ConstP.pooled52,
                           app_ConstP.nDLookupTable2_tableData, 15U));
    } else {
      rtb_a_Min_Modify = fmaxf(0.5F * rtb_Add_g0, -5.0F);
      rtb_a_Max_Modify = fminf(0.5F * rtb_Product_iz, 3.0F);
    }

    /* End of Switch: '<S495>/Switch' */

    /* Lookup_n-D: '<S158>/1-D Lookup Table' incorporates:
     *  Abs: '<S158>/Abs'
     *  DataTypeConversion: '<S1023>/Data Type Conversion30'
     *  Lookup_n-D: '<S159>/1-D Lookup Table'
     */
    rtb_a_traj_FEMid = look1_iflf_binlxpw(fabsf(rtb_Gain5_i),
      app_ConstP.pooled82, app_ConstP.pooled81, 5U);

    /* Delay: '<S150>/Resettable Delay' */
    if ((int32_T)app_DW.icLoad_bl != 0) {
      app_DW.ResettableDelay_DSTATE = rtb_ACC_v_ACCSetSpd_sg;
    }

    /* Sum: '<S150>/Add' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_MinMax1_p = rtb_ACC_v_ACCSetSpd_sg - (real32_T)app_DW.spdD3_DSTATE;

    /* Logic: '<S149>/Logical Operator3' incorporates:
     *  Constant: '<S149>/Constant4'
     *  Constant: '<S149>/k_V_ComftDecSpdThd_sg1'
     *  RelationalOperator: '<S149>/Relational Operator3'
     *  RelationalOperator: '<S149>/Relational Operator4'
     */
    rtb_DFIn_is_AEBStsDsbl_bl = ((rtb_MinMax1_p <= 0.0F) && (-30.0F <=
      rtb_MinMax1_p));

    /* Switch: '<S149>/Switch2' incorporates:
     *  Constant: '<S149>/Constant5'
     *  Constant: '<S154>/Constant'
     *  Delay: '<S150>/Resettable Delay'
     *  Logic: '<S149>/Logical Operator4'
     *  Logic: '<S149>/Logical Operator5'
     *  RelationalOperator: '<S154>/Compare'
     *  Sum: '<S150>/Add1'
     *  UnitDelay: '<S149>/Unit Delay1'
     */
    if ((rtb_ACC_v_ACCSetSpd_sg - app_DW.ResettableDelay_DSTATE < 0.0F) &&
        rtb_DFIn_is_AEBStsDsbl_bl) {
      app_DW.UnitDelay1_DSTATE_l = true;
    } else {
      app_DW.UnitDelay1_DSTATE_l = (rtb_DFIn_is_AEBStsDsbl_bl &&
        app_DW.UnitDelay1_DSTATE_l);
    }

    /* End of Switch: '<S149>/Switch2' */

    /* Switch: '<S152>/Switch' incorporates:
     *  Constant: '<S152>/k_V_OvrrdSpdGapThd_sg'
     *  Logic: '<S152>/Logical Operator'
     *  RelationalOperator: '<S152>/Relational Operator'
     *  UnitDelay: '<S152>/Unit Delay'
     */
    app_DW.UnitDelay_DSTATE_l = (rtb_DFIn_is_EPBAppcnStsApp_bl && (rtb_MinMax1_p
      <= -10.0F));

    /* Switch: '<S151>/Switch' incorporates:
     *  Constant: '<S151>/k_V_RsmSetSpdThd_sg'
     *  Constant: '<S151>/k_V_RsmSpdGapThd_sg'
     *  Logic: '<S151>/Logical Operator'
     *  RelationalOperator: '<S151>/Relational Operator'
     *  RelationalOperator: '<S151>/Relational Operator2'
     *  UnitDelay: '<S151>/Unit Delay'
     */
    app_DW.UnitDelay_DSTATE_g = ((rtb_ACC_v_ACCSetSpd_sg <= 20.0F) &&
      (rtb_MinMax1_p <= -10.0F));

    /* Lookup_n-D: '<S159>/1-D Lookup Table1' incorporates:
     *  Abs: '<S159>/Abs1'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_uDLookupTable5_h = look1_iflf_binlxpw(fabsf((real32_T)
      app_DW.spdD3_DSTATE), app_ConstP.uDLookupTable1_bp01Data,
      app_ConstP.pooled81, 5U);

    /* MinMax: '<S159>/MinMax' incorporates:
     *  Constant: '<S92>/Constant16'
     */
    rtb_MinMax_a0 = fminf(fminf(fminf(10.0F, rtb_a_traj_FEMid),
      rtb_uDLookupTable5_h), app_ConstB.MultiportSwitch_k);

    /* Delay: '<S144>/Resettable Delay1' */
    if ((int32_T)app_DW.icLoad_m != 0) {
      app_DW.ResettableDelay1_DSTATE = rtb_DFIn_is_EPBAppcnStsApp_bl;
    }

    /* RelationalOperator: '<S213>/Compare' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S213>/Constant'
     *  SignalConversion: '<S911>/Signal Copy4'
     */
    rtb_DFIn_is_AEBStsDsbl_bl = ((int32_T)rtb_out_cond_n3 != 0);

    /* Switch: '<S179>/Switch1' incorporates:
     *  Constant: '<S179>/character3'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv1'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv1ORG'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv2'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv2ORG'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv3'
     *  Lookup_n-D: '<S179>/FTCDsrdTmLv3ORG'
     *  Switch: '<S179>/Switch2'
     *  Switch: '<S179>/Switch4'
     *  UnitDelay: '<S1060>/spdD3'
     */
    if (k_TRPLon_is_FTCBMDsrdDistMdOn_bl) {
      rtb_ACC_t_FTCDsrdDistLv1_sg = look1_iflf_binlcpw((real32_T)
        app_DW.spdD3_DSTATE, k_TRPLon_TX_v_FTCDsrdDistBrkPnt_sg,
        k_TRPLon_TY_t_FTCDsrdDistLv1_sg, 13U);
      rtb_ACC_t_FTCDsrdDistLv2_sg = look1_iflf_binlcpw((real32_T)
        app_DW.spdD3_DSTATE, k_TRPLon_TX_v_FTCDsrdDistBrkPnt_sg,
        k_TRPLon_TY_t_FTCDsrdDistLv2_sg, 13U);
      rtb_MinMax1_p = look1_iflf_binlcpw((real32_T)app_DW.spdD3_DSTATE,
        k_TRPLon_TX_v_FTCDsrdDistBrkPnt_sg, k_TRPLon_TY_t_FTCDsrdDistLv3_sg, 13U);
    } else {
      rtb_ACC_t_FTCDsrdDistLv1_sg = look1_iflf_binlcpw((real32_T)
        app_DW.spdD3_DSTATE, k_TRPLon_TX_v_FTCdDesSpdNorm_sg,
        k_TRPLon_TY_t_FTCdDesDistLv1_sg, 13U);
      rtb_ACC_t_FTCDsrdDistLv2_sg = look1_iflf_binlcpw((real32_T)
        app_DW.spdD3_DSTATE, k_TRPLon_TX_v_FTCdDesSpdNorm_sg,
        k_TRPLon_TY_t_FTCdDesDistLv2_sg, 13U);
      rtb_MinMax1_p = look1_iflf_binlcpw((real32_T)app_DW.spdD3_DSTATE,
        k_TRPLon_TX_v_FTCdDesSpdNorm_sg, k_TRPLon_TY_t_FTCdDesDistLv3_sg, 13U);
    }

    /* End of Switch: '<S179>/Switch1' */

    /* Chart: '<S147>/ACC_t_DsrdTm' */
    switch (rtb_ACC_indx_DISTmDist_en) {
     case DSL_DistLvl3:
      break;

     case DSL_DistLvl2:
      rtb_MinMax1_p = rtb_ACC_t_FTCDsrdDistLv2_sg;
      break;

     case DSL_DistLvl1:
      rtb_MinMax1_p = rtb_ACC_t_FTCDsrdDistLv1_sg;
      break;
     default: break;
    }

    /* End of Chart: '<S147>/ACC_t_DsrdTm' */

    /* Abs: '<S188>/Abs' incorporates:
     *  Abs: '<S189>/Abs'
     *  Inport: '<Root>/Obj_01_a'
     */
    rtb_Product_eqe = fabsf(arg_Obj_01_a);

    /* Sum: '<S188>/Add1' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Inport: '<Root>/Obj_01_v'
     *  Sum: '<S187>/Subtract1'
     *  Sum: '<S239>/Minus'
     *  Switch: '<S148>/Switch'
     *  Switch: '<S148>/Switch1'
     *  Switch: '<S187>/Switch'
     *  Switch: '<S187>/Switch1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_ACC_t_FTCDsrdDistLv1_sg = arg_Obj_01_v - (real32_T)app_DW.spdD3_DSTATE;

    /* Logic: '<S188>/Logical Operator1' incorporates:
     *  Abs: '<S188>/Abs'
     *  Constant: '<S188>/k_a_EgoVehStartMove_sg'
     *  Constant: '<S188>/k_v_EgoVehLowSpd_sg'
     *  Constant: '<S188>/k_v_SpdGapObjBigEgo_sg'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  RelationalOperator: '<S188>/Relational Operator1'
     *  RelationalOperator: '<S188>/Relational Operator5'
     *  RelationalOperator: '<S188>/Relational Operator6'
     *  Sum: '<S188>/Add1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_LogicalOperator9_kf = ((rtb_ACC_t_FTCDsrdDistLv1_sg >= 2.0F) &&
      ((real32_T)app_DW.spdD3_DSTATE <= 5.0F) && (rtb_Product_eqe >= 0.5F));

    /* Switch: '<S192>/Switch' incorporates:
     *  Lookup_n-D: '<S182>/2-D Lookup Table1'
     *  UnitDelay: '<S192>/Unit Delay'
     */
    if (rtb_LogicalOperator9_kf) {
      app_DW.UnitDelay_DSTATE_e = look2_iflf_binlxpw(rtb_MinMax1_p, rtb_t_min,
        app_ConstP.pooled42, app_ConstP.pooled43,
        app_ConstP.uDLookupTable1_tableData, app_ConstP.pooled116, 7U);
    }

    /* Chart: '<S192>/GainForStartStop' incorporates:
     *  Constant: '<S188>/k_d_DiffTmGapRampRate_sg'
     *  Constant: '<S192>/RateLimitDown'
     */
    if ((uint32_T)app_DW.is_active_c57_app == 0U) {
      app_DW.is_active_c57_app = 1U;
      app_DW.is_c57_app = app_IN_Stop_g;
      app_B.GainForStartStop = 0.0F;
    } else {
      switch (app_DW.is_c57_app) {
       case app_IN_CountDown:
        if (rtb_LogicalOperator9_kf) {
          app_DW.is_c57_app = app_IN_Start;
          app_B.GainForStartStop = 1.0F;
        } else if (app_B.GainForStartStop <= 0.0F) {
          app_DW.is_c57_app = app_IN_Stop_g;
          app_B.GainForStartStop = 0.0F;
        } else {
          app_B.GainForStartStop--;
        }
        break;

       case app_IN_CountUp:
        if (!rtb_LogicalOperator9_kf) {
          app_DW.is_c57_app = app_IN_Stop_g;
          app_B.GainForStartStop = 0.0F;
        } else if (app_B.GainForStartStop >= 1.0F) {
          app_DW.is_c57_app = app_IN_Start;
          app_B.GainForStartStop = 1.0F;
        } else {
          app_B.GainForStartStop += 0.5F;
        }
        break;

       case app_IN_Start:
        if (!rtb_LogicalOperator9_kf) {
          app_DW.is_c57_app = app_IN_CountDown;
          app_B.GainForStartStop--;
        }
        break;

       default:
        /* case IN_Stop: */
        if (rtb_LogicalOperator9_kf) {
          app_DW.is_c57_app = app_IN_CountUp;
          app_B.GainForStartStop += 0.5F;
        }
        break;
      }
    }

    /* End of Chart: '<S192>/GainForStartStop' */

    /* Saturate: '<S192>/Saturation' */
    if (app_B.GainForStartStop > 1.0F) {
      rtb_t_min = 1.0F;
    } else if (app_B.GainForStartStop < 0.0F) {
      rtb_t_min = 0.0F;
    } else {
      rtb_t_min = app_B.GainForStartStop;
    }

    /* End of Saturate: '<S192>/Saturation' */

    /* Delay: '<S185>/Resettable Delay2' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  SignalConversion: '<S911>/Signal Copy4'
     */
    if ((int32_T)app_DW.icLoad_l4 != 0) {
      app_DW.ResettableDelay2_DSTATE_l = rtb_out_cond_n3;
    }

    /* Logic: '<S185>/AND' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Delay: '<S185>/Resettable Delay2'
     *  RelationalOperator: '<S185>/Relational Operator'
     *  SignalConversion: '<S911>/Signal Copy4'
     */
    rtb_OR_f = ((app_DW.ResettableDelay2_DSTATE_l != rtb_out_cond_n3) &&
                rtb_DFIn_is_AEBStsDsbl_bl);

    /* Chart: '<S147>/ACC_d_DistMinGap' incorporates:
     *  Constant: '<S147>/P_ACC_v_MaxCrsSpdThrs_u4'
     *  Constant: '<S147>/P_ACC_v_MaxCrsSpdThrs_u5'
     *  Constant: '<S147>/P_ACC_v_MaxCrsSpdThrs_u6'
     */
    switch (rtb_ACC_indx_DISTmDist_en) {
     case DSL_DistLvl3:
      rtb_ACC_t_FTCDsrdDistLv2_sg = k_TRPLon_d_DistMinGapFar_sg;
      break;

     case DSL_DistLvl2:
      rtb_ACC_t_FTCDsrdDistLv2_sg = k_TRPLon_d_DistMinGapMid_sg;
      break;

     case DSL_DistLvl1:
      rtb_ACC_t_FTCDsrdDistLv2_sg = k_TRPLon_d_DistMinGapNear_sg;
      break;

     default:
      rtb_ACC_t_FTCDsrdDistLv2_sg = k_TRPLon_d_DistMinGapFar_sg;
      break;
    }

    /* End of Chart: '<S147>/ACC_d_DistMinGap' */

    /* Switch: '<S191>/Switch' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S191>/Constant'
     *  Constant: '<S191>/v1_mps'
     *  Constant: '<S191>/v2_mps'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S191>/AND'
     *  RelationalOperator: '<S191>/Relational Operator'
     *  RelationalOperator: '<S191>/Relational Operator1'
     *  RelationalOperator: '<S191>/Relational Operator2'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Switch: '<S191>/Switch1'
     */
    if ((rtb_uDLookupTable <= 15.0F) && (arg_Obj_01_v <= 1.0F)) {
      rtb_Switch_ai = rtb_ACC_t_FTCDsrdDistLv2_sg;
    } else if (arg_Obj_01_v <= 5.0F) {
      /* Switch: '<S191>/Switch1' incorporates:
       *  Constant: '<S191>/Constant1'
       *  Gain: '<S191>/Gain1'
       *  Lookup_n-D: '<S191>/1-D Lookup Table'
       *  Product: '<S191>/Product'
       */
      rtb_Switch_ai = look1_iflf_binlxpw(3.6F * arg_Obj_01_v,
        app_ConstP.pooled45, app_ConstP.pooled44, 10U) *
        k_TRPLon_Gx_DesireDistLowSpd_sg;
    } else {
      /* Switch: '<S191>/Switch1' incorporates:
       *  Constant: '<S191>/Constant2'
       *  Gain: '<S191>/Gain'
       *  Lookup_n-D: '<S191>/2-D Lookup Table'
       *  Product: '<S191>/Product1'
       */
      rtb_Switch_ai = look2_iflf_binlxpw(rtb_MinMax1_p, 3.6F * arg_Obj_01_v,
        app_ConstP.pooled42, app_ConstP.pooled43, app_ConstP.pooled46,
        app_ConstP.pooled116, 7U) * k_TRPLon_Gx_DesireDistHiSpd_sg;
    }

    /* End of Switch: '<S191>/Switch' */

    /* Outputs for Atomic SubSystem: '<S191>/EnDRL' */
    /* SignalConversion generated from: '<S191>/EnDRL' incorporates:
     *  Constant: '<S191>/Constant3'
     */
    app_EnDRL(rtb_Switch_ai, rtb_Switch_ai, rtb_DFIn_is_AEBStsDsbl_bl, 2.5F,
              app_ConstB.UnaryMinus_l, &rtb_Switch_ik, &app_DW.EnDRL_d,
              &app_PrevZCX.EnDRL_d, 0.01F);

    /* End of Outputs for SubSystem: '<S191>/EnDRL' */

    /* Outputs for Atomic SubSystem: '<S190>/EnDRL' */
    /* SignalConversion generated from: '<S190>/EnDRL' incorporates:
     *  Constant: '<S190>/k_v_NormlFollVeh_sg'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S190>/Logical Operator'
     *  Logic: '<S190>/Logical Operator1'
     *  RelationalOperator: '<S190>/Relational Operator'
     *  UnaryMinus: '<S190>/Unary Minus'
     */
    app_EnDRL(rtb_Switch_ik, rtb_Switch_ik, (!rtb_OR_f) && (7.0F <= arg_Obj_01_v),
              arg_Obj_01_v, -arg_Obj_01_v, &rtb_Switch_ai, &app_DW.EnDRL,
              &app_PrevZCX.EnDRL, 0.01F);

    /* End of Outputs for SubSystem: '<S190>/EnDRL' */

    /* Outputs for Atomic SubSystem: '<S189>/EnDRL1' */
    /* SignalConversion generated from: '<S189>/EnDRL1' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S189>/k_d_BigDeltaDst_sg'
     *  Constant: '<S189>/k_v_EgoVehFllwStpdVeh_sg'
     *  Constant: '<S189>/k_v_TgtVehStopped_sg'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S189>/Logical Operator2'
     *  Logic: '<S189>/Logical Operator3'
     *  RelationalOperator: '<S189>/Relational Operator1'
     *  RelationalOperator: '<S189>/Relational Operator2'
     *  RelationalOperator: '<S189>/Relational Operator3'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Sum: '<S189>/Add'
     *  UnaryMinus: '<S189>/Unary Minus1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    app_EnDRL(rtb_Switch_ai, rtb_Switch_ai, (rtb_uDLookupTable - rtb_Switch_ai >=
               20.0F) && (arg_Obj_01_v <= 1.0F) && (!rtb_OR_f) && (10.0F <=
               (real32_T)app_DW.spdD3_DSTATE), (real32_T)app_DW.spdD3_DSTATE,
              -(real32_T)app_DW.spdD3_DSTATE, &rtb_Switch_ik, &app_DW.EnDRL1,
              &app_PrevZCX.EnDRL1, 0.01F);

    /* End of Outputs for SubSystem: '<S189>/EnDRL1' */

    /* Switch: '<S189>/Switch' incorporates:
     *  Constant: '<S189>/k_a_EgoVehLowAcc_sg'
     *  Constant: '<S189>/k_v_EgoVehLowSpd_sg'
     *  Constant: '<S189>/k_v_TgtVehStopped_sg1'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Delay: '<S189>/Resettable Delay'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S189>/Logical Operator4'
     *  Logic: '<S189>/Logical Operator5'
     *  RelationalOperator: '<S189>/Relational Operator4'
     *  RelationalOperator: '<S189>/Relational Operator5'
     *  RelationalOperator: '<S189>/Relational Operator6'
     *  UnitDelay: '<S1060>/spdD3'
     */
    if (rtb_OR_f || (!(rtb_Product_eqe <= 2.0F)) || (!((real32_T)
          app_DW.spdD3_DSTATE <= 5.0F)) || (!(arg_Obj_01_v <= 1.0F))) {
      app_DW.ResettableDelay_DSTATE_l = rtb_Switch_ik;
    }

    /* End of Switch: '<S189>/Switch' */

    /* Sum: '<S192>/Add1' incorporates:
     *  Constant: '<S192>/Constant'
     *  Delay: '<S189>/Resettable Delay'
     *  Product: '<S192>/Product1'
     *  Product: '<S192>/Product2'
     *  Sum: '<S192>/Add'
     *  UnitDelay: '<S192>/Unit Delay'
     */
    rtb_t_min = (1.0F - rtb_t_min) * app_DW.ResettableDelay_DSTATE_l +
      app_DW.UnitDelay_DSTATE_e * rtb_t_min;

    /* Product: '<S201>/Product' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S201>/k_Cof_ComftSafeGap_sg'
     *  SignalConversion: '<S911>/Signal Copy2'
     */
    rtb_Product_eqe = rtb_uDLookupTable * 0.2F;

    /* Switch: '<S201>/Switch' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S201>/Constant'
     *  Constant: '<S201>/v1_mps'
     *  Constant: '<S201>/v2_mps'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S201>/AND'
     *  RelationalOperator: '<S201>/Relational Operator'
     *  RelationalOperator: '<S201>/Relational Operator1'
     *  RelationalOperator: '<S201>/Relational Operator2'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Switch: '<S201>/Switch1'
     */
    if ((rtb_uDLookupTable <= 15.0F) && (arg_Obj_01_v <= 1.0F)) {
      rtb_ARB_F_PCTWhlDrvnToq_sg = rtb_ACC_t_FTCDsrdDistLv2_sg;
    } else if (arg_Obj_01_v <= 5.0F) {
      /* Switch: '<S201>/Switch1' incorporates:
       *  Constant: '<S201>/Constant1'
       *  Gain: '<S201>/Gain1'
       *  Lookup_n-D: '<S201>/1-D Lookup Table1'
       *  Product: '<S201>/Product1'
       */
      rtb_ARB_F_PCTWhlDrvnToq_sg = look1_iflf_binlxpw(3.6F * arg_Obj_01_v,
        app_ConstP.pooled45, app_ConstP.pooled44, 10U) *
        k_TRPLon_Gx_DesireDistLowSpd_sg;
    } else {
      /* Switch: '<S201>/Switch1' incorporates:
       *  Constant: '<S201>/Constant2'
       *  Gain: '<S201>/Gain'
       *  Lookup_n-D: '<S201>/2-D Lookup Table'
       *  Product: '<S201>/Product2'
       */
      rtb_ARB_F_PCTWhlDrvnToq_sg = look2_iflf_binlxpw(rtb_MinMax1_p, 3.6F *
        arg_Obj_01_v, app_ConstP.pooled42, app_ConstP.pooled43,
        app_ConstP.pooled46, app_ConstP.pooled116, 7U) *
        k_TRPLon_Gx_DesireDistHiSpd_sg;
    }

    /* End of Switch: '<S201>/Switch' */

    /* Gain: '<S201>/Gain3' */
    rtb_Switch_ik = 0.9F * rtb_ARB_F_PCTWhlDrvnToq_sg;

    /* Delay: '<S200>/Resettable Delay' */
    if ((int32_T)app_DW.icLoad_ba != 0) {
      app_DW.ResettableDelay_DSTATE_ll = rtb_MinMax1_p;
    }

    /* Delay: '<S202>/Resettable Delay' */
    if ((int32_T)app_DW.icLoad_en != 0) {
      app_DW.ResettableDelay_DSTATE_h = rtb_DFIn_is_EPBAppcnStsApp_bl;
    }

    /* RelationalOperator: '<S203>/Compare' */
    rtb_LogicalOperator9_kf = !rtb_DFIn_is_EPBAppcnStsApp_bl;

    /* Logic: '<S200>/Logical Operator' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S200>/k_d_MinDstTargetThrld_sg'
     *  Delay: '<S200>/Resettable Delay'
     *  Delay: '<S200>/Resettable Delay1'
     *  Delay: '<S202>/Resettable Delay'
     *  Logic: '<S200>/Logical Operator1'
     *  Logic: '<S202>/Logical Operator'
     *  RelationalOperator: '<S200>/Relational Operator'
     *  RelationalOperator: '<S200>/Relational Operator1'
     *  RelationalOperator: '<S200>/Relational Operator2'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Sum: '<S200>/Add'
     */
    app_DW.ResettableDelay1_DSTATE_b = ((rtb_Switch_ik > rtb_Product_eqe) &&
      (rtb_uDLookupTable - rtb_t_min < 2.0F) && (rtb_OR_f || (rtb_MinMax1_p >
      app_DW.ResettableDelay_DSTATE_ll) || (app_DW.ResettableDelay_DSTATE_h &&
      rtb_LogicalOperator9_kf) || app_DW.ResettableDelay1_DSTATE_b));

    /* Switch: '<S148>/Switch1' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S148>/Constant1'
     *  Constant: '<S148>/Constant3'
     *  SignalConversion: '<S911>/Signal Copy4'
     *  Switch: '<S148>/Switch'
     *  Switch: '<S187>/Switch'
     *  Switch: '<S187>/Switch1'
     */
    if (k_TRPLon_is_UsedDesire0_bl) {
      rtb_Switch1_g[0] = rtb_t_min;

      /* Switch: '<S183>/Switch' incorporates:
       *  Delay: '<S200>/Resettable Delay1'
       */
      if (app_DW.ResettableDelay1_DSTATE_b) {
        rtb_Switch1_g[1] = rtb_Product_eqe;
      } else {
        rtb_Switch1_g[1] = rtb_Switch_ik;
      }

      /* End of Switch: '<S183>/Switch' */
    } else if (k_TRPLon_is_UsedDesire1_bl) {
      /* Switch: '<S186>/Switch2' incorporates:
       *  BusAssignment: '<S5>/Bus Assignment'
       *  Constant: '<S186>/Constant2'
       *  Constant: '<S186>/comfort_brake'
       *  Constant: '<S186>/comfort_brake1'
       *  DataTypeConversion: '<S1060>/Data Type Conversion7'
       *  Gain: '<S186>/Gain'
       *  Gain: '<S186>/Gain1'
       *  Inport: '<Root>/Obj_01_v'
       *  Math: '<S186>/Square1'
       *  Math: '<S186>/Square2'
       *  Product: '<S186>/Divide'
       *  Product: '<S186>/Divide1'
       *  Product: '<S186>/Product'
       *  SignalConversion: '<S911>/Signal Copy4'
       *  Sum: '<S186>/Add'
       *  Sum: '<S186>/Subtract'
       *  Switch: '<S148>/Switch'
       *  UnitDelay: '<S1060>/spdD3'
       */
      if ((int32_T)rtb_out_cond_n3 != 0) {
        rtb_t_min = (((real32_T)app_DW.spdD3_DSTATE * (real32_T)
                      app_DW.spdD3_DSTATE / (2.0F * k_TRPLon_a_ComfortBrake_sg)
                      + (real32_T)app_DW.spdD3_DSTATE * rtb_MinMax1_p) +
                     rtb_ACC_t_FTCDsrdDistLv2_sg) - arg_Obj_01_v * arg_Obj_01_v /
          (2.0F * k_TRPLon_a_ComfortBrake_sg);
      } else {
        rtb_t_min = 0.0F;
      }

      /* End of Switch: '<S186>/Switch2' */

      /* Switch: '<S148>/Switch' incorporates:
       *  Gain: '<S186>/Gain2'
       */
      rtb_Switch1_g[0] = rtb_t_min;
      rtb_Switch1_g[1] = 0.9F * rtb_t_min;
    } else {
      if ((int32_T)rtb_out_cond_n3 != 0) {
        /* Switch: '<S187>/Switch' incorporates:
         *  Constant: '<S187>/Constant2'
         *  DataTypeConversion: '<S1060>/Data Type Conversion7'
         *  Product: '<S187>/Product'
         *  Product: '<S187>/Product3'
         *  Sum: '<S187>/Add1'
         *  Sum: '<S187>/Add2'
         *  Switch: '<S148>/Switch'
         *  Switch: '<S187>/Switch1'
         *  UnitDelay: '<S1060>/spdD3'
         */
        rtb_t_min = (rtb_MinMax1_p * (real32_T)app_DW.spdD3_DSTATE +
                     rtb_ACC_t_FTCDsrdDistLv2_sg) - rtb_ACC_t_FTCDsrdDistLv1_sg *
          k_TRPLon_t_RelDistPrdctTmVx_sg;
      } else {
        /* Switch: '<S187>/Switch1' incorporates:
         *  Constant: '<S187>/Constant5'
         *  Switch: '<S148>/Switch'
         */
        rtb_t_min = 0.0F;
      }

      /* Switch: '<S148>/Switch' incorporates:
       *  Gain: '<S187>/Gain3'
       */
      rtb_Switch1_g[0] = rtb_t_min;
      rtb_Switch1_g[1] = 0.9F * rtb_t_min;
    }

    /* Switch: '<S181>/Switch' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S92>/Constant1'
     *  MinMax: '<S180>/MinMax'
     *  MinMax: '<S180>/MinMax1'
     *  MinMax: '<S181>/MinMax'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Sum: '<S180>/Add'
     *  Sum: '<S180>/Add1'
     *  Sum: '<S92>/Subtract'
     */
    m_dst_target = fminf(fminf(fminf(rtb_uDLookupTable - rtb_Switch1_g[1],
      rtb_uDLookupTable - 3.0F), rtb_uDLookupTable - rtb_Switch1_g[0]),
                         rtb_uDLookupTable - 3.0F);

    /* Switch: '<S145>/Switch' incorporates:
     *  Chart: '<S145>/Chart2'
     *  Constant: '<S91>/Constant'
     *  Inport: '<Root>/Obj_01_v'
     *  Logic: '<S145>/NOT'
     *  RelationalOperator: '<S3>/Relational Operator'
     */
    if (!(rtb_DataTypeConversion45 == VSL_Standstill)) {
      /* Chart: '<S145>/Chart' incorporates:
       *  DataTypeConversion: '<S1060>/Data Type Conversion7'
       *  Inport: '<Root>/Obj_01_a'
       *  Inport: '<Root>/Obj_01_v'
       *  UnitDelay: '<S1060>/spdD3'
       */
      if ((((real32_T)app_DW.spdD3_DSTATE < 2.0F) && (rtb_ACC_v_ACCSetSpd_sg ==
            0.0F)) || (rtb_DFIn_is_AEBStsDsbl_bl && (arg_Obj_01_v < 3.5F) &&
                       (m_dst_target < 5.0F) && (arg_Obj_01_a < 0.0F))) {
        rtb_Switch_jk = LowSpeed2StandStill;
      } else if (((real32_T)app_DW.spdD3_DSTATE < 2.0F) &&
                 ((rtb_ACC_v_ACCSetSpd_sg < 50.0F) || (rtb_DFIn_is_AEBStsDsbl_bl
        && (arg_Obj_01_v < 10.0F) && (m_dst_target < 30.0F)))) {
        rtb_Switch_jk = LowSpeed_Driving;
      } else {
        rtb_Switch_jk = Normal_Driving;
      }

      /* End of Chart: '<S145>/Chart' */
    } else if ((rtb_ACC_v_ACCSetSpd_sg > 0.0F) && ((!rtb_DFIn_is_AEBStsDsbl_bl) ||
                (rtb_DFIn_is_AEBStsDsbl_bl && (arg_Obj_01_v > 1.0F) &&
                 (m_dst_target > 20.0F)))) {
      /* Chart: '<S145>/Chart2' */
      rtb_Switch_jk = StandStill2Driving;
    } else {
      rtb_Switch_jk = StandStill;
    }

    /* End of Switch: '<S145>/Switch' */

    /* Delay: '<S144>/Resettable Delay2' */
    if ((int32_T)app_DW.icLoad_g5 != 0) {
      app_DW.ResettableDelay2_DSTATE = rtb_Switch_jk;
    }

    /* Delay: '<S144>/Resettable Delay4' incorporates:
     *  UnitDelay: '<S151>/Unit Delay'
     */
    if ((int32_T)app_DW.icLoad_cbj != 0) {
      app_DW.ResettableDelay4_DSTATE = app_DW.UnitDelay_DSTATE_g;
    }

    /* Delay: '<S144>/Resettable Delay5' incorporates:
     *  UnitDelay: '<S152>/Unit Delay'
     */
    if ((int32_T)app_DW.icLoad_cj != 0) {
      app_DW.ResettableDelay5_DSTATE = app_DW.UnitDelay_DSTATE_l;
    }

    /* Logic: '<S144>/Logical Operator6' incorporates:
     *  Constant: '<S169>/Constant'
     *  Constant: '<S170>/Constant'
     *  Constant: '<S92>/Constant3'
     *  Delay: '<S144>/Resettable Delay1'
     *  Delay: '<S144>/Resettable Delay2'
     *  Delay: '<S144>/Resettable Delay4'
     *  Delay: '<S144>/Resettable Delay5'
     *  Logic: '<S144>/Logical Operator1'
     *  Logic: '<S144>/Logical Operator2'
     *  Logic: '<S144>/Logical Operator4'
     *  Logic: '<S144>/Logical Operator5'
     *  RelationalOperator: '<S144>/Relational Operator'
     *  RelationalOperator: '<S144>/Relational Operator1'
     *  RelationalOperator: '<S163>/Compare'
     *  RelationalOperator: '<S165>/Compare'
     *  RelationalOperator: '<S167>/FixPt Relational Operator'
     *  RelationalOperator: '<S168>/FixPt Relational Operator'
     *  UnitDelay: '<S151>/Unit Delay'
     *  UnitDelay: '<S152>/Unit Delay'
     *  UnitDelay: '<S167>/Delay Input1'
     *  UnitDelay: '<S168>/Delay Input1'
     *
     * Block description for '<S167>/Delay Input1':
     *
     *  Store in Global RAM
     *
     * Block description for '<S168>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_LogicalOperator9_kf = (((int32_T)longt_out_isCtrlEngage > (int32_T)
      app_DW.DelayInput1_DSTATE_on) || (1.0F != app_DW.DelayInput1_DSTATE) ||
      (app_DW.ResettableDelay1_DSTATE && rtb_LogicalOperator9_kf) ||
      ((app_DW.ResettableDelay2_DSTATE == StandStill) && (rtb_Switch_jk ==
      StandStill2Driving)) || ((!app_DW.ResettableDelay4_DSTATE) &&
      app_DW.UnitDelay_DSTATE_g) || ((!app_DW.ResettableDelay5_DSTATE) &&
      app_DW.UnitDelay_DSTATE_l));

    /* Gain: '<S497>/Gain1' */
    DFIn_a_EstdVSELongtAccel_sg *= 3.6F;

    /* DataTypeConversion: '<S497>/Data Type Conversion1' */
    DFIn_a_EstdVSELongtAccel_sg = floorf(DFIn_a_EstdVSELongtAccel_sg);
    if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg)) {
      DFIn_a_EstdVSELongtAccel_sg = 0.0F;
    } else {
      DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 256.0F);
    }

    /* Delay: '<S497>/Resettable Delay' incorporates:
     *  DataTypeConversion: '<S497>/Data Type Conversion1'
     */
    if ((int32_T)app_DW.icLoad_g53 != 0) {
      app_DW.ResettableDelay_DSTATE_g = (uint8_T)DFIn_a_EstdVSELongtAccel_sg;
    }

    /* DataTypeConversion: '<S497>/Data Type Conversion' incorporates:
     *  Gain: '<S497>/Gain'
     */
    rtb_Product_eqe = floorf(3.6F * rtb_ACC_v_ACCSetSpd_sg);
    if (rtIsNaNF(rtb_Product_eqe) || rtIsInfF(rtb_Product_eqe)) {
      rtb_Product_eqe = 0.0F;
    } else {
      rtb_Product_eqe = fmodf(rtb_Product_eqe, 256.0F);
    }

    P_ACC_V_MaxCrsSpdThrs_u8 = (uint8_T)(rtb_Product_eqe < 0.0F ? (int32_T)
      (uint8_T)(int32_T)-(int32_T)(int8_T)(uint8_T)-rtb_Product_eqe : (int32_T)
      (uint8_T)rtb_Product_eqe);

    /* End of DataTypeConversion: '<S497>/Data Type Conversion' */

    /* Logic: '<S497>/Logical Operator1' incorporates:
     *  Constant: '<S497>/Constant'
     *  DataTypeConversion: '<S497>/Data Type Conversion1'
     *  Delay: '<S497>/Resettable Delay'
     *  Logic: '<S497>/Logical Operator2'
     *  RelationalOperator: '<S497>/Relational Operator2'
     *  RelationalOperator: '<S504>/FixPt Relational Operator'
     *  Sum: '<S497>/Add'
     *  UnitDelay: '<S504>/Delay Input1'
     *
     * Block description for '<S504>/Delay Input1':
     *
     *  Store in Global RAM
     */
    rtb_Compare_hj = ((((int32_T)(uint8_T)(int32_T)((int32_T)(uint8_T)
      DFIn_a_EstdVSELongtAccel_sg - (int32_T)app_DW.ResettableDelay_DSTATE_g) >=
                        5) && rtb_Compare_hj) || (P_ACC_V_MaxCrsSpdThrs_u8 !=
      app_DW.DelayInput1_DSTATE_mr));

    /* Chart: '<S501>/Chart1' incorporates:
     *  Constant: '<S501>/Constant1'
     *  Constant: '<S501>/Constant2'
     *  Logic: '<S501>/Logical Operator1'
     *  UnitDelay: '<S501>/Unit Delay3'
     */
    app_Chart1(app_DW.UnitDelay3_DSTATE_o || rtb_Compare_hj,
               k_TRP_t_NrmRplnTm_sg, 0.05F, &rtb_SeatBeltOn_o,
               &app_DW.sf_Chart1_i);

    /* RelationalOperator: '<S528>/Compare' incorporates:
     *  Constant: '<S528>/Constant'
     *  UnitDelay: '<S501>/Unit Delay2'
     */
    rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = ((int32_T)app_DW.UnitDelay2_DSTATE_m == 2);

    /* UnitDelay: '<S137>/Unit Delay' incorporates:
     *  UnitDelay: '<S501>/Unit Delay2'
     */
    app_DW.UnitDelay2_DSTATE_m = m_Followed_Traj;

    /* Chart: '<S501>/Chart2' incorporates:
     *  Constant: '<S501>/Constant3'
     *  Constant: '<S501>/Constant4'
     *  Constant: '<S501>/Constant5'
     *  Constant: '<S529>/Constant'
     *  Constant: '<S531>/Constant'
     *  Logic: '<S501>/AND'
     *  Logic: '<S501>/Logical Operator'
     *  Logic: '<S501>/Logical Operator2'
     *  RelationalOperator: '<S501>/Relational Operator'
     *  RelationalOperator: '<S501>/Relational Operator1'
     *  RelationalOperator: '<S529>/Compare'
     *  UnitDelay: '<S501>/Unit Delay'
     *  UnitDelay: '<S501>/Unit Delay2'
     *  UnitDelay: '<S501>/Unit Delay4'
     */
    app_Chart1(((app_DW.UnitDelay_DSTATE_f <= 0.1F) && (app_DW.UnitDelay4_DSTATE
      == RPL_KeepTrj)) || (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m && ((int32_T)
      app_DW.UnitDelay2_DSTATE_m == 1)), k_TRP_t_NrmRplnTm_sg, 0.05F,
               &rtb_Compare_hj, &app_DW.sf_Chart2_g);

    /* Chart: '<S501>/Chart' incorporates:
     *  Logic: '<S501>/Logical Operator3'
     */
    app_Chart_b(longt_out_isCtrlEngage, rtb_LogicalOperator9_kf,
                rtb_SeatBeltOn_o, rtb_Compare_hj, &m_TRP_Replan_Level_Spd);

    /* Lookup_n-D: '<S500>/n-D Lookup Table5' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Lookup_n-D: '<S500>/n-D Lookup Table2'
     *  Lookup_n-D: '<S500>/n-D Lookup Table3'
     *  Lookup_n-D: '<S500>/n-D Lookup Table4'
     *  UnitDelay: '<S1060>/spdD3'
     */
    rtb_ACC_t_FTCDsrdDistLv2_sg = look1_iflf_binlxpw((real32_T)
      app_DW.spdD3_DSTATE, app_ConstP.pooled52, app_ConstP.pooled84, 15U);

    /* Switch: '<S500>/Switch' incorporates:
     *  Constant: '<S500>/Constant1'
     *  Constant: '<S500>/Constant2'
     *  UnitDelay: '<S500>/Unit Delay'
     */
    if (app_DW.UnitDelay_DSTATE_fl) {
      rtb_Product_eqe = 1.25F;
    } else {
      rtb_Product_eqe = 1.0F;
    }

    /* End of Switch: '<S500>/Switch' */

    /* Product: '<S500>/Product' incorporates:
     *  Gain: '<S500>/Gain1'
     */
    rtb_Product_eqe *= 20.0F * rtb_ACC_t_FTCDsrdDistLv2_sg;

    /* Logic: '<S176>/OR' incorporates:
     *  Constant: '<S176>/Constant1'
     *  RelationalOperator: '<S176>/Relational Operator'
     *  UnitDelay: '<S176>/Unit Delay'
     */
    rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = ((app_DW.UnitDelay_DSTATE_p >= 100000.0F)
      || rtb_LogicalOperator9_kf);

    /* Delay: '<S176>/Resettable Delay' */
    if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m && ((int32_T)
         app_PrevZCX.ResettableDelay_Reset_ZCE != 1)) {
      app_DW.ResettableDelay_DSTATE_d = 0.0F;
    }

    app_PrevZCX.ResettableDelay_Reset_ZCE = (ZCSigState)
      rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m;

    /* Sum: '<S176>/Add' incorporates:
     *  Constant: '<S176>/Constant'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Delay: '<S176>/Resettable Delay'
     *  Product: '<S176>/Product'
     *  UnitDelay: '<S1060>/spdD3'
     */
    app_DW.ResettableDelay_DSTATE_d += (real32_T)app_DW.spdD3_DSTATE * 0.05F;

    /* Switch: '<S176>/Switch' incorporates:
     *  DataTypeConversion: '<S1023>/Data Type Conversion30'
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Delay: '<S176>/Resettable Delay'
     *  UnitDelay: '<S1060>/spdD3'
     *  UnitDelay: '<S92>/Unit Delay2'
     */
    if (rtb_LogicalOperator9_kf) {
      app_DW.UnitDelay_DSTATE_i5 = app_DW.ResettableDelay_DSTATE_d;
      app_DW.UnitDelay1_DSTATE_c = (real32_T)app_DW.spdD3_DSTATE;
      rtb_t_min = rtb_Gain5_i;
    } else {
      rtb_t_min = app_DW.UnitDelay2_DSTATE_p;
    }

    /* MultiPortSwitch: '<S499>/Multiport Switch' */
    switch (m_TRP_Replan_Level_Spd) {
     case RPL_Disable:
      /* MultiPortSwitch: '<S499>/Multiport Switch' incorporates:
       *  Constant: '<S499>/Constant3'
       */
      MultiportSwitch[0] = 0.0F;
      MultiportSwitch[1] = 0.0F;
      MultiportSwitch[2] = 0.0F;
      break;

     case RPL_Init:
      /* MultiPortSwitch: '<S499>/Multiport Switch' incorporates:
       *  DataTypeConversion: '<S1023>/Data Type Conversion30'
       *  Delay: '<S176>/Resettable Delay'
       */
      MultiportSwitch[0] = app_DW.ResettableDelay_DSTATE_d;
      MultiportSwitch[1] = nDLookupTable1;
      MultiportSwitch[2] = rtb_Gain5_i;
      break;

     case RPL_RePlan:
      /* MultiPortSwitch: '<S499>/Multiport Switch' incorporates:
       *  DataTypeConversion: '<S1023>/Data Type Conversion30'
       *  Delay: '<S176>/Resettable Delay'
       */
      MultiportSwitch[0] = app_DW.ResettableDelay_DSTATE_d;
      MultiportSwitch[1] = nDLookupTable1;
      MultiportSwitch[2] = rtb_Gain5_i;
      break;

     default:
      /* MultiPortSwitch: '<S499>/Multiport Switch' incorporates:
       *  Sum: '<S499>/Minus3'
       */
      MultiportSwitch[0] = app_DW.UnitDelay_DSTATE_i5;
      MultiportSwitch[1] = app_DW.UnitDelay1_DSTATE_c - Switch;
      MultiportSwitch[2] = rtb_t_min;
      break;
    }

    /* End of MultiPortSwitch: '<S499>/Multiport Switch' */

    /* Sum: '<S500>/Minus' */
    rtb_ARB_F_PCTWhlDrvnToq_sg = MultiportSwitch[1];

    /* Lookup_n-D: '<S500>/n-D Lookup Table1' incorporates:
     *  Sum: '<S120>/Add1'
     */
    nDLookupTable1 = look1_iflf_binlxpw(rtb_ARB_F_PCTWhlDrvnToq_sg,
      app_ConstP.pooled51, app_ConstP.pooled50, 30U);

    /* Lookup_n-D: '<S500>/n-D Lookup Table' incorporates:
     *  Sum: '<S120>/Add1'
     */
    rtb_ARB_F_PCTWhlDrvnToq_sg = look1_iflf_binlxpw(rtb_ARB_F_PCTWhlDrvnToq_sg,
      app_ConstP.pooled51, app_ConstP.nDLookupTable_tableData_b, 30U);

    /* Gain: '<S500>/Gain' */
    rtb_Switch_ik = 0.5F * rtb_ARB_F_PCTWhlDrvnToq_sg;

    /* Chart: '<S502>/TRP_Scheduling' incorporates:
     *  Lookup_n-D: '<S543>/n-D Lookup Table1'
     *  Lookup_n-D: '<S543>/n-D Lookup Table2'
     *  Product: '<S735>/Divide8'
     *  Product: '<S763>/Divide8'
     *  Product: '<S789>/Divide8'
     *  Product: '<S818>/Divide8'
     *  Product: '<S847>/Divide8'
     *  Product: '<S876>/Divide8'
     *  Sum: '<S872>/Add2'
     */
    if (m_TRP_Replan_Level_Spd == RPL_Disable) {
      /* Outputs for Function Call SubSystem: '<S502>/Trj_RePlan2' */
      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant'
       *  SignalConversion generated from: '<S537>/Constant'
       */
      s_traj_real_Spd = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant10'
       *  SignalConversion generated from: '<S537>/Constant10'
       */
      rtb_Switch_ai = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant1'
       *  SignalConversion generated from: '<S537>/Constant1'
       */
      v_traj_real_Spd = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant2'
       *  SignalConversion generated from: '<S537>/Constant2'
       */
      rtb_ACC_t_FTCDsrdDistLv2_sg = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant4'
       *  SignalConversion generated from: '<S537>/Constant4'
       */
      Longt_Spd_C0 = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant5'
       *  SignalConversion generated from: '<S537>/Constant5'
       */
      a_traj_real_Spd_PrdtOneStp = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant6'
       *  SignalConversion generated from: '<S537>/Constant6'
       */
      rtb_Product_eqe = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant7'
       *  SignalConversion generated from: '<S537>/Constant7'
       */
      nDLookupTable1 = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant8'
       *  SignalConversion generated from: '<S537>/Constant8'
       */
      Longt_Spd_C1 = 0.0F;

      /* Merge generated from: '<S534>/Merge' incorporates:
       *  Constant: '<S537>/Constant9'
       *  SignalConversion generated from: '<S537>/Constant9'
       */
      rtb_Switch_ik = 0.0F;

      /* Merge generated from: '<S534>/Merge1' incorporates:
       *  SignalConversion generated from: '<S537>/Trj_BatchNone_Out'
       */
      t_end = app_ConstB.t_end;

      /* Merge: '<S534>/Merge3' incorporates:
       *  Constant: '<S537>/Constant13'
       *  SignalConversion generated from: '<S537>/Traj_t_TrjTrvlTmNone_sg'
       */
      Merge3 = 0.0F;

      /* Update for UnitDelay: '<S501>/Unit Delay' incorporates:
       *  Constant: '<S537>/Constant14'
       *  Merge: '<S534>/Merge4'
       *  SignalConversion generated from: '<S537>/Traj_t_TrjRemainTmNone_sg'
       */
      app_DW.UnitDelay_DSTATE_f = 0.0F;

      /* End of Outputs for SubSystem: '<S502>/Trj_RePlan2' */
    } else if ((m_TRP_Replan_Level_Spd == RPL_Init) || (m_TRP_Replan_Level_Spd ==
                RPL_RePlan) || (m_TRP_Replan_Level_Spd == RPL_Normal)) {
      /* Outputs for Function Call SubSystem: '<S502>/Trj_RePlan' */
      /* Sum: '<S538>/Add2' */
      app_B.Add2 = MultiportSwitch[1] + Switch;

      /* Product: '<S538>/Product' incorporates:
       *  Constant: '<S538>/Constant1'
       */
      app_B.Product_e = 0.5F * MultiportSwitch[2];

      /* Gain: '<S543>/Gain5' incorporates:
       *  Abs: '<S543>/Abs'
       */
      rtb_Add2_pgh = 3.6F * fabsf(MultiportSwitch[1]);

      /* Outputs for Atomic SubSystem: '<S543>/LinSpace' */
      app_LinSpace(look1_iflf_binlxpw(rtb_Add2_pgh, app_ConstP.pooled52,
        app_ConstP.nDLookupTable2_tableData_l, 15U), look1_iflf_binlxpw
                   (rtb_Add2_pgh, app_ConstP.pooled52,
                    app_ConstP.nDLookupTable1_tableData_o, 15U), rtb_Reshape,
                   &app_B.LinSpace, 6);

      /* End of Outputs for SubSystem: '<S543>/LinSpace' */

      /* Product: '<S734>/Product1' incorporates:
       *  Lookup_n-D: '<S543>/n-D Lookup Table1'
       *  Lookup_n-D: '<S543>/n-D Lookup Table2'
       *  Product: '<S734>/Product5'
       *  Product: '<S734>/Product6'
       *  Sum: '<S872>/Add2'
       */
      Merge3 = MultiportSwitch[2] * rtb_Reshape[1];

      /* Product: '<S734>/Product4' incorporates:
       *  Math: '<S728>/Square7'
       *  Math: '<S733>/Square1'
       *  Product: '<S734>/Product3'
       */
      rtb_Switch_ai = rtb_Reshape[1] * rtb_Reshape[1];

      /* Gain: '<S734>/Gain1' incorporates:
       *  Gain: '<S734>/Gain2'
       *  Gain: '<S734>/Gain3'
       *  Product: '<S734>/Divide3'
       *  Product: '<S734>/Product1'
       *  Product: '<S734>/Product4'
       *  Sum: '<S734>/Add1'
       */
      v_traj_real_Spd = -((2.0F * MultiportSwitch[1] + Merge3) * 6.0F /
                          rtb_Switch_ai);

      /* Product: '<S734>/Product3' incorporates:
       *  Product: '<S728>/Product7'
       *  Product: '<S733>/Product3'
       *  Product: '<S734>/Product2'
       */
      t_end = rtb_Switch_ai * rtb_Reshape[1];

      /* Product: '<S734>/Divide4' incorporates:
       *  Gain: '<S734>/Gain4'
       *  Gain: '<S734>/Gain5'
       *  Gain: '<S734>/Gain6'
       *  Product: '<S734>/Product3'
       *  Sum: '<S734>/Add3'
       */
      a_traj_real_Spd_PrdtOneStp = (Merge3 * 3.0F + 8.0F * MultiportSwitch[1]) *
        6.0F / t_end;

      /* Gain: '<S734>/Gain9' incorporates:
       *  Gain: '<S734>/Gain7'
       *  Gain: '<S734>/Gain8'
       *  Product: '<S734>/Divide1'
       *  Product: '<S734>/Product2'
       *  Sum: '<S734>/Add2'
       */
      j_traj_real_Spd = -((3.0F * MultiportSwitch[1] + Merge3) * 24.0F / (t_end *
        rtb_Reshape[1]));

      /* Product: '<S733>/Product' incorporates:
       *  Product: '<S728>/Product6'
       */
      Merge3 = v_traj_real_Spd * rtb_Reshape[1];

      /* Product: '<S733>/Product4' incorporates:
       *  Constant: '<S733>/Constant1'
       *  Constant: '<S733>/Constant2'
       *  Gain: '<S733>/Gain'
       *  Product: '<S733>/Product'
       *  Product: '<S733>/Product1'
       *  Product: '<S733>/Product2'
       *  Sum: '<S733>/Add'
       */
      LimitationViolate = ((0.5F * a_traj_real_Spd_PrdtOneStp * rtb_Switch_ai +
                            Merge3) + t_end * (0.166666672F * j_traj_real_Spd)) *
        0.0F * nDLookupTable1;

      /* Product: '<S733>/Product5' */
      Opt = rtb_Switch_ik * rtb_Reshape[1];

      /* Product: '<S735>/Divide9' incorporates:
       *  Constant: '<S735>/Constant5'
       */
      s_traj_real_Spd = j_traj_real_Spd * 0.0416666679F;

      /* Sum: '<S735>/Add2' incorporates:
       *  Constant: '<S735>/Constant1'
       *  Constant: '<S735>/Constant2'
       *  Product: '<S735>/Divide1'
       *  Product: '<S735>/Divide3'
       */
      Longt_Spd_C0 = 2.0F * s_traj_real_Spd * rtb_Reshape[1] +
        a_traj_real_Spd_PrdtOneStp * 0.166666672F;

      /* Outputs for Atomic SubSystem: '<S735>/SfD'
       *
       * Block description for '<S735>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[1] * rtb_Reshape[1],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S735>/SfD' */

      /* Sum: '<S735>/Add4' incorporates:
       *  Constant: '<S735>/Constant16'
       *  Product: '<S735>/Divide8'
       *  Product: '<S735>/Multiply7'
       *  Product: '<S735>/Multiply8'
       */
      Longt_Spd_C1 = Longt_Spd_C0 * Longt_Spd_C0 - 4.0F * s_traj_real_Spd *
        rtb_Product1_hd;

      /* If: '<S735>/If' */
      if ((s_traj_real_Spd != 0.0F) && (Longt_Spd_C1 >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem' incorporates:
         *  ActionPort: '<S746>/Action Port'
         */
        app_IfActionSubsystem_c(s_traj_real_Spd, Longt_Spd_C0, Longt_Spd_C1,
          rtb_Reshape[1], rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem' */
      } else if ((s_traj_real_Spd == 0.0F) && (Longt_Spd_C0 != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S747>/Action Port'
         */
        app_IfActionSubsystem1_h(Longt_Spd_C0, rtb_Product1_hd, rtb_Reshape[1],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S748>/Action Port'
         */
        /* SignalConversion: '<S748>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[1];
        rtb_Switch1_g[1] = rtb_Reshape[1];

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem2' */
      }

      /* End of If: '<S735>/If' */

      /* Sum: '<S744>/Add' incorporates:
       *  Gain: '<S744>/Gain'
       *  Gain: '<S744>/Gain1'
       *  Gain: '<S744>/Gain2'
       *  Product: '<S744>/Multiply'
       *  Product: '<S744>/Multiply1'
       *  Product: '<S744>/Multiply2'
       *  Product: '<S744>/Multiply3'
       */
      s_traj_real_Spd = ((v_traj_real_Spd * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                          0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
        MultiportSwitch[1])) + a_traj_real_Spd_PrdtOneStp * rtb_Switch1_g[0] *
                         rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
        j_traj_real_Spd * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0]
        * rtb_Switch1_g[0] * 0.0416666679F;

      /* Product: '<S735>/Multiply9' */
      rtb_KTt_a = MultiportSwitch[1] * s_traj_real_Spd;

      /* Sum: '<S745>/Add' incorporates:
       *  Gain: '<S745>/Gain'
       *  Gain: '<S745>/Gain1'
       *  Gain: '<S745>/Gain2'
       *  Product: '<S745>/Multiply'
       *  Product: '<S745>/Multiply1'
       *  Product: '<S745>/Multiply2'
       *  Product: '<S745>/Multiply3'
       */
      Longt_Spd_C0 = ((v_traj_real_Spd * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                       0.5F + (MultiportSwitch[2] * rtb_Switch1_g[1] +
        MultiportSwitch[1])) + a_traj_real_Spd_PrdtOneStp * rtb_Switch1_g[1] *
                      rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.166666672F) +
        j_traj_real_Spd * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1]
        * rtb_Switch1_g[1] * 0.0416666679F;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S735>/Multiply10'
       */
      app_B.Opt_m = MultiportSwitch[1] * Longt_Spd_C0;

      /* If: '<S735>/If1' */
      if ((rtb_KTt_a < 0.0F) && (app_B.Opt_m >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S749>/Action Port'
         */
        app_IfActionSubsystem3(s_traj_real_Spd, &app_B.Opt_m);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem3' */
      } else if ((rtb_KTt_a >= 0.0F) && (app_B.Opt_m < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S750>/Action Port'
         */
        app_IfActionSubsystem4(Longt_Spd_C0, &app_B.Opt_m);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem4' */
      } else if ((rtb_KTt_a < 0.0F) && (app_B.Opt_m < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S751>/Action Port'
         */
        app_IfActionSubsystem5(s_traj_real_Spd, Longt_Spd_C0, &app_B.Opt_m);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S735>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S752>/Action Port'
         */
        app_IfActionSubsystem6(&app_B.Opt_m);

        /* End of Outputs for SubSystem: '<S735>/If Action Subsystem6' */
      }

      /* End of If: '<S735>/If1' */

      /* Product: '<S733>/Product6' */
      c4 = rtb_ACC_t_FTCDsrdDistLv2_sg * app_B.Opt_m;

      /* Sum: '<S733>/Add1' */
      rtb_KTt_a = (LimitationViolate + Opt) + c4;

      /* Sum: '<S728>/Add6' incorporates:
       *  Constant: '<S728>/Constant10'
       *  Constant: '<S728>/Constant9'
       *  Product: '<S728>/Divide6'
       *  Product: '<S728>/Divide7'
       */
      rtb_Switch_ai = ((Merge3 + MultiportSwitch[2]) +
                       a_traj_real_Spd_PrdtOneStp / 2.0F * rtb_Switch_ai) +
        t_end * (j_traj_real_Spd / 6.0F);

      /* Sum: '<S728>/Add1' incorporates:
       *  Constant: '<S728>/Constant3'
       *  Math: '<S728>/Square3'
       *  Product: '<S728>/Product3'
       */
      rtb_Add1_fd = a_traj_real_Spd_PrdtOneStp * a_traj_real_Spd_PrdtOneStp -
        v_traj_real_Spd * j_traj_real_Spd * 2.0F;

      /* Sqrt: '<S728>/Sqrt' incorporates:
       *  Abs: '<S728>/Abs'
       *  Sqrt: '<S728>/Sqrt1'
       */
      Merge3 = sqrtf(fabsf(rtb_Add1_fd));

      /* Product: '<S728>/Divide2' incorporates:
       *  Gain: '<S728>/Gain'
       *  Sqrt: '<S728>/Sqrt'
       *  Sum: '<S728>/Add3'
       */
      t_end = (-a_traj_real_Spd_PrdtOneStp + Merge3) / j_traj_real_Spd;

      /* Product: '<S728>/Divide3' incorporates:
       *  Gain: '<S728>/Gain1'
       *  Sum: '<S728>/Add4'
       */
      Merge3 = (-a_traj_real_Spd_PrdtOneStp - Merge3) / j_traj_real_Spd;

      /* If: '<S728>/If' incorporates:
       *  Constant: '<S728>/Constant1'
       *  Constant: '<S728>/Constant2'
       *  Constant: '<S728>/Constant5'
       *  Constant: '<S728>/Constant7'
       *  Constant: '<S728>/Constant8'
       *  Math: '<S728>/Square1'
       *  Math: '<S728>/Square2'
       *  Math: '<S728>/Square4'
       *  Math: '<S728>/Square5'
       *  Product: '<S728>/Divide'
       *  Product: '<S728>/Divide1'
       *  Product: '<S728>/Divide4'
       *  Product: '<S728>/Divide5'
       *  Product: '<S728>/Product1'
       *  Product: '<S728>/Product2'
       *  Product: '<S728>/Product4'
       *  Product: '<S728>/Product5'
       *  Sum: '<S728>/Add2'
       *  Sum: '<S728>/Add5'
       */
      if (rtb_Add1_fd < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S728>/If Action Subsystem' incorporates:
         *  ActionPort: '<S736>/Action Port'
         */
        app_IfActionSubsystem(rtb_Switch_ai, 0.0F, rtb_Reshape[1], &c5,
                              &t_Ax_Extrem1, &t_Ax_Extrem2, &t_Jerk_Extrem);

        /* End of Outputs for SubSystem: '<S728>/If Action Subsystem' */
      } else if (rtb_Add1_fd == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S728>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S737>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + v_traj_real_Spd * t_end) +
          a_traj_real_Spd_PrdtOneStp / 2.0F * (t_end * t_end)) + j_traj_real_Spd
          / 6.0F * (t_end * t_end * t_end), ((MultiportSwitch[2] +
          v_traj_real_Spd * Merge3) + a_traj_real_Spd_PrdtOneStp / 2.0F *
          (Merge3 * Merge3)) + j_traj_real_Spd / 6.0F * (Merge3 * Merge3 *
          Merge3), t_end, &c5, &t_Ax_Extrem1, &t_Ax_Extrem2, &t_Jerk_Extrem);

        /* End of Outputs for SubSystem: '<S728>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S728>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S738>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + v_traj_real_Spd * t_end) +
          a_traj_real_Spd_PrdtOneStp / 2.0F * (t_end * t_end)) + j_traj_real_Spd
          / 6.0F * (t_end * t_end * t_end), ((MultiportSwitch[2] +
          v_traj_real_Spd * Merge3) + a_traj_real_Spd_PrdtOneStp / 2.0F *
          (Merge3 * Merge3)) + j_traj_real_Spd / 6.0F * (Merge3 * Merge3 *
          Merge3), t_end, Merge3, &c5, &t_Ax_Extrem1, &t_Ax_Extrem2,
          &t_Jerk_Extrem);

        /* End of Outputs for SubSystem: '<S728>/If Action Subsystem2' */
      }

      /* End of If: '<S728>/If' */

      /* MinMax: '<S728>/Min' */
      Ax_Extrem1 = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], rtb_Switch_ai), c5),
                         t_Ax_Extrem1);

      /* Product: '<S732>/Product4' incorporates:
       *  Abs: '<S732>/Abs'
       *  MinMax: '<S728>/Min1'
       *  MinMax: '<S732>/Max5'
       */
      Ax_Extrem2 = rtb_Product_eqe * fmaxf(Ax_Extrem1, fabsf(fminf(fminf(fminf
        (MultiportSwitch[2], rtb_Switch_ai), c5), t_Ax_Extrem1)));

      /* Switch: '<S731>/Switch' incorporates:
       *  Constant: '<S731>/Invalid'
       *  Constant: '<S742>/Constant'
       *  Gain: '<S731>/Gain'
       *  RelationalOperator: '<S742>/Compare'
       */
      if (j_traj_real_Spd != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S731>/SfD'
         *
         * Block description for '<S731>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-a_traj_real_Spd_PrdtOneStp, j_traj_real_Spd, &Jerk_Extrem,
                  1.0E-7F);

        /* End of Outputs for SubSystem: '<S731>/SfD' */
      } else {
        Jerk_Extrem = 0.0F;
      }

      /* End of Switch: '<S731>/Switch' */

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S731>/Divide3'
       */
      app_B.LimitationViolate_k = j_traj_real_Spd * Jerk_Extrem;

      /* Sum: '<S731>/Add2' incorporates:
       *  Math: '<S731>/Square2'
       *  Product: '<S731>/Divide2'
       */
      ax_Max_Traj = (a_traj_real_Spd_PrdtOneStp * Jerk_Extrem + v_traj_real_Spd)
        + app_B.LimitationViolate_k * app_B.LimitationViolate_k;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Constant: '<S731>/t_Start'
       *  Math: '<S731>/Square1'
       *  Product: '<S731>/Divide4'
       *  Product: '<S731>/Divide5'
       *  Sum: '<S731>/Add1'
       */
      app_B.LimitationViolate_k = j_traj_real_Spd * 0.0F;
      app_B.LimitationViolate_k = (a_traj_real_Spd_PrdtOneStp * 0.0F +
        v_traj_real_Spd) + app_B.LimitationViolate_k * app_B.LimitationViolate_k;

      /* Product: '<S731>/Divide7' */
      rtb_Switch_i = j_traj_real_Spd * rtb_Reshape[1];

      /* Sum: '<S731>/Add3' incorporates:
       *  Math: '<S731>/Square3'
       *  Product: '<S731>/Divide6'
       */
      rtb_Add1_fd = (a_traj_real_Spd_PrdtOneStp * rtb_Reshape[1] +
                     v_traj_real_Spd) + rtb_Switch_i * rtb_Switch_i;

      /* MinMax: '<S731>/Min' */
      rtb_Switch_i = fmaxf(fmaxf(ax_Max_Traj, app_B.LimitationViolate_k),
                           rtb_Add1_fd);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Abs: '<S732>/Abs2'
       *  MinMax: '<S731>/Min1'
       */
      app_B.LimitationViolate_k = fminf(fminf(ax_Max_Traj,
        app_B.LimitationViolate_k), rtb_Add1_fd);
      app_B.LimitationViolate_k = fabsf(app_B.LimitationViolate_k);

      /* Product: '<S732>/Product1' incorporates:
       *  MinMax: '<S732>/Max6'
       */
      rtb_Product1_j2z = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_i,
        app_B.LimitationViolate_k);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Constant: '<S545>/Constant'
       *  Sum: '<S732>/Add5'
       */
      app_B.Opt_m -= 0.277777791F;

      /* Product: '<S732>/Product2' incorporates:
       *  Constant: '<S732>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S732>/Max4'
       */
      rtb_Product2_jd = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(app_B.Opt_m, 0.0F);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Sum: '<S732>/Add8'
       */
      app_B.LimitationViolate_k = (Ax_Extrem2 + rtb_Product1_j2z) +
        rtb_Product2_jd;

      /* Product: '<S762>/Product1' incorporates:
       *  Product: '<S762>/Product5'
       *  Product: '<S762>/Product6'
       */
      Merge3 = MultiportSwitch[2] * rtb_Reshape[0];

      /* Product: '<S762>/Product4' incorporates:
       *  Math: '<S757>/Square7'
       *  Math: '<S761>/Square1'
       *  Product: '<S762>/Product3'
       */
      rtb_Switch_ai = rtb_Reshape[0] * rtb_Reshape[0];

      /* Gain: '<S762>/Gain1' incorporates:
       *  Gain: '<S762>/Gain2'
       *  Gain: '<S762>/Gain3'
       *  Product: '<S762>/Divide3'
       *  Product: '<S762>/Product1'
       *  Product: '<S762>/Product4'
       *  Sum: '<S762>/Add1'
       */
      app_B.c3_f = -((2.0F * MultiportSwitch[1] + Merge3) * 6.0F / rtb_Switch_ai);

      /* Product: '<S762>/Product3' incorporates:
       *  Product: '<S757>/Product7'
       *  Product: '<S761>/Product3'
       *  Product: '<S762>/Product2'
       */
      t_end = rtb_Switch_ai * rtb_Reshape[0];

      /* Product: '<S762>/Divide4' incorporates:
       *  Gain: '<S762>/Gain4'
       *  Gain: '<S762>/Gain5'
       *  Gain: '<S762>/Gain6'
       *  Product: '<S762>/Product3'
       *  Sum: '<S762>/Add3'
       */
      app_B.c4_p = (Merge3 * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F / t_end;

      /* Gain: '<S762>/Gain9' incorporates:
       *  Gain: '<S762>/Gain7'
       *  Gain: '<S762>/Gain8'
       *  Product: '<S762>/Divide1'
       *  Product: '<S762>/Product2'
       *  Sum: '<S762>/Add2'
       */
      app_B.c5_f = -((3.0F * MultiportSwitch[1] + Merge3) * 24.0F / (t_end *
        rtb_Reshape[0]));

      /* Product: '<S761>/Product' incorporates:
       *  Product: '<S757>/Product6'
       */
      Merge3 = app_B.c3_f * rtb_Reshape[0];

      /* Product: '<S761>/Product4' incorporates:
       *  Constant: '<S761>/Constant1'
       *  Constant: '<S761>/Constant2'
       *  Gain: '<S761>/Gain'
       *  Product: '<S761>/Product'
       *  Product: '<S761>/Product1'
       *  Product: '<S761>/Product2'
       *  Sum: '<S761>/Add'
       */
      rtb_Product4_dp = ((0.5F * app_B.c4_p * rtb_Switch_ai + Merge3) + t_end *
                         (0.166666672F * app_B.c5_f)) * 0.0F * nDLookupTable1;

      /* Product: '<S761>/Product5' */
      rtb_KTt_h = rtb_Switch_ik * rtb_Reshape[0];

      /* Product: '<S763>/Divide9' incorporates:
       *  Constant: '<S763>/Constant5'
       */
      s_traj_real_Spd = app_B.c5_f * 0.0416666679F;

      /* Sum: '<S763>/Add2' incorporates:
       *  Constant: '<S763>/Constant1'
       *  Constant: '<S763>/Constant2'
       *  Product: '<S763>/Divide1'
       *  Product: '<S763>/Divide3'
       */
      Longt_Spd_C0 = 2.0F * s_traj_real_Spd * rtb_Reshape[0] + app_B.c4_p *
        0.166666672F;

      /* Outputs for Atomic SubSystem: '<S763>/SfD'
       *
       * Block description for '<S763>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[0] * rtb_Reshape[0],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S763>/SfD' */

      /* Sum: '<S763>/Add4' incorporates:
       *  Constant: '<S763>/Constant16'
       *  Product: '<S763>/Divide8'
       *  Product: '<S763>/Multiply7'
       *  Product: '<S763>/Multiply8'
       */
      Longt_Spd_C1 = Longt_Spd_C0 * Longt_Spd_C0 - 4.0F * s_traj_real_Spd *
        rtb_Product1_hd;

      /* If: '<S763>/If' */
      if ((s_traj_real_Spd != 0.0F) && (Longt_Spd_C1 >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem' incorporates:
         *  ActionPort: '<S771>/Action Port'
         */
        app_IfActionSubsystem_c(s_traj_real_Spd, Longt_Spd_C0, Longt_Spd_C1,
          rtb_Reshape[0], rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem' */
      } else if ((s_traj_real_Spd == 0.0F) && (Longt_Spd_C0 != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S772>/Action Port'
         */
        app_IfActionSubsystem1_h(Longt_Spd_C0, rtb_Product1_hd, rtb_Reshape[0],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S773>/Action Port'
         */
        /* SignalConversion: '<S773>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[0];
        rtb_Switch1_g[1] = rtb_Reshape[0];

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem2' */
      }

      /* End of If: '<S763>/If' */

      /* Sum: '<S769>/Add' incorporates:
       *  Gain: '<S769>/Gain'
       *  Gain: '<S769>/Gain1'
       *  Gain: '<S769>/Gain2'
       *  Product: '<S769>/Multiply'
       *  Product: '<S769>/Multiply1'
       *  Product: '<S769>/Multiply2'
       *  Product: '<S769>/Multiply3'
       */
      s_traj_real_Spd = ((app_B.c3_f * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                          0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
        MultiportSwitch[1])) + app_B.c4_p * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                         rtb_Switch1_g[0] * 0.166666672F) + app_B.c5_f *
        rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0]
        * 0.0416666679F;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S763>/Multiply9'
       */
      app_B.Opt_m = MultiportSwitch[1] * s_traj_real_Spd;

      /* Sum: '<S770>/Add' incorporates:
       *  Gain: '<S770>/Gain'
       *  Gain: '<S770>/Gain1'
       *  Gain: '<S770>/Gain2'
       *  Product: '<S770>/Multiply'
       *  Product: '<S770>/Multiply1'
       *  Product: '<S770>/Multiply2'
       *  Product: '<S770>/Multiply3'
       */
      Longt_Spd_C0 = ((app_B.c3_f * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
                       (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch
                        [1])) + app_B.c4_p * rtb_Switch1_g[1] * rtb_Switch1_g[1]
                      * rtb_Switch1_g[1] * 0.166666672F) + app_B.c5_f *
        rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1]
        * 0.0416666679F;

      /* Product: '<S763>/Multiply10' */
      rtb_Product4_aq = MultiportSwitch[1] * Longt_Spd_C0;

      /* If: '<S763>/If1' */
      if ((app_B.Opt_m < 0.0F) && (rtb_Product4_aq >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S774>/Action Port'
         */
        app_IfActionSubsystem3(s_traj_real_Spd, &rtb_Product4_aq);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem3' */
      } else if ((app_B.Opt_m >= 0.0F) && (rtb_Product4_aq < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S775>/Action Port'
         */
        app_IfActionSubsystem4(Longt_Spd_C0, &rtb_Product4_aq);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem4' */
      } else if ((app_B.Opt_m < 0.0F) && (rtb_Product4_aq < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S776>/Action Port'
         */
        app_IfActionSubsystem5(s_traj_real_Spd, Longt_Spd_C0, &rtb_Product4_aq);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S763>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S777>/Action Port'
         */
        app_IfActionSubsystem6(&rtb_Product4_aq);

        /* End of Outputs for SubSystem: '<S763>/If Action Subsystem6' */
      }

      /* End of If: '<S763>/If1' */

      /* Product: '<S761>/Product6' */
      rtb_K_OsV_Os_c = rtb_ACC_t_FTCDsrdDistLv2_sg * rtb_Product4_aq;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Sum: '<S761>/Add1'
       */
      app_B.Opt_m = (rtb_Product4_dp + rtb_KTt_h) + rtb_K_OsV_Os_c;

      /* Sum: '<S757>/Add6' incorporates:
       *  Constant: '<S757>/Constant10'
       *  Constant: '<S757>/Constant9'
       *  Product: '<S757>/Divide6'
       *  Product: '<S757>/Divide7'
       */
      rtb_Switch_ai = ((Merge3 + MultiportSwitch[2]) + app_B.c4_p / 2.0F *
                       rtb_Switch_ai) + t_end * (app_B.c5_f / 6.0F);

      /* Sum: '<S757>/Add1' incorporates:
       *  Constant: '<S757>/Constant3'
       *  Math: '<S757>/Square3'
       *  Product: '<S757>/Product3'
       */
      rtb_Add1_fd = app_B.c4_p * app_B.c4_p - app_B.c3_f * app_B.c5_f * 2.0F;

      /* Sqrt: '<S757>/Sqrt' incorporates:
       *  Abs: '<S757>/Abs'
       *  Sqrt: '<S757>/Sqrt1'
       */
      Merge3 = sqrtf(fabsf(rtb_Add1_fd));

      /* Product: '<S757>/Divide2' incorporates:
       *  Gain: '<S757>/Gain'
       *  Sqrt: '<S757>/Sqrt'
       *  Sum: '<S757>/Add3'
       */
      t_end = (-app_B.c4_p + Merge3) / app_B.c5_f;

      /* Product: '<S757>/Divide3' incorporates:
       *  Gain: '<S757>/Gain1'
       *  Sum: '<S757>/Add4'
       */
      Merge3 = (-app_B.c4_p - Merge3) / app_B.c5_f;

      /* If: '<S757>/If' incorporates:
       *  Constant: '<S757>/Constant1'
       *  Constant: '<S757>/Constant2'
       *  Constant: '<S757>/Constant5'
       *  Constant: '<S757>/Constant7'
       *  Constant: '<S757>/Constant8'
       *  Math: '<S757>/Square1'
       *  Math: '<S757>/Square2'
       *  Math: '<S757>/Square4'
       *  Math: '<S757>/Square5'
       *  Product: '<S757>/Divide'
       *  Product: '<S757>/Divide1'
       *  Product: '<S757>/Divide4'
       *  Product: '<S757>/Divide5'
       *  Product: '<S757>/Product1'
       *  Product: '<S757>/Product2'
       *  Product: '<S757>/Product4'
       *  Product: '<S757>/Product5'
       *  Sum: '<S757>/Add2'
       *  Sum: '<S757>/Add5'
       */
      if (rtb_Add1_fd < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S757>/If Action Subsystem' incorporates:
         *  ActionPort: '<S764>/Action Port'
         */
        app_IfActionSubsystem(rtb_Switch_ai, 0.0F, rtb_Reshape[0],
                              &app_B.Ax_Extrem1_nb, &app_B.Ax_Extrem2_k,
                              &app_B.t_Ax_Extrem1_nf, &app_B.t_Ax_Extrem2_c);

        /* End of Outputs for SubSystem: '<S757>/If Action Subsystem' */
      } else if (rtb_Add1_fd == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S757>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S765>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + app_B.c3_f * t_end) +
          app_B.c4_p / 2.0F * (t_end * t_end)) + app_B.c5_f / 6.0F * (t_end *
          t_end * t_end), ((MultiportSwitch[2] + app_B.c3_f * Merge3) +
                           app_B.c4_p / 2.0F * (Merge3 * Merge3)) + app_B.c5_f /
          6.0F * (Merge3 * Merge3 * Merge3), t_end, &app_B.Ax_Extrem1_nb,
          &app_B.Ax_Extrem2_k, &app_B.t_Ax_Extrem1_nf, &app_B.t_Ax_Extrem2_c);

        /* End of Outputs for SubSystem: '<S757>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S757>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S766>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + app_B.c3_f * t_end) +
          app_B.c4_p / 2.0F * (t_end * t_end)) + app_B.c5_f / 6.0F * (t_end *
          t_end * t_end), ((MultiportSwitch[2] + app_B.c3_f * Merge3) +
                           app_B.c4_p / 2.0F * (Merge3 * Merge3)) + app_B.c5_f /
          6.0F * (Merge3 * Merge3 * Merge3), t_end, Merge3, &app_B.Ax_Extrem1_nb,
          &app_B.Ax_Extrem2_k, &app_B.t_Ax_Extrem1_nf, &app_B.t_Ax_Extrem2_c);

        /* End of Outputs for SubSystem: '<S757>/If Action Subsystem2' */
      }

      /* End of If: '<S757>/If' */

      /* MinMax: '<S757>/Min' */
      app_B.ax_Max_Traj_m = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], rtb_Switch_ai),
        app_B.Ax_Extrem1_nb), app_B.Ax_Extrem2_k);

      /* Product: '<S760>/Product4' incorporates:
       *  Abs: '<S760>/Abs'
       *  MinMax: '<S757>/Min1'
       *  MinMax: '<S760>/Max5'
       */
      rtb_Product4_lc = rtb_Product_eqe * fmaxf(app_B.ax_Max_Traj_m, fabsf(fminf
        (fminf(fminf(MultiportSwitch[2], rtb_Switch_ai), app_B.Ax_Extrem1_nb),
         app_B.Ax_Extrem2_k)));

      /* Switch: '<S759>/Switch' incorporates:
       *  Constant: '<S767>/Constant'
       *  Gain: '<S759>/Gain'
       *  RelationalOperator: '<S767>/Compare'
       */
      if (app_B.c5_f != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S759>/SfD'
         *
         * Block description for '<S759>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-app_B.c4_p, app_B.c5_f, &app_B.t_Jerk_Extrem_b, 1.0E-7F);

        /* End of Outputs for SubSystem: '<S759>/SfD' */
      } else {
        /* Switch: '<S759>/Switch' incorporates:
         *  Constant: '<S759>/Invalid'
         */
        app_B.t_Jerk_Extrem_b = 0.0F;
      }

      /* End of Switch: '<S759>/Switch' */

      /* Sum: '<S759>/Add2' incorporates:
       *  Gain: '<S759>/Gain1'
       *  Product: '<S759>/Divide2'
       *  Product: '<S759>/Divide3'
       */
      app_B.Jerk_Extrem_h = app_B.c5_f * app_B.t_Jerk_Extrem_b *
        app_B.t_Jerk_Extrem_b * 0.5F + (app_B.c4_p * app_B.t_Jerk_Extrem_b +
        app_B.c3_f);

      /* Sum: '<S759>/Add1' incorporates:
       *  Constant: '<S759>/t_Start'
       *  Gain: '<S759>/Gain2'
       *  Product: '<S759>/Divide4'
       *  Product: '<S759>/Divide5'
       */
      rtb_Switch_ai = app_B.c5_f * 0.0F * 0.0F * 0.5F + (app_B.c4_p * 0.0F +
        app_B.c3_f);

      /* Sum: '<S759>/Add3' incorporates:
       *  Gain: '<S759>/Gain3'
       *  Product: '<S759>/Divide6'
       *  Product: '<S759>/Divide7'
       */
      rtb_Add1_fd = app_B.c5_f * rtb_Reshape[0] * rtb_Reshape[0] * 0.5F +
        (app_B.c4_p * rtb_Reshape[0] + app_B.c3_f);

      /* MinMax: '<S759>/Min' */
      rtb_Switch_i = fmaxf(fmaxf(app_B.Jerk_Extrem_h, rtb_Switch_ai),
                           rtb_Add1_fd);

      /* MinMax: '<S759>/Min1' */
      rtb_Switch_ai = fminf(fminf(app_B.Jerk_Extrem_h, rtb_Switch_ai),
                            rtb_Add1_fd);

      /* Abs: '<S760>/Abs2' */
      rtb_Switch_ai = fabsf(rtb_Switch_ai);

      /* Product: '<S760>/Product1' incorporates:
       *  MinMax: '<S760>/Max6'
       */
      rtb_Product1_ei = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_i,
        rtb_Switch_ai);

      /* Sum: '<S760>/Add5' incorporates:
       *  Constant: '<S546>/Constant'
       */
      rtb_Product4_aq -= 0.277777791F;

      /* Product: '<S760>/Product2' incorporates:
       *  Constant: '<S760>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S760>/Max4'
       */
      rtb_Product2_hzb = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product4_aq,
        0.0F);

      /* Sum: '<S760>/Add8' */
      rtb_Switch_ai = (rtb_Product4_lc + rtb_Product1_ei) + rtb_Product2_hzb;

      /* Logic: '<S729>/Logical Operator1' incorporates:
       *  RelationalOperator: '<S729>/Relational Operator2'
       *  Sum: '<S729>/Add'
       *  Sum: '<S729>/Add1'
       */
      rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = (rtb_KTt_a + app_B.LimitationViolate_k <
        app_B.Opt_m + rtb_Switch_ai);

      /* Product: '<S788>/Product1' incorporates:
       *  Product: '<S788>/Product5'
       *  Product: '<S788>/Product6'
       */
      t_end = MultiportSwitch[2] * rtb_Reshape[2];

      /* Product: '<S788>/Product4' incorporates:
       *  Math: '<S782>/Square7'
       *  Math: '<S787>/Square1'
       *  Product: '<S788>/Product3'
       */
      Merge3 = rtb_Reshape[2] * rtb_Reshape[2];

      /* Gain: '<S788>/Gain1' incorporates:
       *  Gain: '<S788>/Gain2'
       *  Gain: '<S788>/Gain3'
       *  Product: '<S788>/Divide3'
       *  Product: '<S788>/Product1'
       *  Product: '<S788>/Product4'
       *  Sum: '<S788>/Add1'
       */
      rtb_Gain1_bg = -((2.0F * MultiportSwitch[1] + t_end) * 6.0F / Merge3);

      /* Product: '<S788>/Product3' incorporates:
       *  Product: '<S782>/Product7'
       *  Product: '<S787>/Product3'
       *  Product: '<S788>/Product2'
       */
      s_traj_real_Spd = Merge3 * rtb_Reshape[2];

      /* Product: '<S788>/Divide4' incorporates:
       *  Gain: '<S788>/Gain4'
       *  Gain: '<S788>/Gain5'
       *  Gain: '<S788>/Gain6'
       *  Product: '<S788>/Product3'
       *  Sum: '<S788>/Add3'
       */
      rtb_Divide4_h1 = (t_end * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F /
        s_traj_real_Spd;

      /* Gain: '<S788>/Gain9' incorporates:
       *  Gain: '<S788>/Gain7'
       *  Gain: '<S788>/Gain8'
       *  Product: '<S788>/Divide1'
       *  Product: '<S788>/Product2'
       *  Sum: '<S788>/Add2'
       */
      rtb_Gain9_kp = -((3.0F * MultiportSwitch[1] + t_end) * 24.0F /
                       (s_traj_real_Spd * rtb_Reshape[2]));

      /* Product: '<S787>/Product' incorporates:
       *  Product: '<S782>/Product6'
       */
      Longt_Spd_C0 = rtb_Gain1_bg * rtb_Reshape[2];

      /* Product: '<S787>/Product4' incorporates:
       *  Constant: '<S787>/Constant1'
       *  Constant: '<S787>/Constant2'
       *  Gain: '<S787>/Gain'
       *  Product: '<S787>/Product'
       *  Product: '<S787>/Product1'
       *  Product: '<S787>/Product2'
       *  Sum: '<S787>/Add'
       */
      rtb_Product4_p = ((0.5F * rtb_Divide4_h1 * Merge3 + Longt_Spd_C0) +
                        s_traj_real_Spd * (0.166666672F * rtb_Gain9_kp)) * 0.0F *
        nDLookupTable1;

      /* Product: '<S787>/Product5' */
      rtb_KTt_af = rtb_Switch_ik * rtb_Reshape[2];

      /* Product: '<S789>/Divide9' incorporates:
       *  Constant: '<S789>/Constant5'
       */
      t_end = rtb_Gain9_kp * 0.0416666679F;

      /* Sum: '<S789>/Add2' incorporates:
       *  Constant: '<S789>/Constant1'
       *  Constant: '<S789>/Constant2'
       *  Product: '<S789>/Divide1'
       *  Product: '<S789>/Divide3'
       */
      Longt_Spd_C1 = 2.0F * t_end * rtb_Reshape[2] + rtb_Divide4_h1 *
        0.166666672F;

      /* Outputs for Atomic SubSystem: '<S789>/SfD'
       *
       * Block description for '<S789>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[2] * rtb_Reshape[2],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S789>/SfD' */

      /* Sum: '<S789>/Add4' incorporates:
       *  Constant: '<S789>/Constant16'
       *  Product: '<S789>/Divide8'
       *  Product: '<S789>/Multiply7'
       *  Product: '<S789>/Multiply8'
       */
      c3 = Longt_Spd_C1 * Longt_Spd_C1 - 4.0F * t_end * rtb_Product1_hd;

      /* If: '<S789>/If' */
      if ((t_end != 0.0F) && (c3 >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem' incorporates:
         *  ActionPort: '<S800>/Action Port'
         */
        app_IfActionSubsystem_c(t_end, Longt_Spd_C1, c3, rtb_Reshape[2],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem' */
      } else if ((t_end == 0.0F) && (Longt_Spd_C1 != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S801>/Action Port'
         */
        app_IfActionSubsystem1_h(Longt_Spd_C1, rtb_Product1_hd, rtb_Reshape[2],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S802>/Action Port'
         */
        /* SignalConversion: '<S802>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[2];
        rtb_Switch1_g[1] = rtb_Reshape[2];

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem2' */
      }

      /* End of If: '<S789>/If' */

      /* Sum: '<S798>/Add' incorporates:
       *  Gain: '<S798>/Gain'
       *  Gain: '<S798>/Gain1'
       *  Gain: '<S798>/Gain2'
       *  Product: '<S798>/Multiply'
       *  Product: '<S798>/Multiply1'
       *  Product: '<S798>/Multiply2'
       *  Product: '<S798>/Multiply3'
       */
      Longt_Spd_C1 = ((rtb_Gain1_bg * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F
                       + (MultiportSwitch[2] * rtb_Switch1_g[0] +
                          MultiportSwitch[1])) + rtb_Divide4_h1 * rtb_Switch1_g
                      [0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F)
        + rtb_Gain9_kp * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
        rtb_Switch1_g[0] * 0.0416666679F;

      /* Product: '<S789>/Multiply9' */
      rtb_Product4_aq = MultiportSwitch[1] * Longt_Spd_C1;

      /* Sum: '<S799>/Add' incorporates:
       *  Gain: '<S799>/Gain'
       *  Gain: '<S799>/Gain1'
       *  Gain: '<S799>/Gain2'
       *  Product: '<S799>/Multiply'
       *  Product: '<S799>/Multiply1'
       *  Product: '<S799>/Multiply2'
       *  Product: '<S799>/Multiply3'
       */
      c3 = ((rtb_Gain1_bg * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
             (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch[1])) +
            rtb_Divide4_h1 * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
            rtb_Switch1_g[1] * 0.166666672F) + rtb_Gain9_kp * rtb_Switch1_g[1] *
        rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

      /* Product: '<S789>/Multiply10' */
      t_end = MultiportSwitch[1] * c3;

      /* If: '<S789>/If1' */
      if ((rtb_Product4_aq < 0.0F) && (t_end >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S803>/Action Port'
         */
        app_IfActionSubsystem3(Longt_Spd_C1, &t_end);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem3' */
      } else if ((rtb_Product4_aq >= 0.0F) && (t_end < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S804>/Action Port'
         */
        app_IfActionSubsystem4(c3, &t_end);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem4' */
      } else if ((rtb_Product4_aq < 0.0F) && (t_end < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S805>/Action Port'
         */
        app_IfActionSubsystem5(Longt_Spd_C1, c3, &t_end);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S789>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S806>/Action Port'
         */
        app_IfActionSubsystem6(&t_end);

        /* End of Outputs for SubSystem: '<S789>/If Action Subsystem6' */
      }

      /* End of If: '<S789>/If1' */

      /* Product: '<S787>/Product6' */
      rtb_K_OsV_Os_l = rtb_ACC_t_FTCDsrdDistLv2_sg * t_end;

      /* Sum: '<S787>/Add1' */
      rtb_Product4_aq = (rtb_Product4_p + rtb_KTt_af) + rtb_K_OsV_Os_l;

      /* Sum: '<S782>/Add6' incorporates:
       *  Constant: '<S782>/Constant10'
       *  Constant: '<S782>/Constant9'
       *  Product: '<S782>/Divide6'
       *  Product: '<S782>/Divide7'
       */
      Merge3 = ((Longt_Spd_C0 + MultiportSwitch[2]) + rtb_Divide4_h1 / 2.0F *
                Merge3) + s_traj_real_Spd * (rtb_Gain9_kp / 6.0F);

      /* Sum: '<S782>/Add1' incorporates:
       *  Constant: '<S782>/Constant3'
       *  Math: '<S782>/Square3'
       *  Product: '<S782>/Product3'
       */
      rtb_Add1_fd = rtb_Divide4_h1 * rtb_Divide4_h1 - rtb_Gain1_bg *
        rtb_Gain9_kp * 2.0F;

      /* Sqrt: '<S782>/Sqrt' incorporates:
       *  Abs: '<S782>/Abs'
       *  Sqrt: '<S782>/Sqrt1'
       */
      Longt_Spd_C0 = sqrtf(fabsf(rtb_Add1_fd));

      /* Product: '<S782>/Divide2' incorporates:
       *  Gain: '<S782>/Gain'
       *  Sqrt: '<S782>/Sqrt'
       *  Sum: '<S782>/Add3'
       */
      s_traj_real_Spd = (-rtb_Divide4_h1 + Longt_Spd_C0) / rtb_Gain9_kp;

      /* Product: '<S782>/Divide3' incorporates:
       *  Gain: '<S782>/Gain1'
       *  Sum: '<S782>/Add4'
       */
      Longt_Spd_C0 = (-rtb_Divide4_h1 - Longt_Spd_C0) / rtb_Gain9_kp;

      /* If: '<S782>/If' incorporates:
       *  Constant: '<S782>/Constant1'
       *  Constant: '<S782>/Constant2'
       *  Constant: '<S782>/Constant5'
       *  Constant: '<S782>/Constant7'
       *  Constant: '<S782>/Constant8'
       *  Math: '<S782>/Square1'
       *  Math: '<S782>/Square2'
       *  Math: '<S782>/Square4'
       *  Math: '<S782>/Square5'
       *  Product: '<S782>/Divide'
       *  Product: '<S782>/Divide1'
       *  Product: '<S782>/Divide4'
       *  Product: '<S782>/Divide5'
       *  Product: '<S782>/Product1'
       *  Product: '<S782>/Product2'
       *  Product: '<S782>/Product4'
       *  Product: '<S782>/Product5'
       *  Sum: '<S782>/Add2'
       *  Sum: '<S782>/Add5'
       */
      if (rtb_Add1_fd < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S782>/If Action Subsystem' incorporates:
         *  ActionPort: '<S790>/Action Port'
         */
        app_IfActionSubsystem(Merge3, 0.0F, rtb_Reshape[2], &Ax_Extrem1_n,
                              &Ax_Extrem2_f, &t_Ax_Extrem1_e, &t_Ax_Extrem2_g);

        /* End of Outputs for SubSystem: '<S782>/If Action Subsystem' */
      } else if (rtb_Add1_fd == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S782>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S791>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_Gain1_bg *
          s_traj_real_Spd) + rtb_Divide4_h1 / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_kp / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_bg * Longt_Spd_C0) + rtb_Divide4_h1 / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_kp / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, &Ax_Extrem1_n, &Ax_Extrem2_f,
          &t_Ax_Extrem1_e, &t_Ax_Extrem2_g);

        /* End of Outputs for SubSystem: '<S782>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S782>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S792>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_Gain1_bg *
          s_traj_real_Spd) + rtb_Divide4_h1 / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_kp / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_bg * Longt_Spd_C0) + rtb_Divide4_h1 / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_kp / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, Longt_Spd_C0, &Ax_Extrem1_n,
          &Ax_Extrem2_f, &t_Ax_Extrem1_e, &t_Ax_Extrem2_g);

        /* End of Outputs for SubSystem: '<S782>/If Action Subsystem2' */
      }

      /* End of If: '<S782>/If' */

      /* MinMax: '<S782>/Min' */
      rtb_Min_p = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Merge3), Ax_Extrem1_n),
                        Ax_Extrem2_f);

      /* Product: '<S786>/Product4' incorporates:
       *  Abs: '<S786>/Abs'
       *  MinMax: '<S782>/Min1'
       *  MinMax: '<S786>/Max5'
       */
      rtb_Product4_k0 = rtb_Product_eqe * fmaxf(rtb_Min_p, fabsf(fminf(fminf
        (fminf(MultiportSwitch[2], Merge3), Ax_Extrem1_n), Ax_Extrem2_f)));

      /* Switch: '<S785>/Switch' incorporates:
       *  Constant: '<S785>/Invalid'
       *  Constant: '<S796>/Constant'
       *  Gain: '<S785>/Gain'
       *  RelationalOperator: '<S796>/Compare'
       */
      if (rtb_Gain9_kp != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S785>/SfD'
         *
         * Block description for '<S785>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-rtb_Divide4_h1, rtb_Gain9_kp, &rtb_Switch_ki, 1.0E-7F);

        /* End of Outputs for SubSystem: '<S785>/SfD' */
      } else {
        rtb_Switch_ki = 0.0F;
      }

      /* End of Switch: '<S785>/Switch' */

      /* Product: '<S785>/Divide3' */
      rtb_Gain1_jl = rtb_Gain9_kp * rtb_Switch_ki;

      /* Sum: '<S785>/Add2' incorporates:
       *  Math: '<S785>/Square2'
       *  Product: '<S785>/Divide2'
       */
      rtb_Add2_l = (rtb_Divide4_h1 * rtb_Switch_ki + rtb_Gain1_bg) +
        rtb_Gain1_jl * rtb_Gain1_jl;

      /* Product: '<S785>/Divide5' incorporates:
       *  Constant: '<S785>/t_Start'
       */
      rtb_Gain1_jl = rtb_Gain9_kp * 0.0F;

      /* Sum: '<S785>/Add1' incorporates:
       *  Constant: '<S785>/t_Start'
       *  Math: '<S785>/Square1'
       *  Product: '<S785>/Divide4'
       */
      rtb_Gain1_jl = (rtb_Divide4_h1 * 0.0F + rtb_Gain1_bg) + rtb_Gain1_jl *
        rtb_Gain1_jl;

      /* Product: '<S785>/Divide7' */
      rtb_Switch_i = rtb_Gain9_kp * rtb_Reshape[2];

      /* Sum: '<S785>/Add3' incorporates:
       *  Math: '<S785>/Square3'
       *  Product: '<S785>/Divide6'
       */
      rtb_Add1_fd = (rtb_Divide4_h1 * rtb_Reshape[2] + rtb_Gain1_bg) +
        rtb_Switch_i * rtb_Switch_i;

      /* MinMax: '<S785>/Min' */
      rtb_Switch_i = fmaxf(fmaxf(rtb_Add2_l, rtb_Gain1_jl), rtb_Add1_fd);

      /* MinMax: '<S785>/Min1' */
      rtb_Gain1_jl = fminf(fminf(rtb_Add2_l, rtb_Gain1_jl), rtb_Add1_fd);

      /* Abs: '<S786>/Abs2' */
      rtb_Gain1_jl = fabsf(rtb_Gain1_jl);

      /* Product: '<S786>/Product1' incorporates:
       *  MinMax: '<S786>/Max6'
       */
      rtb_Product1_da = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_i,
        rtb_Gain1_jl);

      /* Sum: '<S786>/Add5' incorporates:
       *  Constant: '<S547>/Constant'
       */
      t_end -= 0.277777791F;

      /* Product: '<S786>/Product2' incorporates:
       *  Constant: '<S786>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S786>/Max4'
       */
      rtb_Product2_jb = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(t_end, 0.0F);

      /* Sum: '<S786>/Add8' */
      rtb_Gain1_jl = (rtb_Product4_k0 + rtb_Product1_da) + rtb_Product2_jb;

      /* Switch generated from: '<S729>/Switch2' */
      if (!rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        rtb_KTt_a = app_B.Opt_m;

        /* Switch generated from: '<S841>/Switch2' */
        app_B.LimitationViolate_k = rtb_Switch_ai;
      }

      /* Logic: '<S783>/Logical Operator1' incorporates:
       *  RelationalOperator: '<S783>/Relational Operator2'
       *  Sum: '<S783>/Add'
       *  Sum: '<S783>/Add1'
       */
      rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = (rtb_Product4_aq + rtb_Gain1_jl <
        rtb_KTt_a + app_B.LimitationViolate_k);

      /* Product: '<S817>/Product1' incorporates:
       *  Product: '<S817>/Product5'
       *  Product: '<S817>/Product6'
       */
      rtb_Switch_ai = MultiportSwitch[2] * rtb_Reshape[3];

      /* Product: '<S817>/Product4' incorporates:
       *  Math: '<S811>/Square7'
       *  Math: '<S816>/Square1'
       *  Product: '<S817>/Product3'
       */
      Merge3 = rtb_Reshape[3] * rtb_Reshape[3];

      /* Gain: '<S817>/Gain1' incorporates:
       *  Gain: '<S817>/Gain2'
       *  Gain: '<S817>/Gain3'
       *  Product: '<S817>/Divide3'
       *  Product: '<S817>/Product1'
       *  Product: '<S817>/Product4'
       *  Sum: '<S817>/Add1'
       */
      rtb_Gain1_az = -((2.0F * MultiportSwitch[1] + rtb_Switch_ai) * 6.0F /
                       Merge3);

      /* Product: '<S817>/Product3' incorporates:
       *  Product: '<S811>/Product7'
       *  Product: '<S816>/Product3'
       *  Product: '<S817>/Product2'
       */
      s_traj_real_Spd = Merge3 * rtb_Reshape[3];

      /* Product: '<S817>/Divide4' incorporates:
       *  Gain: '<S817>/Gain4'
       *  Gain: '<S817>/Gain5'
       *  Gain: '<S817>/Gain6'
       *  Product: '<S817>/Product3'
       *  Sum: '<S817>/Add3'
       */
      rtb_Divide4_b0 = (rtb_Switch_ai * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F
        / s_traj_real_Spd;

      /* Gain: '<S817>/Gain9' incorporates:
       *  Gain: '<S817>/Gain7'
       *  Gain: '<S817>/Gain8'
       *  Product: '<S817>/Divide1'
       *  Product: '<S817>/Product2'
       *  Sum: '<S817>/Add2'
       */
      rtb_Gain9_e = -((3.0F * MultiportSwitch[1] + rtb_Switch_ai) * 24.0F /
                      (s_traj_real_Spd * rtb_Reshape[3]));

      /* Product: '<S816>/Product' incorporates:
       *  Product: '<S811>/Product6'
       */
      Longt_Spd_C0 = rtb_Gain1_az * rtb_Reshape[3];

      /* Product: '<S816>/Product4' incorporates:
       *  Constant: '<S816>/Constant1'
       *  Constant: '<S816>/Constant2'
       *  Gain: '<S816>/Gain'
       *  Product: '<S816>/Product'
       *  Product: '<S816>/Product1'
       *  Product: '<S816>/Product2'
       *  Sum: '<S816>/Add'
       */
      rtb_Product4_no = ((0.5F * rtb_Divide4_b0 * Merge3 + Longt_Spd_C0) +
                         s_traj_real_Spd * (0.166666672F * rtb_Gain9_e)) * 0.0F *
        nDLookupTable1;

      /* Product: '<S816>/Product5' */
      rtb_KTt_m0 = rtb_Switch_ik * rtb_Reshape[3];

      /* Product: '<S818>/Divide9' incorporates:
       *  Constant: '<S818>/Constant5'
       */
      rtb_Switch_ai = rtb_Gain9_e * 0.0416666679F;

      /* Sum: '<S818>/Add2' incorporates:
       *  Constant: '<S818>/Constant1'
       *  Constant: '<S818>/Constant2'
       *  Product: '<S818>/Divide1'
       *  Product: '<S818>/Divide3'
       */
      t_end = 2.0F * rtb_Switch_ai * rtb_Reshape[3] + rtb_Divide4_b0 *
        0.166666672F;

      /* Outputs for Atomic SubSystem: '<S818>/SfD'
       *
       * Block description for '<S818>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[3] * rtb_Reshape[3],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S818>/SfD' */

      /* Sum: '<S818>/Add4' incorporates:
       *  Constant: '<S818>/Constant16'
       *  Product: '<S818>/Divide8'
       *  Product: '<S818>/Multiply7'
       *  Product: '<S818>/Multiply8'
       */
      Longt_Spd_C1 = t_end * t_end - 4.0F * rtb_Switch_ai * rtb_Product1_hd;

      /* If: '<S818>/If' */
      if ((rtb_Switch_ai != 0.0F) && (Longt_Spd_C1 >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem' incorporates:
         *  ActionPort: '<S829>/Action Port'
         */
        app_IfActionSubsystem_c(rtb_Switch_ai, t_end, Longt_Spd_C1, rtb_Reshape
          [3], rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem' */
      } else if ((rtb_Switch_ai == 0.0F) && (t_end != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S830>/Action Port'
         */
        app_IfActionSubsystem1_h(t_end, rtb_Product1_hd, rtb_Reshape[3],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S831>/Action Port'
         */
        /* SignalConversion: '<S831>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[3];
        rtb_Switch1_g[1] = rtb_Reshape[3];

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem2' */
      }

      /* End of If: '<S818>/If' */

      /* Sum: '<S827>/Add' incorporates:
       *  Gain: '<S827>/Gain'
       *  Gain: '<S827>/Gain1'
       *  Gain: '<S827>/Gain2'
       *  Product: '<S827>/Multiply'
       *  Product: '<S827>/Multiply1'
       *  Product: '<S827>/Multiply2'
       *  Product: '<S827>/Multiply3'
       */
      Longt_Spd_C1 = ((rtb_Gain1_az * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F
                       + (MultiportSwitch[2] * rtb_Switch1_g[0] +
                          MultiportSwitch[1])) + rtb_Divide4_b0 * rtb_Switch1_g
                      [0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F)
        + rtb_Gain9_e * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
        rtb_Switch1_g[0] * 0.0416666679F;

      /* Product: '<S818>/Multiply9' */
      t_end = MultiportSwitch[1] * Longt_Spd_C1;

      /* Sum: '<S828>/Add' incorporates:
       *  Gain: '<S828>/Gain'
       *  Gain: '<S828>/Gain1'
       *  Gain: '<S828>/Gain2'
       *  Product: '<S828>/Multiply'
       *  Product: '<S828>/Multiply1'
       *  Product: '<S828>/Multiply2'
       *  Product: '<S828>/Multiply3'
       */
      c3 = ((rtb_Gain1_az * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
             (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch[1])) +
            rtb_Divide4_b0 * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
            rtb_Switch1_g[1] * 0.166666672F) + rtb_Gain9_e * rtb_Switch1_g[1] *
        rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

      /* Product: '<S818>/Multiply10' */
      rtb_Switch_ai = MultiportSwitch[1] * c3;

      /* If: '<S818>/If1' */
      if ((t_end < 0.0F) && (rtb_Switch_ai >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S832>/Action Port'
         */
        app_IfActionSubsystem3(Longt_Spd_C1, &t_end);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem3' */
      } else if ((t_end >= 0.0F) && (rtb_Switch_ai < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S833>/Action Port'
         */
        app_IfActionSubsystem4(c3, &t_end);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem4' */
      } else if ((t_end < 0.0F) && (rtb_Switch_ai < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S834>/Action Port'
         */
        app_IfActionSubsystem5(Longt_Spd_C1, c3, &t_end);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S818>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S835>/Action Port'
         */
        app_IfActionSubsystem6(&t_end);

        /* End of Outputs for SubSystem: '<S818>/If Action Subsystem6' */
      }

      /* End of If: '<S818>/If1' */

      /* Product: '<S816>/Product6' */
      rtb_K_OsV_Os_bx = rtb_ACC_t_FTCDsrdDistLv2_sg * t_end;

      /* Sum: '<S816>/Add1' */
      rtb_Switch_ai = (rtb_Product4_no + rtb_KTt_m0) + rtb_K_OsV_Os_bx;

      /* Sum: '<S811>/Add6' incorporates:
       *  Constant: '<S811>/Constant10'
       *  Constant: '<S811>/Constant9'
       *  Product: '<S811>/Divide6'
       *  Product: '<S811>/Divide7'
       */
      Merge3 = ((Longt_Spd_C0 + MultiportSwitch[2]) + rtb_Divide4_b0 / 2.0F *
                Merge3) + s_traj_real_Spd * (rtb_Gain9_e / 6.0F);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Constant: '<S811>/Constant3'
       *  Math: '<S811>/Square3'
       *  Product: '<S811>/Product3'
       *  Sum: '<S811>/Add1'
       */
      app_B.Opt_m = rtb_Divide4_b0 * rtb_Divide4_b0 - rtb_Gain1_az * rtb_Gain9_e
        * 2.0F;

      /* Sqrt: '<S811>/Sqrt' incorporates:
       *  Abs: '<S811>/Abs'
       *  Sqrt: '<S811>/Sqrt1'
       */
      Longt_Spd_C0 = sqrtf(fabsf(app_B.Opt_m));

      /* Product: '<S811>/Divide2' incorporates:
       *  Gain: '<S811>/Gain'
       *  Sqrt: '<S811>/Sqrt'
       *  Sum: '<S811>/Add3'
       */
      s_traj_real_Spd = (-rtb_Divide4_b0 + Longt_Spd_C0) / rtb_Gain9_e;

      /* Product: '<S811>/Divide3' incorporates:
       *  Gain: '<S811>/Gain1'
       *  Sum: '<S811>/Add4'
       */
      Longt_Spd_C0 = (-rtb_Divide4_b0 - Longt_Spd_C0) / rtb_Gain9_e;

      /* If: '<S811>/If' incorporates:
       *  Constant: '<S811>/Constant1'
       *  Constant: '<S811>/Constant2'
       *  Constant: '<S811>/Constant5'
       *  Constant: '<S811>/Constant7'
       *  Constant: '<S811>/Constant8'
       *  Math: '<S811>/Square1'
       *  Math: '<S811>/Square2'
       *  Math: '<S811>/Square4'
       *  Math: '<S811>/Square5'
       *  Product: '<S811>/Divide'
       *  Product: '<S811>/Divide1'
       *  Product: '<S811>/Divide4'
       *  Product: '<S811>/Divide5'
       *  Product: '<S811>/Product1'
       *  Product: '<S811>/Product2'
       *  Product: '<S811>/Product4'
       *  Product: '<S811>/Product5'
       *  Sum: '<S811>/Add2'
       *  Sum: '<S811>/Add5'
       */
      if (app_B.Opt_m < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S811>/If Action Subsystem' incorporates:
         *  ActionPort: '<S819>/Action Port'
         */
        app_IfActionSubsystem(Merge3, 0.0F, rtb_Reshape[3], &Ax_Extrem1_b,
                              &Ax_Extrem2_j, &t_Ax_Extrem1_j, &t_Ax_Extrem2_l);

        /* End of Outputs for SubSystem: '<S811>/If Action Subsystem' */
      } else if (app_B.Opt_m == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S811>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S820>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_Gain1_az *
          s_traj_real_Spd) + rtb_Divide4_b0 / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_e / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_az * Longt_Spd_C0) + rtb_Divide4_b0 / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_e / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, &Ax_Extrem1_b, &Ax_Extrem2_j,
          &t_Ax_Extrem1_j, &t_Ax_Extrem2_l);

        /* End of Outputs for SubSystem: '<S811>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S811>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S821>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_Gain1_az *
          s_traj_real_Spd) + rtb_Divide4_b0 / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_e / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_az * Longt_Spd_C0) + rtb_Divide4_b0 / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_e / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, Longt_Spd_C0, &Ax_Extrem1_b,
          &Ax_Extrem2_j, &t_Ax_Extrem1_j, &t_Ax_Extrem2_l);

        /* End of Outputs for SubSystem: '<S811>/If Action Subsystem2' */
      }

      /* End of If: '<S811>/If' */

      /* MinMax: '<S811>/Min' */
      rtb_Min_h = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Merge3), Ax_Extrem1_b),
                        Ax_Extrem2_j);

      /* Product: '<S815>/Product4' incorporates:
       *  Abs: '<S815>/Abs'
       *  MinMax: '<S811>/Min1'
       *  MinMax: '<S815>/Max5'
       */
      rtb_Product4_j = rtb_Product_eqe * fmaxf(rtb_Min_h, fabsf(fminf(fminf
        (fminf(MultiportSwitch[2], Merge3), Ax_Extrem1_b), Ax_Extrem2_j)));

      /* Switch: '<S814>/Switch' incorporates:
       *  Constant: '<S814>/Invalid'
       *  Constant: '<S825>/Constant'
       *  Gain: '<S814>/Gain'
       *  RelationalOperator: '<S825>/Compare'
       */
      if (rtb_Gain9_e != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S814>/SfD'
         *
         * Block description for '<S814>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-rtb_Divide4_b0, rtb_Gain9_e, &rtb_Switch_ddv, 1.0E-7F);

        /* End of Outputs for SubSystem: '<S814>/SfD' */
      } else {
        rtb_Switch_ddv = 0.0F;
      }

      /* End of Switch: '<S814>/Switch' */

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S814>/Divide3'
       */
      app_B.Opt_m = rtb_Gain9_e * rtb_Switch_ddv;

      /* Sum: '<S814>/Add2' incorporates:
       *  Math: '<S814>/Square2'
       *  Product: '<S814>/Divide2'
       */
      rtb_Add2_fb = (rtb_Divide4_b0 * rtb_Switch_ddv + rtb_Gain1_az) +
        app_B.Opt_m * app_B.Opt_m;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Constant: '<S814>/t_Start'
       *  Math: '<S814>/Square1'
       *  Product: '<S814>/Divide4'
       *  Product: '<S814>/Divide5'
       *  Sum: '<S814>/Add1'
       */
      app_B.Opt_m = rtb_Gain9_e * 0.0F;
      app_B.Opt_m = (rtb_Divide4_b0 * 0.0F + rtb_Gain1_az) + app_B.Opt_m *
        app_B.Opt_m;

      /* Product: '<S814>/Divide7' */
      rtb_Switch_i = rtb_Gain9_e * rtb_Reshape[3];

      /* Sum: '<S814>/Add3' incorporates:
       *  Math: '<S814>/Square3'
       *  Product: '<S814>/Divide6'
       */
      rtb_Add1_fd = (rtb_Divide4_b0 * rtb_Reshape[3] + rtb_Gain1_az) +
        rtb_Switch_i * rtb_Switch_i;

      /* MinMax: '<S814>/Min' */
      rtb_Switch_i = fmaxf(fmaxf(rtb_Add2_fb, app_B.Opt_m), rtb_Add1_fd);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Abs: '<S815>/Abs2'
       *  MinMax: '<S814>/Min1'
       */
      app_B.Opt_m = fminf(fminf(rtb_Add2_fb, app_B.Opt_m), rtb_Add1_fd);
      app_B.Opt_m = fabsf(app_B.Opt_m);

      /* Product: '<S815>/Product1' incorporates:
       *  MinMax: '<S815>/Max6'
       */
      rtb_Product1_n3 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_i,
        app_B.Opt_m);

      /* Sum: '<S815>/Add5' incorporates:
       *  Constant: '<S548>/Constant'
       */
      t_end -= 0.277777791F;

      /* Product: '<S815>/Product2' incorporates:
       *  Constant: '<S815>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S815>/Max4'
       */
      rtb_Product2_pl1 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(t_end, 0.0F);

      /* Sum: '<S815>/Add8' */
      t_end = (rtb_Product4_j + rtb_Product1_n3) + rtb_Product2_pl1;

      /* Switch generated from: '<S783>/Switch2' */
      if (!rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Product4_aq = rtb_KTt_a;
        rtb_Gain1_jl = app_B.LimitationViolate_k;
      }

      /* Logic: '<S812>/Logical Operator1' incorporates:
       *  RelationalOperator: '<S812>/Relational Operator2'
       *  Sum: '<S812>/Add'
       *  Sum: '<S812>/Add1'
       */
      rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = (rtb_Switch_ai + t_end <
        rtb_Product4_aq + rtb_Gain1_jl);

      /* Product: '<S846>/Product1' incorporates:
       *  Product: '<S846>/Product5'
       *  Product: '<S846>/Product6'
       */
      Longt_Spd_C0 = MultiportSwitch[2] * rtb_Reshape[4];

      /* Product: '<S846>/Product4' incorporates:
       *  Math: '<S840>/Square7'
       *  Math: '<S845>/Square1'
       *  Product: '<S846>/Product3'
       */
      Merge3 = rtb_Reshape[4] * rtb_Reshape[4];

      /* Gain: '<S846>/Gain1' incorporates:
       *  Gain: '<S846>/Gain2'
       *  Gain: '<S846>/Gain3'
       *  Product: '<S846>/Divide3'
       *  Product: '<S846>/Product1'
       *  Product: '<S846>/Product4'
       *  Sum: '<S846>/Add1'
       */
      rtb_Gain1_pv = -((2.0F * MultiportSwitch[1] + Longt_Spd_C0) * 6.0F /
                       Merge3);

      /* Product: '<S846>/Product3' incorporates:
       *  Product: '<S840>/Product7'
       *  Product: '<S845>/Product3'
       *  Product: '<S846>/Product2'
       */
      s_traj_real_Spd = Merge3 * rtb_Reshape[4];

      /* Product: '<S846>/Divide4' incorporates:
       *  Gain: '<S846>/Gain4'
       *  Gain: '<S846>/Gain5'
       *  Gain: '<S846>/Gain6'
       *  Product: '<S846>/Product3'
       *  Sum: '<S846>/Add3'
       */
      rtb_Divide4_b = (Longt_Spd_C0 * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F /
        s_traj_real_Spd;

      /* Gain: '<S846>/Gain9' incorporates:
       *  Gain: '<S846>/Gain7'
       *  Gain: '<S846>/Gain8'
       *  Product: '<S846>/Divide1'
       *  Product: '<S846>/Product2'
       *  Sum: '<S846>/Add2'
       */
      rtb_Gain9_b = -((3.0F * MultiportSwitch[1] + Longt_Spd_C0) * 24.0F /
                      (s_traj_real_Spd * rtb_Reshape[4]));

      /* Product: '<S845>/Product' incorporates:
       *  Product: '<S840>/Product6'
       */
      Longt_Spd_C0 = rtb_Gain1_pv * rtb_Reshape[4];

      /* Product: '<S845>/Product4' incorporates:
       *  Constant: '<S845>/Constant1'
       *  Constant: '<S845>/Constant2'
       *  Gain: '<S845>/Gain'
       *  Product: '<S845>/Product'
       *  Product: '<S845>/Product1'
       *  Product: '<S845>/Product2'
       *  Sum: '<S845>/Add'
       */
      rtb_Product4_e5 = ((0.5F * rtb_Divide4_b * Merge3 + Longt_Spd_C0) +
                         s_traj_real_Spd * (0.166666672F * rtb_Gain9_b)) * 0.0F *
        nDLookupTable1;

      /* Product: '<S845>/Product5' */
      rtb_KTt_b = rtb_Switch_ik * rtb_Reshape[4];

      /* Product: '<S847>/Divide9' incorporates:
       *  Constant: '<S847>/Constant5'
       */
      Longt_Spd_C1 = rtb_Gain9_b * 0.0416666679F;

      /* Sum: '<S847>/Add2' incorporates:
       *  Constant: '<S847>/Constant1'
       *  Constant: '<S847>/Constant2'
       *  Product: '<S847>/Divide1'
       *  Product: '<S847>/Divide3'
       */
      c3 = 2.0F * Longt_Spd_C1 * rtb_Reshape[4] + rtb_Divide4_b * 0.166666672F;

      /* Outputs for Atomic SubSystem: '<S847>/SfD'
       *
       * Block description for '<S847>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[4] * rtb_Reshape[4],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S847>/SfD' */

      /* Sum: '<S847>/Add4' incorporates:
       *  Constant: '<S847>/Constant16'
       *  Product: '<S847>/Divide8'
       *  Product: '<S847>/Multiply7'
       *  Product: '<S847>/Multiply8'
       */
      rtb_KTt_a = c3 * c3 - 4.0F * Longt_Spd_C1 * rtb_Product1_hd;

      /* If: '<S847>/If' */
      if ((Longt_Spd_C1 != 0.0F) && (rtb_KTt_a >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem' incorporates:
         *  ActionPort: '<S858>/Action Port'
         */
        app_IfActionSubsystem_c(Longt_Spd_C1, c3, rtb_KTt_a, rtb_Reshape[4],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem' */
      } else if ((Longt_Spd_C1 == 0.0F) && (c3 != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S859>/Action Port'
         */
        app_IfActionSubsystem1_h(c3, rtb_Product1_hd, rtb_Reshape[4],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S860>/Action Port'
         */
        /* SignalConversion: '<S860>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[4];
        rtb_Switch1_g[1] = rtb_Reshape[4];

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem2' */
      }

      /* End of If: '<S847>/If' */

      /* Sum: '<S856>/Add' incorporates:
       *  Gain: '<S856>/Gain'
       *  Gain: '<S856>/Gain1'
       *  Gain: '<S856>/Gain2'
       *  Product: '<S856>/Multiply'
       *  Product: '<S856>/Multiply1'
       *  Product: '<S856>/Multiply2'
       *  Product: '<S856>/Multiply3'
       */
      Longt_Spd_C1 = ((rtb_Gain1_pv * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F
                       + (MultiportSwitch[2] * rtb_Switch1_g[0] +
                          MultiportSwitch[1])) + rtb_Divide4_b * rtb_Switch1_g[0]
                      * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
        rtb_Gain9_b * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
        rtb_Switch1_g[0] * 0.0416666679F;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S847>/Multiply9'
       */
      app_B.LimitationViolate_k = MultiportSwitch[1] * Longt_Spd_C1;

      /* Sum: '<S857>/Add' incorporates:
       *  Gain: '<S857>/Gain'
       *  Gain: '<S857>/Gain1'
       *  Gain: '<S857>/Gain2'
       *  Product: '<S857>/Multiply'
       *  Product: '<S857>/Multiply1'
       *  Product: '<S857>/Multiply2'
       *  Product: '<S857>/Multiply3'
       */
      c3 = ((rtb_Gain1_pv * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
             (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch[1])) +
            rtb_Divide4_b * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g
            [1] * 0.166666672F) + rtb_Gain9_b * rtb_Switch1_g[1] *
        rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Product: '<S847>/Multiply10'
       */
      app_B.Opt_m = MultiportSwitch[1] * c3;

      /* If: '<S847>/If1' */
      if ((app_B.LimitationViolate_k < 0.0F) && (app_B.Opt_m >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S861>/Action Port'
         */
        app_IfActionSubsystem3(Longt_Spd_C1, &app_B.LimitationViolate_k);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem3' */
      } else if ((app_B.LimitationViolate_k >= 0.0F) && (app_B.Opt_m < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S862>/Action Port'
         */
        app_IfActionSubsystem4(c3, &app_B.LimitationViolate_k);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem4' */
      } else if ((app_B.LimitationViolate_k < 0.0F) && (app_B.Opt_m < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S863>/Action Port'
         */
        app_IfActionSubsystem5(Longt_Spd_C1, c3, &app_B.LimitationViolate_k);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S847>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S864>/Action Port'
         */
        app_IfActionSubsystem6(&app_B.LimitationViolate_k);

        /* End of Outputs for SubSystem: '<S847>/If Action Subsystem6' */
      }

      /* End of If: '<S847>/If1' */

      /* Product: '<S845>/Product6' */
      rtb_K_OsV_Os_au = rtb_ACC_t_FTCDsrdDistLv2_sg * app_B.LimitationViolate_k;

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Sum: '<S845>/Add1'
       */
      app_B.Opt_m = (rtb_Product4_e5 + rtb_KTt_b) + rtb_K_OsV_Os_au;

      /* Sum: '<S840>/Add6' incorporates:
       *  Constant: '<S840>/Constant10'
       *  Constant: '<S840>/Constant9'
       *  Product: '<S840>/Divide6'
       *  Product: '<S840>/Divide7'
       */
      Merge3 = ((Longt_Spd_C0 + MultiportSwitch[2]) + rtb_Divide4_b / 2.0F *
                Merge3) + s_traj_real_Spd * (rtb_Gain9_b / 6.0F);

      /* Sum: '<S840>/Add1' incorporates:
       *  Constant: '<S840>/Constant3'
       *  Math: '<S840>/Square3'
       *  Product: '<S840>/Product3'
       */
      rtb_KTt_a = rtb_Divide4_b * rtb_Divide4_b - rtb_Gain1_pv * rtb_Gain9_b *
        2.0F;

      /* Sqrt: '<S840>/Sqrt' incorporates:
       *  Abs: '<S840>/Abs'
       *  Sqrt: '<S840>/Sqrt1'
       */
      Longt_Spd_C0 = sqrtf(fabsf(rtb_KTt_a));

      /* Product: '<S840>/Divide2' incorporates:
       *  Gain: '<S840>/Gain'
       *  Sqrt: '<S840>/Sqrt'
       *  Sum: '<S840>/Add3'
       */
      s_traj_real_Spd = (-rtb_Divide4_b + Longt_Spd_C0) / rtb_Gain9_b;

      /* Product: '<S840>/Divide3' incorporates:
       *  Gain: '<S840>/Gain1'
       *  Sum: '<S840>/Add4'
       */
      Longt_Spd_C0 = (-rtb_Divide4_b - Longt_Spd_C0) / rtb_Gain9_b;

      /* If: '<S840>/If' incorporates:
       *  Constant: '<S840>/Constant1'
       *  Constant: '<S840>/Constant2'
       *  Constant: '<S840>/Constant5'
       *  Constant: '<S840>/Constant7'
       *  Constant: '<S840>/Constant8'
       *  Math: '<S840>/Square1'
       *  Math: '<S840>/Square2'
       *  Math: '<S840>/Square4'
       *  Math: '<S840>/Square5'
       *  Product: '<S840>/Divide'
       *  Product: '<S840>/Divide1'
       *  Product: '<S840>/Divide4'
       *  Product: '<S840>/Divide5'
       *  Product: '<S840>/Product1'
       *  Product: '<S840>/Product2'
       *  Product: '<S840>/Product4'
       *  Product: '<S840>/Product5'
       *  Sum: '<S840>/Add2'
       *  Sum: '<S840>/Add5'
       */
      if (rtb_KTt_a < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S840>/If Action Subsystem' incorporates:
         *  ActionPort: '<S848>/Action Port'
         */
        app_IfActionSubsystem(Merge3, 0.0F, rtb_Reshape[4], &Ax_Extrem1_ny,
                              &Ax_Extrem2_e, &t_Ax_Extrem1_k, &t_Ax_Extrem2_a);

        /* End of Outputs for SubSystem: '<S840>/If Action Subsystem' */
      } else if (rtb_KTt_a == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S840>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S849>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_Gain1_pv *
          s_traj_real_Spd) + rtb_Divide4_b / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_b / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_pv * Longt_Spd_C0) + rtb_Divide4_b / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_b / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, &Ax_Extrem1_ny, &Ax_Extrem2_e,
          &t_Ax_Extrem1_k, &t_Ax_Extrem2_a);

        /* End of Outputs for SubSystem: '<S840>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S840>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S850>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_Gain1_pv *
          s_traj_real_Spd) + rtb_Divide4_b / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_b / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_pv * Longt_Spd_C0) + rtb_Divide4_b / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_b / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, Longt_Spd_C0, &Ax_Extrem1_ny,
          &Ax_Extrem2_e, &t_Ax_Extrem1_k, &t_Ax_Extrem2_a);

        /* End of Outputs for SubSystem: '<S840>/If Action Subsystem2' */
      }

      /* End of If: '<S840>/If' */

      /* MinMax: '<S840>/Min' */
      rtb_Min_l = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Merge3), Ax_Extrem1_ny),
                        Ax_Extrem2_e);

      /* Product: '<S844>/Product4' incorporates:
       *  Abs: '<S844>/Abs'
       *  MinMax: '<S840>/Min1'
       *  MinMax: '<S844>/Max5'
       */
      rtb_Product4_ge = rtb_Product_eqe * fmaxf(rtb_Min_l, fabsf(fminf(fminf
        (fminf(MultiportSwitch[2], Merge3), Ax_Extrem1_ny), Ax_Extrem2_e)));

      /* Switch: '<S843>/Switch' incorporates:
       *  Constant: '<S843>/Invalid'
       *  Constant: '<S854>/Constant'
       *  Gain: '<S843>/Gain'
       *  RelationalOperator: '<S854>/Compare'
       */
      if (rtb_Gain9_b != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S843>/SfD'
         *
         * Block description for '<S843>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-rtb_Divide4_b, rtb_Gain9_b, &rtb_Switch_hv, 1.0E-7F);

        /* End of Outputs for SubSystem: '<S843>/SfD' */
      } else {
        rtb_Switch_hv = 0.0F;
      }

      /* End of Switch: '<S843>/Switch' */

      /* Product: '<S843>/Divide3' */
      rtb_KTt_a = rtb_Gain9_b * rtb_Switch_hv;

      /* Sum: '<S843>/Add2' incorporates:
       *  Math: '<S843>/Square2'
       *  Product: '<S843>/Divide2'
       */
      rtb_Add2_o = (rtb_Divide4_b * rtb_Switch_hv + rtb_Gain1_pv) + rtb_KTt_a *
        rtb_KTt_a;

      /* Product: '<S843>/Divide5' incorporates:
       *  Constant: '<S843>/t_Start'
       */
      rtb_KTt_a = rtb_Gain9_b * 0.0F;

      /* Sum: '<S843>/Add1' incorporates:
       *  Constant: '<S843>/t_Start'
       *  Math: '<S843>/Square1'
       *  Product: '<S843>/Divide4'
       */
      rtb_KTt_a = (rtb_Divide4_b * 0.0F + rtb_Gain1_pv) + rtb_KTt_a * rtb_KTt_a;

      /* Product: '<S843>/Divide7' */
      rtb_Switch_i = rtb_Gain9_b * rtb_Reshape[4];

      /* Sum: '<S843>/Add3' incorporates:
       *  Math: '<S843>/Square3'
       *  Product: '<S843>/Divide6'
       */
      rtb_Add1_fd = (rtb_Divide4_b * rtb_Reshape[4] + rtb_Gain1_pv) +
        rtb_Switch_i * rtb_Switch_i;

      /* MinMax: '<S843>/Min' */
      rtb_Switch_i = fmaxf(fmaxf(rtb_Add2_o, rtb_KTt_a), rtb_Add1_fd);

      /* MinMax: '<S843>/Min1' */
      rtb_KTt_a = fminf(fminf(rtb_Add2_o, rtb_KTt_a), rtb_Add1_fd);

      /* Abs: '<S844>/Abs2' */
      rtb_KTt_a = fabsf(rtb_KTt_a);

      /* Product: '<S844>/Product1' incorporates:
       *  MinMax: '<S844>/Max6'
       */
      rtb_Product1_a4 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_i,
        rtb_KTt_a);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Constant: '<S549>/Constant'
       *  Sum: '<S844>/Add5'
       */
      app_B.LimitationViolate_k -= 0.277777791F;

      /* Product: '<S844>/Product2' incorporates:
       *  Constant: '<S844>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S844>/Max4'
       */
      rtb_Product2_mv = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf
        (app_B.LimitationViolate_k, 0.0F);

      /* Switch generated from: '<S841>/Switch2' incorporates:
       *  Sum: '<S844>/Add8'
       */
      app_B.LimitationViolate_k = (rtb_Product4_ge + rtb_Product1_a4) +
        rtb_Product2_mv;

      /* Switch generated from: '<S812>/Switch2' */
      if (!rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Switch_ai = rtb_Product4_aq;
        t_end = rtb_Gain1_jl;
      }

      /* Logic: '<S841>/Logical Operator1' incorporates:
       *  RelationalOperator: '<S841>/Relational Operator2'
       *  Sum: '<S841>/Add'
       *  Sum: '<S841>/Add1'
       */
      rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p = (app_B.Opt_m +
        app_B.LimitationViolate_k < rtb_Switch_ai + t_end);

      /* Product: '<S875>/Product1' incorporates:
       *  Product: '<S875>/Product5'
       *  Product: '<S875>/Product6'
       */
      Longt_Spd_C0 = MultiportSwitch[2] * rtb_Reshape[5];

      /* Product: '<S875>/Product4' incorporates:
       *  Math: '<S869>/Square7'
       *  Math: '<S874>/Square1'
       *  Product: '<S875>/Product3'
       */
      Merge3 = rtb_Reshape[5] * rtb_Reshape[5];

      /* Gain: '<S875>/Gain1' incorporates:
       *  Gain: '<S875>/Gain2'
       *  Gain: '<S875>/Gain3'
       *  Product: '<S875>/Divide3'
       *  Product: '<S875>/Product1'
       *  Product: '<S875>/Product4'
       *  Sum: '<S875>/Add1'
       */
      rtb_Gain1_jl = -((2.0F * MultiportSwitch[1] + Longt_Spd_C0) * 6.0F /
                       Merge3);

      /* Product: '<S875>/Product3' incorporates:
       *  Product: '<S869>/Product7'
       *  Product: '<S874>/Product3'
       *  Product: '<S875>/Product2'
       */
      s_traj_real_Spd = Merge3 * rtb_Reshape[5];

      /* Product: '<S875>/Divide4' incorporates:
       *  Gain: '<S875>/Gain4'
       *  Gain: '<S875>/Gain5'
       *  Gain: '<S875>/Gain6'
       *  Product: '<S875>/Product3'
       *  Sum: '<S875>/Add3'
       */
      rtb_Divide4_aa = (Longt_Spd_C0 * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F /
        s_traj_real_Spd;

      /* Gain: '<S875>/Gain9' incorporates:
       *  Gain: '<S875>/Gain7'
       *  Gain: '<S875>/Gain8'
       *  Product: '<S875>/Divide1'
       *  Product: '<S875>/Product2'
       *  Sum: '<S875>/Add2'
       */
      rtb_Gain9_m = -((3.0F * MultiportSwitch[1] + Longt_Spd_C0) * 24.0F /
                      (s_traj_real_Spd * rtb_Reshape[5]));

      /* Product: '<S874>/Product' incorporates:
       *  Product: '<S869>/Product6'
       */
      Longt_Spd_C0 = rtb_Gain1_jl * rtb_Reshape[5];

      /* Product: '<S874>/Product4' incorporates:
       *  Constant: '<S874>/Constant1'
       *  Constant: '<S874>/Constant2'
       *  Gain: '<S874>/Gain'
       *  Product: '<S874>/Product'
       *  Product: '<S874>/Product1'
       *  Product: '<S874>/Product2'
       *  Sum: '<S874>/Add'
       */
      rtb_Product4_aq = ((0.5F * rtb_Divide4_aa * Merge3 + Longt_Spd_C0) +
                         s_traj_real_Spd * (0.166666672F * rtb_Gain9_m)) * 0.0F *
        nDLookupTable1;

      /* Product: '<S874>/Product5' */
      rtb_KTt_a = rtb_Switch_ik * rtb_Reshape[5];

      /* Product: '<S876>/Divide9' incorporates:
       *  Constant: '<S876>/Constant5'
       */
      Longt_Spd_C1 = rtb_Gain9_m * 0.0416666679F;

      /* Sum: '<S876>/Add2' incorporates:
       *  Constant: '<S876>/Constant1'
       *  Constant: '<S876>/Constant2'
       *  Product: '<S876>/Divide1'
       *  Product: '<S876>/Divide3'
       */
      c3 = 2.0F * Longt_Spd_C1 * rtb_Reshape[5] + rtb_Divide4_aa * 0.166666672F;

      /* Outputs for Atomic SubSystem: '<S876>/SfD'
       *
       * Block description for '<S876>/SfD':
       *  Safe Divide
       */
      app_SfD_i(MultiportSwitch[1], rtb_Reshape[5] * rtb_Reshape[5],
                &rtb_Product1_hd, 0.01F);

      /* End of Outputs for SubSystem: '<S876>/SfD' */

      /* Sum: '<S876>/Add4' incorporates:
       *  Constant: '<S876>/Constant16'
       *  Product: '<S876>/Divide8'
       *  Product: '<S876>/Multiply7'
       *  Product: '<S876>/Multiply8'
       */
      rtb_Add1_fd = c3 * c3 - 4.0F * Longt_Spd_C1 * rtb_Product1_hd;

      /* If: '<S876>/If' */
      if ((Longt_Spd_C1 != 0.0F) && (rtb_Add1_fd >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem' incorporates:
         *  ActionPort: '<S887>/Action Port'
         */
        app_IfActionSubsystem_c(Longt_Spd_C1, c3, rtb_Add1_fd, rtb_Reshape[5],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem' */
      } else if ((Longt_Spd_C1 == 0.0F) && (c3 != 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S888>/Action Port'
         */
        app_IfActionSubsystem1_h(c3, rtb_Product1_hd, rtb_Reshape[5],
          rtb_Switch1_g);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S889>/Action Port'
         */
        /* SignalConversion: '<S889>/Signal Conversion' */
        rtb_Switch1_g[0] = rtb_Reshape[5];
        rtb_Switch1_g[1] = rtb_Reshape[5];

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem2' */
      }

      /* End of If: '<S876>/If' */

      /* Sum: '<S885>/Add' incorporates:
       *  Gain: '<S885>/Gain'
       *  Gain: '<S885>/Gain1'
       *  Gain: '<S885>/Gain2'
       *  Product: '<S885>/Multiply'
       *  Product: '<S885>/Multiply1'
       *  Product: '<S885>/Multiply2'
       *  Product: '<S885>/Multiply3'
       */
      Longt_Spd_C1 = ((rtb_Gain1_jl * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F
                       + (MultiportSwitch[2] * rtb_Switch1_g[0] +
                          MultiportSwitch[1])) + rtb_Divide4_aa * rtb_Switch1_g
                      [0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F)
        + rtb_Gain9_m * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
        rtb_Switch1_g[0] * 0.0416666679F;

      /* Product: '<S876>/Multiply9' */
      rtb_K_OsV_Os_b = MultiportSwitch[1] * Longt_Spd_C1;

      /* Sum: '<S886>/Add' incorporates:
       *  Gain: '<S886>/Gain'
       *  Gain: '<S886>/Gain1'
       *  Gain: '<S886>/Gain2'
       *  Product: '<S886>/Multiply'
       *  Product: '<S886>/Multiply1'
       *  Product: '<S886>/Multiply2'
       *  Product: '<S886>/Multiply3'
       */
      rtb_Product1_hd = ((rtb_Gain1_jl * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                          0.5F + (MultiportSwitch[2] * rtb_Switch1_g[1] +
        MultiportSwitch[1])) + rtb_Divide4_aa * rtb_Switch1_g[1] *
                         rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.166666672F) +
        rtb_Gain9_m * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
        rtb_Switch1_g[1] * 0.0416666679F;

      /* Product: '<S876>/Multiply10' */
      c3 = MultiportSwitch[1] * rtb_Product1_hd;

      /* If: '<S876>/If1' */
      if ((rtb_K_OsV_Os_b < 0.0F) && (c3 >= 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem3' incorporates:
         *  ActionPort: '<S890>/Action Port'
         */
        app_IfActionSubsystem3(Longt_Spd_C1, &c3);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem3' */
      } else if ((rtb_K_OsV_Os_b >= 0.0F) && (c3 < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem4' incorporates:
         *  ActionPort: '<S891>/Action Port'
         */
        app_IfActionSubsystem4(rtb_Product1_hd, &c3);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem4' */
      } else if ((rtb_K_OsV_Os_b < 0.0F) && (c3 < 0.0F)) {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem5' incorporates:
         *  ActionPort: '<S892>/Action Port'
         */
        app_IfActionSubsystem5(Longt_Spd_C1, rtb_Product1_hd, &c3);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem5' */
      } else {
        /* Outputs for IfAction SubSystem: '<S876>/If Action Subsystem6' incorporates:
         *  ActionPort: '<S893>/Action Port'
         */
        app_IfActionSubsystem6(&c3);

        /* End of Outputs for SubSystem: '<S876>/If Action Subsystem6' */
      }

      /* End of If: '<S876>/If1' */

      /* Product: '<S874>/Product6' */
      rtb_K_OsV_Os_b = rtb_ACC_t_FTCDsrdDistLv2_sg * c3;

      /* Sum: '<S874>/Add1' */
      rtb_Add1_fd = (rtb_Product4_aq + rtb_KTt_a) + rtb_K_OsV_Os_b;

      /* Sum: '<S869>/Add6' incorporates:
       *  Constant: '<S869>/Constant10'
       *  Constant: '<S869>/Constant9'
       *  Product: '<S869>/Divide6'
       *  Product: '<S869>/Divide7'
       */
      Merge3 = ((Longt_Spd_C0 + MultiportSwitch[2]) + rtb_Divide4_aa / 2.0F *
                Merge3) + s_traj_real_Spd * (rtb_Gain9_m / 6.0F);

      /* Sum: '<S869>/Add1' incorporates:
       *  Constant: '<S869>/Constant3'
       *  Math: '<S869>/Square3'
       *  Product: '<S869>/Product3'
       */
      rtb_Product4_jc = rtb_Divide4_aa * rtb_Divide4_aa - rtb_Gain1_jl *
        rtb_Gain9_m * 2.0F;

      /* Sqrt: '<S869>/Sqrt' incorporates:
       *  Abs: '<S869>/Abs'
       *  Sqrt: '<S869>/Sqrt1'
       */
      Longt_Spd_C0 = sqrtf(fabsf(rtb_Product4_jc));

      /* Product: '<S869>/Divide2' incorporates:
       *  Gain: '<S869>/Gain'
       *  Sqrt: '<S869>/Sqrt'
       *  Sum: '<S869>/Add3'
       */
      s_traj_real_Spd = (-rtb_Divide4_aa + Longt_Spd_C0) / rtb_Gain9_m;

      /* Product: '<S869>/Divide3' incorporates:
       *  Gain: '<S869>/Gain1'
       *  Sum: '<S869>/Add4'
       */
      Longt_Spd_C0 = (-rtb_Divide4_aa - Longt_Spd_C0) / rtb_Gain9_m;

      /* If: '<S869>/If' incorporates:
       *  Constant: '<S869>/Constant1'
       *  Constant: '<S869>/Constant2'
       *  Constant: '<S869>/Constant5'
       *  Constant: '<S869>/Constant7'
       *  Constant: '<S869>/Constant8'
       *  Math: '<S869>/Square1'
       *  Math: '<S869>/Square2'
       *  Math: '<S869>/Square4'
       *  Math: '<S869>/Square5'
       *  Product: '<S869>/Divide'
       *  Product: '<S869>/Divide1'
       *  Product: '<S869>/Divide4'
       *  Product: '<S869>/Divide5'
       *  Product: '<S869>/Product1'
       *  Product: '<S869>/Product2'
       *  Product: '<S869>/Product4'
       *  Product: '<S869>/Product5'
       *  Sum: '<S869>/Add2'
       *  Sum: '<S869>/Add5'
       */
      if (rtb_Product4_jc < 0.0F) {
        /* Outputs for IfAction SubSystem: '<S869>/If Action Subsystem' incorporates:
         *  ActionPort: '<S877>/Action Port'
         */
        app_IfActionSubsystem(Merge3, 0.0F, rtb_Reshape[5], &Ax_Extrem1_o,
                              &Ax_Extrem2_i, &t_Ax_Extrem1_f, &t_Ax_Extrem2_e);

        /* End of Outputs for SubSystem: '<S869>/If Action Subsystem' */
      } else if (rtb_Product4_jc == 0.0F) {
        /* Outputs for IfAction SubSystem: '<S869>/If Action Subsystem1' incorporates:
         *  ActionPort: '<S878>/Action Port'
         */
        app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_Gain1_jl *
          s_traj_real_Spd) + rtb_Divide4_aa / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_m / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_jl * Longt_Spd_C0) + rtb_Divide4_aa / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_m / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, &Ax_Extrem1_o, &Ax_Extrem2_i,
          &t_Ax_Extrem1_f, &t_Ax_Extrem2_e);

        /* End of Outputs for SubSystem: '<S869>/If Action Subsystem1' */
      } else {
        /* Outputs for IfAction SubSystem: '<S869>/If Action Subsystem2' incorporates:
         *  ActionPort: '<S879>/Action Port'
         */
        app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_Gain1_jl *
          s_traj_real_Spd) + rtb_Divide4_aa / 2.0F * (s_traj_real_Spd *
          s_traj_real_Spd)) + rtb_Gain9_m / 6.0F * (s_traj_real_Spd *
          s_traj_real_Spd * s_traj_real_Spd), ((MultiportSwitch[2] +
          rtb_Gain1_jl * Longt_Spd_C0) + rtb_Divide4_aa / 2.0F * (Longt_Spd_C0 *
          Longt_Spd_C0)) + rtb_Gain9_m / 6.0F * (Longt_Spd_C0 * Longt_Spd_C0 *
          Longt_Spd_C0), s_traj_real_Spd, Longt_Spd_C0, &Ax_Extrem1_o,
          &Ax_Extrem2_i, &t_Ax_Extrem1_f, &t_Ax_Extrem2_e);

        /* End of Outputs for SubSystem: '<S869>/If Action Subsystem2' */
      }

      /* End of If: '<S869>/If' */

      /* MinMax: '<S869>/Min' */
      rtb_Min_lp = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Merge3), Ax_Extrem1_o),
                         Ax_Extrem2_i);

      /* Product: '<S873>/Product4' incorporates:
       *  Abs: '<S873>/Abs'
       *  MinMax: '<S869>/Min1'
       *  MinMax: '<S873>/Max5'
       */
      rtb_Product4_jc = rtb_Product_eqe * fmaxf(rtb_Min_lp, fabsf(fminf(fminf
        (fminf(MultiportSwitch[2], Merge3), Ax_Extrem1_o), Ax_Extrem2_i)));

      /* Switch: '<S872>/Switch' incorporates:
       *  Constant: '<S872>/Invalid'
       *  Constant: '<S883>/Constant'
       *  Gain: '<S872>/Gain'
       *  RelationalOperator: '<S883>/Compare'
       */
      if (rtb_Gain9_m != 0.0F) {
        /* Outputs for Atomic SubSystem: '<S872>/SfD'
         *
         * Block description for '<S872>/SfD':
         *  Safe Divide
         */
        app_SfD_i(-rtb_Divide4_aa, rtb_Gain9_m, &rtb_Switch_i, 1.0E-7F);

        /* End of Outputs for SubSystem: '<S872>/SfD' */
      } else {
        rtb_Switch_i = 0.0F;
      }

      /* End of Switch: '<S872>/Switch' */

      /* Product: '<S872>/Divide3' */
      rtb_Add2_pgh = rtb_Gain9_m * rtb_Switch_i;

      /* Sum: '<S872>/Add2' incorporates:
       *  Math: '<S872>/Square2'
       *  Product: '<S872>/Divide2'
       */
      rtb_Add2_pgh = (rtb_Divide4_aa * rtb_Switch_i + rtb_Gain1_jl) +
        rtb_Add2_pgh * rtb_Add2_pgh;

      /* Product: '<S872>/Divide5' incorporates:
       *  Constant: '<S872>/t_Start'
       */
      rtb_Add8 = rtb_Gain9_m * 0.0F;

      /* Sum: '<S872>/Add1' incorporates:
       *  Constant: '<S872>/t_Start'
       *  Math: '<S872>/Square1'
       *  Product: '<S872>/Divide4'
       */
      rtb_Add8 = (rtb_Divide4_aa * 0.0F + rtb_Gain1_jl) + rtb_Add8 * rtb_Add8;

      /* Product: '<S872>/Divide7' */
      rtb_Product1_hd = rtb_Gain9_m * rtb_Reshape[5];

      /* Sum: '<S872>/Add3' incorporates:
       *  Math: '<S872>/Square3'
       *  Product: '<S872>/Divide6'
       */
      rtb_Product2_m2 = (rtb_Divide4_aa * rtb_Reshape[5] + rtb_Gain1_jl) +
        rtb_Product1_hd * rtb_Product1_hd;

      /* MinMax: '<S872>/Min' */
      rtb_Product1_hd = fmaxf(fmaxf(rtb_Add2_pgh, rtb_Add8), rtb_Product2_m2);

      /* MinMax: '<S872>/Min1' */
      rtb_Add8 = fminf(fminf(rtb_Add2_pgh, rtb_Add8), rtb_Product2_m2);

      /* Abs: '<S873>/Abs2' */
      rtb_Add8 = fabsf(rtb_Add8);

      /* Product: '<S873>/Product1' incorporates:
       *  MinMax: '<S873>/Max6'
       */
      rtb_Product1_hd = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product1_hd,
        rtb_Add8);

      /* Sum: '<S873>/Add5' incorporates:
       *  Constant: '<S550>/Constant'
       */
      c3 -= 0.277777791F;

      /* Product: '<S873>/Product2' incorporates:
       *  Constant: '<S873>/Constant5'
       *  Lookup_n-D: '<S500>/n-D Lookup Table5'
       *  MinMax: '<S873>/Max4'
       */
      rtb_Product2_m2 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(c3, 0.0F);

      /* Sum: '<S873>/Add8' */
      rtb_Add8 = (rtb_Product4_jc + rtb_Product1_hd) + rtb_Product2_m2;

      /* Switch generated from: '<S841>/Switch2' */
      if (!rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        /* Switch generated from: '<S841>/Switch2' */
        app_B.Opt_m = rtb_Switch_ai;

        /* Switch generated from: '<S841>/Switch2' */
        app_B.LimitationViolate_k = t_end;
      }

      /* Logic: '<S870>/Logical Operator1' incorporates:
       *  RelationalOperator: '<S870>/Relational Operator2'
       *  Sum: '<S870>/Add'
       *  Sum: '<S870>/Add1'
       */
      rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (rtb_Add1_fd + rtb_Add8 < app_B.Opt_m +
        app_B.LimitationViolate_k);

      /* Switch generated from: '<S870>/Switch2' incorporates:
       *  Switch generated from: '<S729>/Switch2'
       *  Switch generated from: '<S783>/Switch2'
       *  Switch generated from: '<S812>/Switch2'
       *  Switch generated from: '<S841>/Switch2'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        s_traj_real_Spd = rtb_Reshape[5];

        /* Switch generated from: '<S841>/Switch2' */
        app_B.LimitationViolate_k = rtb_Add8;

        /* Switch generated from: '<S841>/Switch2' */
        app_B.Opt_m = rtb_Add1_fd;

        /* Gain: '<S762>/Gain1' */
        app_B.c3_f = rtb_Gain1_jl;

        /* Product: '<S762>/Divide4' */
        app_B.c4_p = rtb_Divide4_aa;

        /* Gain: '<S762>/Gain9' */
        app_B.c5_f = rtb_Gain9_m;

        /* Switch generated from: '<S870>/Switch2' */
        app_B.t_Ax_Extrem1_nf = t_Ax_Extrem1_f;

        /* Switch generated from: '<S870>/Switch2' */
        app_B.t_Ax_Extrem2_c = t_Ax_Extrem2_e;

        /* Switch: '<S759>/Switch' */
        app_B.t_Jerk_Extrem_b = rtb_Switch_i;

        /* Switch generated from: '<S870>/Switch2' */
        app_B.Ax_Extrem1_nb = Ax_Extrem1_o;

        /* Switch generated from: '<S870>/Switch2' */
        app_B.Ax_Extrem2_k = Ax_Extrem2_i;

        /* Sum: '<S759>/Add2' */
        app_B.Jerk_Extrem_h = rtb_Add2_pgh;

        /* MinMax: '<S757>/Min' */
        app_B.ax_Max_Traj_m = rtb_Min_lp;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Constant: '<S550>/Constant1'
         */
        app_B.Traj_Numb_d = 16U;
        app_B.Opt_SubIterm_e[0] = rtb_Product4_aq;
        app_B.Opt_SubIterm_e[1] = rtb_KTt_a;
        app_B.Opt_SubIterm_e[2] = rtb_K_OsV_Os_b;
        app_B.LmtViolt_SubIterm_a[0] = rtb_Product4_jc;
        app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_hd;
        app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_m2;
      } else {
        if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
          /* Switch generated from: '<S841>/Switch2' */
          s_traj_real_Spd = rtb_Reshape[4];
        } else if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
          /* Switch generated from: '<S812>/Switch2' incorporates:
           *  Switch generated from: '<S841>/Switch2'
           */
          s_traj_real_Spd = rtb_Reshape[3];
        } else if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          /* Switch generated from: '<S783>/Switch2' incorporates:
           *  Switch generated from: '<S812>/Switch2'
           *  Switch generated from: '<S841>/Switch2'
           */
          s_traj_real_Spd = rtb_Reshape[2];
        } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
          /* Switch generated from: '<S729>/Switch2' incorporates:
           *  Switch generated from: '<S783>/Switch2'
           *  Switch generated from: '<S812>/Switch2'
           *  Switch generated from: '<S841>/Switch2'
           */
          s_traj_real_Spd = rtb_Reshape[1];
        } else {
          /* Switch generated from: '<S812>/Switch2' incorporates:
           *  Switch generated from: '<S729>/Switch2'
           *  Switch generated from: '<S783>/Switch2'
           *  Switch generated from: '<S841>/Switch2'
           */
          s_traj_real_Spd = rtb_Reshape[0];
        }

        /* Switch generated from: '<S841>/Switch2' incorporates:
         *  Switch generated from: '<S729>/Switch2'
         *  Switch generated from: '<S783>/Switch2'
         *  Switch generated from: '<S812>/Switch2'
         */
        if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
          /* Gain: '<S762>/Gain1' */
          app_B.c3_f = rtb_Gain1_pv;

          /* Product: '<S762>/Divide4' */
          app_B.c4_p = rtb_Divide4_b;

          /* Gain: '<S762>/Gain9' */
          app_B.c5_f = rtb_Gain9_b;

          /* Switch generated from: '<S870>/Switch2' */
          app_B.t_Ax_Extrem1_nf = t_Ax_Extrem1_k;

          /* Switch generated from: '<S870>/Switch2' */
          app_B.t_Ax_Extrem2_c = t_Ax_Extrem2_a;

          /* Switch: '<S759>/Switch' */
          app_B.t_Jerk_Extrem_b = rtb_Switch_hv;

          /* Switch generated from: '<S870>/Switch2' */
          app_B.Ax_Extrem1_nb = Ax_Extrem1_ny;

          /* Switch generated from: '<S870>/Switch2' */
          app_B.Ax_Extrem2_k = Ax_Extrem2_e;

          /* Sum: '<S759>/Add2' */
          app_B.Jerk_Extrem_h = rtb_Add2_o;

          /* MinMax: '<S757>/Min' */
          app_B.ax_Max_Traj_m = rtb_Min_l;

          /* Switch generated from: '<S870>/Switch2' incorporates:
           *  Constant: '<S549>/Constant1'
           */
          app_B.Traj_Numb_d = 15U;
          app_B.Opt_SubIterm_e[0] = rtb_Product4_e5;
          app_B.Opt_SubIterm_e[1] = rtb_KTt_b;
          app_B.Opt_SubIterm_e[2] = rtb_K_OsV_Os_au;
          app_B.LmtViolt_SubIterm_a[0] = rtb_Product4_ge;
          app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_a4;
          app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_mv;
        } else {
          if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
            /* Gain: '<S762>/Gain1' */
            app_B.c3_f = rtb_Gain1_az;

            /* Product: '<S762>/Divide4' */
            app_B.c4_p = rtb_Divide4_b0;

            /* Gain: '<S762>/Gain9' */
            app_B.c5_f = rtb_Gain9_e;

            /* Switch generated from: '<S870>/Switch2' */
            app_B.t_Ax_Extrem1_nf = t_Ax_Extrem1_j;

            /* Switch generated from: '<S870>/Switch2' */
            app_B.t_Ax_Extrem2_c = t_Ax_Extrem2_l;

            /* Switch: '<S759>/Switch' */
            app_B.t_Jerk_Extrem_b = rtb_Switch_ddv;

            /* Switch generated from: '<S870>/Switch2' */
            app_B.Ax_Extrem1_nb = Ax_Extrem1_b;

            /* Switch generated from: '<S870>/Switch2' */
            app_B.Ax_Extrem2_k = Ax_Extrem2_j;

            /* Sum: '<S759>/Add2' */
            app_B.Jerk_Extrem_h = rtb_Add2_fb;
          } else {
            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Gain: '<S762>/Gain1' */
              app_B.c3_f = rtb_Gain1_bg;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Gain: '<S762>/Gain1' */
                app_B.c3_f = v_traj_real_Spd;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Product: '<S762>/Divide4' */
              app_B.c4_p = rtb_Divide4_h1;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Product: '<S762>/Divide4' */
                app_B.c4_p = a_traj_real_Spd_PrdtOneStp;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Gain: '<S762>/Gain9' */
              app_B.c5_f = rtb_Gain9_kp;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Gain: '<S762>/Gain9' */
                app_B.c5_f = j_traj_real_Spd;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch generated from: '<S870>/Switch2' */
              app_B.t_Ax_Extrem1_nf = t_Ax_Extrem1_e;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Switch generated from: '<S870>/Switch2' */
                app_B.t_Ax_Extrem1_nf = t_Ax_Extrem2;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch generated from: '<S870>/Switch2' */
              app_B.t_Ax_Extrem2_c = t_Ax_Extrem2_g;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Switch generated from: '<S870>/Switch2' */
                app_B.t_Ax_Extrem2_c = t_Jerk_Extrem;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch: '<S759>/Switch' */
              app_B.t_Jerk_Extrem_b = rtb_Switch_ki;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Switch: '<S759>/Switch' */
                app_B.t_Jerk_Extrem_b = Jerk_Extrem;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch generated from: '<S870>/Switch2' */
              app_B.Ax_Extrem1_nb = Ax_Extrem1_n;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Switch generated from: '<S870>/Switch2' */
                app_B.Ax_Extrem1_nb = c5;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch generated from: '<S870>/Switch2' */
              app_B.Ax_Extrem2_k = Ax_Extrem2_f;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Switch generated from: '<S870>/Switch2' */
                app_B.Ax_Extrem2_k = t_Ax_Extrem1;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Sum: '<S759>/Add2' */
              app_B.Jerk_Extrem_h = rtb_Add2_l;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* Sum: '<S759>/Add2' */
                app_B.Jerk_Extrem_h = ax_Max_Traj;
              }
            }
          }

          if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
            /* MinMax: '<S757>/Min' */
            app_B.ax_Max_Traj_m = rtb_Min_h;

            /* Switch generated from: '<S870>/Switch2' incorporates:
             *  Constant: '<S548>/Constant1'
             */
            app_B.Traj_Numb_d = 14U;
            app_B.Opt_SubIterm_e[0] = rtb_Product4_no;
            app_B.Opt_SubIterm_e[1] = rtb_KTt_m0;
            app_B.Opt_SubIterm_e[2] = rtb_K_OsV_Os_bx;
            app_B.LmtViolt_SubIterm_a[0] = rtb_Product4_j;
            app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_n3;
            app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_pl1;
          } else {
            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* MinMax: '<S757>/Min' */
              app_B.ax_Max_Traj_m = rtb_Min_p;
            } else {
              if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
                /* MinMax: '<S757>/Min' */
                app_B.ax_Max_Traj_m = Ax_Extrem1;
              }
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              /* Switch generated from: '<S870>/Switch2' incorporates:
               *  Constant: '<S547>/Constant2'
               */
              app_B.Traj_Numb_d = 13U;
            } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
              /* Switch generated from: '<S870>/Switch2' incorporates:
               *  Constant: '<S545>/Constant1'
               */
              app_B.Traj_Numb_d = 12U;
            } else {
              /* Switch generated from: '<S870>/Switch2' incorporates:
               *  Constant: '<S546>/Constant1'
               */
              app_B.Traj_Numb_d = 11U;
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              app_B.Opt_SubIterm_e[0] = rtb_Product4_p;
              app_B.Opt_SubIterm_e[1] = rtb_KTt_af;
              app_B.Opt_SubIterm_e[2] = rtb_K_OsV_Os_l;
            } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
              app_B.Opt_SubIterm_e[0] = LimitationViolate;
              app_B.Opt_SubIterm_e[1] = Opt;
              app_B.Opt_SubIterm_e[2] = c4;
            } else {
              app_B.Opt_SubIterm_e[0] = rtb_Product4_dp;
              app_B.Opt_SubIterm_e[1] = rtb_KTt_h;
              app_B.Opt_SubIterm_e[2] = rtb_K_OsV_Os_c;
            }

            if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
              app_B.LmtViolt_SubIterm_a[0] = rtb_Product4_k0;
              app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_da;
              app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_jb;
            } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
              app_B.LmtViolt_SubIterm_a[0] = Ax_Extrem2;
              app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_j2z;
              app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_jd;
            } else {
              app_B.LmtViolt_SubIterm_a[0] = rtb_Product4_lc;
              app_B.LmtViolt_SubIterm_a[1] = rtb_Product1_ei;
              app_B.LmtViolt_SubIterm_a[2] = rtb_Product2_hzb;
            }
          }
        }
      }

      /* End of Switch generated from: '<S870>/Switch2' */

      /* Abs: '<S543>/Abs1' incorporates:
       *  Sum: '<S543>/Add'
       */
      c3 = fabsf(rtb_Reshape[1] - rtb_Reshape[0]);

      /* Sum: '<S544>/Add' incorporates:
       *  Gain: '<S544>/Gain2'
       */
      rtb_Switch_ai = 0.25F * c3 + s_traj_real_Spd;

      /* Sum: '<S544>/Add1' incorporates:
       *  Gain: '<S544>/Gain4'
       */
      t_end = 0.5F * c3 + s_traj_real_Spd;

      /* Sum: '<S544>/Add2' incorporates:
       *  Gain: '<S544>/Gain5'
       */
      Merge3 = 0.75F * c3 + s_traj_real_Spd;

      /* Sum: '<S544>/Minus' incorporates:
       *  Gain: '<S544>/Gain'
       */
      Longt_Spd_C0 = s_traj_real_Spd - 0.75F * c3;

      /* Sum: '<S544>/Minus1' incorporates:
       *  Gain: '<S544>/Gain1'
       */
      Longt_Spd_C1 = s_traj_real_Spd - 0.5F * c3;

      /* Sum: '<S544>/Minus3' incorporates:
       *  Gain: '<S544>/Gain3'
       */
      c3 = s_traj_real_Spd - 0.25F * c3;

      /* Switch: '<S544>/Switch1' incorporates:
       *  Product: '<S561>/Divide8'
       *  Product: '<S589>/Divide8'
       *  Product: '<S617>/Divide8'
       *  RelationalOperator: '<S544>/Equal'
       */
      if (rtb_Reshape[0] == s_traj_real_Spd) {
        /* Switch generated from: '<S542>/Switch' */
        app_B.Collision_o = false;

        /* Switch generated from: '<S542>/Switch' */
        app_B.t_end_m = s_traj_real_Spd;

        /* Switch generated from: '<S542>/Switch' */
        app_B.Traj_valid_e = true;
      } else {
        /* Outputs for Enabled SubSystem: '<S535>/Enabled Subsystem' incorporates:
         *  EnablePort: '<S539>/Enable'
         */
        /* Product: '<S560>/Product5' incorporates:
         *  Product: '<S560>/Product1'
         *  Product: '<S560>/Product6'
         */
        j_traj_real_Spd = MultiportSwitch[2] * Longt_Spd_C0;

        /* Product: '<S560>/Product3' incorporates:
         *  Math: '<S554>/Square7'
         *  Math: '<S559>/Square1'
         *  Product: '<S554>/Product7'
         *  Product: '<S559>/Product3'
         *  Product: '<S560>/Product2'
         *  Product: '<S560>/Product4'
         */
        v_traj_real_Spd = Longt_Spd_C0 * Longt_Spd_C0;
        a_traj_real_Spd_PrdtOneStp = v_traj_real_Spd * Longt_Spd_C0;

        /* Product: '<S560>/Divide4' incorporates:
         *  Gain: '<S560>/Gain4'
         *  Gain: '<S560>/Gain5'
         *  Gain: '<S560>/Gain6'
         *  Product: '<S560>/Product3'
         *  Product: '<S560>/Product5'
         *  Sum: '<S560>/Add3'
         */
        app_B.c4_ps = (j_traj_real_Spd * 3.0F + 8.0F * MultiportSwitch[1]) *
          6.0F / a_traj_real_Spd_PrdtOneStp;

        /* Gain: '<S560>/Gain1' incorporates:
         *  Gain: '<S560>/Gain2'
         *  Gain: '<S560>/Gain3'
         *  Product: '<S560>/Divide3'
         *  Sum: '<S560>/Add1'
         */
        app_B.c3_f0 = -((2.0F * MultiportSwitch[1] + j_traj_real_Spd) * 6.0F /
                        v_traj_real_Spd);

        /* Gain: '<S560>/Gain9' incorporates:
         *  Gain: '<S560>/Gain7'
         *  Gain: '<S560>/Gain8'
         *  Product: '<S560>/Divide1'
         *  Product: '<S560>/Product2'
         *  Sum: '<S560>/Add2'
         */
        app_B.c5_i = -((3.0F * MultiportSwitch[1] + j_traj_real_Spd) * 24.0F /
                       (a_traj_real_Spd_PrdtOneStp * Longt_Spd_C0));

        /* Sum: '<S554>/Add1' incorporates:
         *  Constant: '<S554>/Constant3'
         *  Math: '<S554>/Square3'
         *  Product: '<S554>/Product3'
         */
        rtb_KTt_h = app_B.c4_ps * app_B.c4_ps - app_B.c3_f0 * app_B.c5_i * 2.0F;

        /* Sqrt: '<S554>/Sqrt' incorporates:
         *  Abs: '<S554>/Abs'
         *  Sqrt: '<S554>/Sqrt1'
         */
        LimitationViolate = sqrtf(fabsf(rtb_KTt_h));

        /* Product: '<S554>/Divide2' incorporates:
         *  Gain: '<S554>/Gain'
         *  Sqrt: '<S554>/Sqrt'
         *  Sum: '<S554>/Add3'
         */
        j_traj_real_Spd = (-app_B.c4_ps + LimitationViolate) / app_B.c5_i;

        /* Product: '<S554>/Divide3' incorporates:
         *  Gain: '<S554>/Gain1'
         *  Sum: '<S554>/Add4'
         */
        c4 = (-app_B.c4_ps - LimitationViolate) / app_B.c5_i;

        /* Product: '<S554>/Product6' incorporates:
         *  Product: '<S559>/Product'
         */
        LimitationViolate = app_B.c3_f0 * Longt_Spd_C0;

        /* Sum: '<S554>/Add6' incorporates:
         *  Constant: '<S554>/Constant10'
         *  Constant: '<S554>/Constant9'
         *  Product: '<S554>/Divide6'
         *  Product: '<S554>/Divide7'
         *  Product: '<S554>/Product6'
         */
        Opt = ((LimitationViolate + MultiportSwitch[2]) + app_B.c4_ps / 2.0F *
               v_traj_real_Spd) + a_traj_real_Spd_PrdtOneStp * (app_B.c5_i /
          6.0F);

        /* If: '<S554>/If' incorporates:
         *  Constant: '<S554>/Constant1'
         *  Constant: '<S554>/Constant2'
         *  Constant: '<S554>/Constant5'
         *  Constant: '<S554>/Constant7'
         *  Constant: '<S554>/Constant8'
         *  Math: '<S554>/Square1'
         *  Math: '<S554>/Square2'
         *  Math: '<S554>/Square4'
         *  Math: '<S554>/Square5'
         *  Product: '<S554>/Divide'
         *  Product: '<S554>/Divide1'
         *  Product: '<S554>/Divide4'
         *  Product: '<S554>/Divide5'
         *  Product: '<S554>/Product1'
         *  Product: '<S554>/Product2'
         *  Product: '<S554>/Product4'
         *  Product: '<S554>/Product5'
         *  Sum: '<S554>/Add2'
         *  Sum: '<S554>/Add5'
         */
        if (rtb_KTt_h < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S554>/If Action Subsystem' incorporates:
           *  ActionPort: '<S562>/Action Port'
           */
          app_IfActionSubsystem(Opt, 0.0F, Longt_Spd_C0, &app_B.Ax_Extrem1_m,
                                &app_B.Ax_Extrem2_d, &app_B.t_Ax_Extrem1_nt,
                                &app_B.t_Ax_Extrem2_i);

          /* End of Outputs for SubSystem: '<S554>/If Action Subsystem' */
        } else if (rtb_KTt_h == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S554>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S563>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + app_B.c3_f0 *
            j_traj_real_Spd) + app_B.c4_ps / 2.0F * (j_traj_real_Spd *
            j_traj_real_Spd)) + app_B.c5_i / 6.0F * (j_traj_real_Spd *
            j_traj_real_Spd * j_traj_real_Spd), ((MultiportSwitch[2] +
            app_B.c3_f0 * c4) + app_B.c4_ps / 2.0F * (c4 * c4)) + app_B.c5_i /
            6.0F * (c4 * c4 * c4), j_traj_real_Spd, &app_B.Ax_Extrem1_m,
            &app_B.Ax_Extrem2_d, &app_B.t_Ax_Extrem1_nt, &app_B.t_Ax_Extrem2_i);

          /* End of Outputs for SubSystem: '<S554>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S554>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S564>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + app_B.c3_f0 *
            j_traj_real_Spd) + app_B.c4_ps / 2.0F * (j_traj_real_Spd *
            j_traj_real_Spd)) + app_B.c5_i / 6.0F * (j_traj_real_Spd *
            j_traj_real_Spd * j_traj_real_Spd), ((MultiportSwitch[2] +
            app_B.c3_f0 * c4) + app_B.c4_ps / 2.0F * (c4 * c4)) + app_B.c5_i /
            6.0F * (c4 * c4 * c4), j_traj_real_Spd, c4, &app_B.Ax_Extrem1_m,
            &app_B.Ax_Extrem2_d, &app_B.t_Ax_Extrem1_nt, &app_B.t_Ax_Extrem2_i);

          /* End of Outputs for SubSystem: '<S554>/If Action Subsystem2' */
        }

        /* End of If: '<S554>/If' */

        /* MinMax: '<S554>/Min' */
        app_B.ax_Max_Traj_mm = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Opt),
          app_B.Ax_Extrem1_m), app_B.Ax_Extrem2_d);

        /* Product: '<S559>/Product4' incorporates:
         *  Constant: '<S559>/Constant1'
         *  Constant: '<S559>/Constant2'
         *  Gain: '<S559>/Gain'
         *  Product: '<S559>/Product1'
         *  Product: '<S559>/Product2'
         *  Sum: '<S559>/Add'
         */
        v_traj_real_Spd = ((0.5F * app_B.c4_ps * v_traj_real_Spd +
                            LimitationViolate) + a_traj_real_Spd_PrdtOneStp *
                           (0.166666672F * app_B.c5_i)) * 0.0F * nDLookupTable1;

        /* Product: '<S559>/Product5' */
        a_traj_real_Spd_PrdtOneStp = rtb_Switch_ik * Longt_Spd_C0;

        /* Product: '<S561>/Divide9' incorporates:
         *  Constant: '<S561>/Constant5'
         */
        j_traj_real_Spd = app_B.c5_i * 0.0416666679F;

        /* Sum: '<S561>/Add2' incorporates:
         *  Constant: '<S561>/Constant1'
         *  Constant: '<S561>/Constant2'
         *  Product: '<S561>/Divide1'
         *  Product: '<S561>/Divide3'
         */
        LimitationViolate = 2.0F * j_traj_real_Spd * Longt_Spd_C0 + app_B.c4_ps *
          0.166666672F;

        /* Outputs for Atomic SubSystem: '<S561>/SfD'
         *
         * Block description for '<S561>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], Longt_Spd_C0 * Longt_Spd_C0,
                  &rtb_K_OsV_Os_c, 0.01F);

        /* End of Outputs for SubSystem: '<S561>/SfD' */

        /* Sum: '<S561>/Add4' incorporates:
         *  Constant: '<S561>/Constant16'
         *  Product: '<S561>/Divide8'
         *  Product: '<S561>/Multiply7'
         *  Product: '<S561>/Multiply8'
         */
        c4 = LimitationViolate * LimitationViolate - 4.0F * j_traj_real_Spd *
          rtb_K_OsV_Os_c;

        /* If: '<S561>/If' */
        if ((j_traj_real_Spd != 0.0F) && (c4 >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem' incorporates:
           *  ActionPort: '<S571>/Action Port'
           */
          app_IfActionSubsystem_c(j_traj_real_Spd, LimitationViolate, c4,
            Longt_Spd_C0, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem' */
        } else if ((j_traj_real_Spd == 0.0F) && (LimitationViolate != 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S572>/Action Port'
           */
          app_IfActionSubsystem1_h(LimitationViolate, rtb_K_OsV_Os_c,
            Longt_Spd_C0, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S573>/Action Port'
           */
          /* SignalConversion: '<S573>/Signal Conversion' */
          rtb_Switch1_g[0] = Longt_Spd_C0;
          rtb_Switch1_g[1] = Longt_Spd_C0;

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem2' */
        }

        /* End of If: '<S561>/If' */

        /* Sum: '<S569>/Add' incorporates:
         *  Gain: '<S569>/Gain'
         *  Gain: '<S569>/Gain1'
         *  Gain: '<S569>/Gain2'
         *  Product: '<S569>/Multiply'
         *  Product: '<S569>/Multiply1'
         *  Product: '<S569>/Multiply2'
         *  Product: '<S569>/Multiply3'
         */
        LimitationViolate = ((app_B.c3_f0 * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                              0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
          MultiportSwitch[1])) + app_B.c4_ps * rtb_Switch1_g[0] * rtb_Switch1_g
                             [0] * rtb_Switch1_g[0] * 0.166666672F) + app_B.c5_i
          * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
          rtb_Switch1_g[0] * 0.0416666679F;

        /* Product: '<S561>/Multiply9' */
        rtb_Product4_dp = MultiportSwitch[1] * LimitationViolate;

        /* Sum: '<S570>/Add' incorporates:
         *  Gain: '<S570>/Gain'
         *  Gain: '<S570>/Gain1'
         *  Gain: '<S570>/Gain2'
         *  Product: '<S570>/Multiply'
         *  Product: '<S570>/Multiply1'
         *  Product: '<S570>/Multiply2'
         *  Product: '<S570>/Multiply3'
         */
        c4 = ((app_B.c3_f0 * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
               (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch[1])) +
              app_B.c4_ps * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g
              [1] * 0.166666672F) + app_B.c5_i * rtb_Switch1_g[1] *
          rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

        /* Product: '<S561>/Multiply10' */
        j_traj_real_Spd = MultiportSwitch[1] * c4;

        /* If: '<S561>/If1' */
        if ((rtb_Product4_dp < 0.0F) && (j_traj_real_Spd >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S574>/Action Port'
           */
          app_IfActionSubsystem3(LimitationViolate, &j_traj_real_Spd);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem3' */
        } else if ((rtb_Product4_dp >= 0.0F) && (j_traj_real_Spd < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S575>/Action Port'
           */
          app_IfActionSubsystem4(c4, &j_traj_real_Spd);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem4' */
        } else if ((rtb_Product4_dp < 0.0F) && (j_traj_real_Spd < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S576>/Action Port'
           */
          app_IfActionSubsystem5(LimitationViolate, c4, &j_traj_real_Spd);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S561>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S577>/Action Port'
           */
          app_IfActionSubsystem6(&j_traj_real_Spd);

          /* End of Outputs for SubSystem: '<S561>/If Action Subsystem6' */
        }

        /* End of If: '<S561>/If1' */

        /* Product: '<S559>/Product6' */
        LimitationViolate = rtb_ACC_t_FTCDsrdDistLv2_sg * j_traj_real_Spd;

        /* Sum: '<S559>/Add1' */
        rtb_Product4_dp = (v_traj_real_Spd + a_traj_real_Spd_PrdtOneStp) +
          LimitationViolate;

        /* Product: '<S558>/Product4' incorporates:
         *  Abs: '<S558>/Abs'
         *  MinMax: '<S554>/Min1'
         *  MinMax: '<S558>/Max5'
         */
        Opt = rtb_Product_eqe * fmaxf(app_B.ax_Max_Traj_mm, fabsf(fminf(fminf
          (fminf(MultiportSwitch[2], Opt), app_B.Ax_Extrem1_m),
          app_B.Ax_Extrem2_d)));

        /* Switch: '<S557>/Switch' incorporates:
         *  Constant: '<S568>/Constant'
         *  RelationalOperator: '<S568>/Compare'
         */
        if (app_B.c5_i != 0.0F) {
          /* Switch: '<S557>/Switch' incorporates:
           *  Gain: '<S557>/Gain'
           *  Product: '<S557>/Divide1'
           */
          app_B.t_Jerk_Extrem_i = -app_B.c4_ps / app_B.c5_i;
        } else {
          /* Switch: '<S557>/Switch' incorporates:
           *  Constant: '<S557>/Invalid'
           */
          app_B.t_Jerk_Extrem_i = 0.0F;
        }

        /* End of Switch: '<S557>/Switch' */

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Product: '<S557>/Divide3'
         */
        app_B.Opt_mq = app_B.c5_i * app_B.t_Jerk_Extrem_i;

        /* Sum: '<S557>/Add2' incorporates:
         *  Math: '<S557>/Square2'
         *  Product: '<S557>/Divide2'
         */
        app_B.Jerk_Extrem_n = (app_B.c4_ps * app_B.t_Jerk_Extrem_i + app_B.c3_f0)
          + app_B.Opt_mq * app_B.Opt_mq;

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Constant: '<S557>/t_Start'
         *  Math: '<S557>/Square1'
         *  Product: '<S557>/Divide4'
         *  Product: '<S557>/Divide5'
         *  Sum: '<S557>/Add1'
         */
        app_B.Opt_mq = app_B.c5_i * 0.0F;
        app_B.Opt_mq = (app_B.c4_ps * 0.0F + app_B.c3_f0) + app_B.Opt_mq *
          app_B.Opt_mq;

        /* Product: '<S557>/Divide7' */
        t_Ax_Extrem2_g = app_B.c5_i * Longt_Spd_C0;

        /* Sum: '<S557>/Add3' incorporates:
         *  Math: '<S557>/Square3'
         *  Product: '<S557>/Divide6'
         */
        t_Ax_Extrem2_g = (app_B.c4_ps * Longt_Spd_C0 + app_B.c3_f0) +
          t_Ax_Extrem2_g * t_Ax_Extrem2_g;

        /* MinMax: '<S557>/Min' */
        rtb_KTt_h = fmaxf(fmaxf(app_B.Jerk_Extrem_n, app_B.Opt_mq),
                          t_Ax_Extrem2_g);

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Abs: '<S558>/Abs2'
         *  MinMax: '<S557>/Min1'
         */
        app_B.Opt_mq = fminf(fminf(app_B.Jerk_Extrem_n, app_B.Opt_mq),
                             t_Ax_Extrem2_g);
        app_B.Opt_mq = fabsf(app_B.Opt_mq);

        /* Product: '<S558>/Product1' incorporates:
         *  MinMax: '<S558>/Max6'
         */
        c4 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_KTt_h, app_B.Opt_mq);

        /* Sum: '<S558>/Add5' incorporates:
         *  Constant: '<S551>/Constant'
         */
        j_traj_real_Spd -= 0.277777791F;

        /* Product: '<S558>/Product2' incorporates:
         *  Constant: '<S558>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S558>/Max4'
         */
        c5 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(j_traj_real_Spd, 0.0F);

        /* Sum: '<S558>/Add8' */
        j_traj_real_Spd = (Opt + c4) + c5;

        /* Logic: '<S555>/Logical Operator1' incorporates:
         *  RelationalOperator: '<S555>/Relational Operator2'
         *  Sum: '<S555>/Add'
         *  Sum: '<S555>/Add1'
         */
        rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = (rtb_Product4_dp + j_traj_real_Spd <
          app_B.Opt_m + app_B.LimitationViolate_k);

        /* Switch generated from: '<S555>/Switch2' */
        if (!rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
          j_traj_real_Spd = app_B.LimitationViolate_k;
          rtb_Product4_dp = app_B.Opt_m;
        }

        /* Product: '<S588>/Product5' incorporates:
         *  Product: '<S588>/Product1'
         *  Product: '<S588>/Product6'
         */
        t_Jerk_Extrem = MultiportSwitch[2] * Longt_Spd_C1;

        /* Product: '<S588>/Product3' incorporates:
         *  Math: '<S582>/Square7'
         *  Math: '<S587>/Square1'
         *  Product: '<S582>/Product7'
         *  Product: '<S587>/Product3'
         *  Product: '<S588>/Product2'
         *  Product: '<S588>/Product4'
         */
        rtb_Product2_jd = Longt_Spd_C1 * Longt_Spd_C1;
        rtb_KTt_a = rtb_Product2_jd * Longt_Spd_C1;

        /* Product: '<S588>/Divide4' incorporates:
         *  Gain: '<S588>/Gain4'
         *  Gain: '<S588>/Gain5'
         *  Gain: '<S588>/Gain6'
         *  Product: '<S588>/Product3'
         *  Product: '<S588>/Product5'
         *  Sum: '<S588>/Add3'
         */
        t_Ax_Extrem1 = (t_Jerk_Extrem * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F
          / rtb_KTt_a;

        /* Gain: '<S588>/Gain1' incorporates:
         *  Gain: '<S588>/Gain2'
         *  Gain: '<S588>/Gain3'
         *  Product: '<S588>/Divide3'
         *  Sum: '<S588>/Add1'
         */
        t_Ax_Extrem2 = -((2.0F * MultiportSwitch[1] + t_Jerk_Extrem) * 6.0F /
                         rtb_Product2_jd);

        /* Gain: '<S588>/Gain9' incorporates:
         *  Gain: '<S588>/Gain7'
         *  Gain: '<S588>/Gain8'
         *  Product: '<S588>/Divide1'
         *  Product: '<S588>/Product2'
         *  Sum: '<S588>/Add2'
         */
        t_Jerk_Extrem = -((3.0F * MultiportSwitch[1] + t_Jerk_Extrem) * 24.0F /
                          (rtb_KTt_a * Longt_Spd_C1));

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Constant: '<S582>/Constant3'
         *  Math: '<S582>/Square3'
         *  Product: '<S582>/Product3'
         *  Sum: '<S582>/Add1'
         */
        app_B.Opt_mq = t_Ax_Extrem1 * t_Ax_Extrem1 - t_Ax_Extrem2 *
          t_Jerk_Extrem * 2.0F;

        /* Sqrt: '<S582>/Sqrt' incorporates:
         *  Abs: '<S582>/Abs'
         *  Sqrt: '<S582>/Sqrt1'
         */
        Ax_Extrem1 = sqrtf(fabsf(app_B.Opt_mq));

        /* Product: '<S582>/Divide2' incorporates:
         *  Gain: '<S582>/Gain'
         *  Sqrt: '<S582>/Sqrt'
         *  Sum: '<S582>/Add3'
         */
        rtb_Product1_j2z = (-t_Ax_Extrem1 + Ax_Extrem1) / t_Jerk_Extrem;

        /* Product: '<S582>/Divide3' incorporates:
         *  Gain: '<S582>/Gain1'
         *  Sum: '<S582>/Add4'
         */
        rtb_Product4_aq = (-t_Ax_Extrem1 - Ax_Extrem1) / t_Jerk_Extrem;

        /* Product: '<S582>/Product6' incorporates:
         *  Product: '<S587>/Product'
         */
        rtb_K_OsV_Os_c = t_Ax_Extrem2 * Longt_Spd_C1;

        /* Sum: '<S582>/Add6' incorporates:
         *  Constant: '<S582>/Constant10'
         *  Constant: '<S582>/Constant9'
         *  Product: '<S582>/Divide6'
         *  Product: '<S582>/Divide7'
         *  Product: '<S582>/Product6'
         */
        rtb_KTt_h = ((rtb_K_OsV_Os_c + MultiportSwitch[2]) + t_Ax_Extrem1 / 2.0F
                     * rtb_Product2_jd) + rtb_KTt_a * (t_Jerk_Extrem / 6.0F);

        /* If: '<S582>/If' incorporates:
         *  Constant: '<S582>/Constant1'
         *  Constant: '<S582>/Constant2'
         *  Constant: '<S582>/Constant5'
         *  Constant: '<S582>/Constant7'
         *  Constant: '<S582>/Constant8'
         *  Math: '<S582>/Square1'
         *  Math: '<S582>/Square2'
         *  Math: '<S582>/Square4'
         *  Math: '<S582>/Square5'
         *  Product: '<S582>/Divide'
         *  Product: '<S582>/Divide1'
         *  Product: '<S582>/Divide4'
         *  Product: '<S582>/Divide5'
         *  Product: '<S582>/Product1'
         *  Product: '<S582>/Product2'
         *  Product: '<S582>/Product4'
         *  Product: '<S582>/Product5'
         *  Sum: '<S582>/Add2'
         *  Sum: '<S582>/Add5'
         */
        if (app_B.Opt_mq < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S582>/If Action Subsystem' incorporates:
           *  ActionPort: '<S590>/Action Port'
           */
          app_IfActionSubsystem(rtb_KTt_h, 0.0F, Longt_Spd_C1, &Jerk_Extrem,
                                &ax_Max_Traj, &Ax_Extrem1, &Ax_Extrem2);

          /* End of Outputs for SubSystem: '<S582>/If Action Subsystem' */
        } else if (app_B.Opt_mq == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S582>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S591>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + t_Ax_Extrem2 *
            rtb_Product1_j2z) + t_Ax_Extrem1 / 2.0F * (rtb_Product1_j2z *
            rtb_Product1_j2z)) + t_Jerk_Extrem / 6.0F * (rtb_Product1_j2z *
            rtb_Product1_j2z * rtb_Product1_j2z), ((MultiportSwitch[2] +
            t_Ax_Extrem2 * rtb_Product4_aq) + t_Ax_Extrem1 / 2.0F *
            (rtb_Product4_aq * rtb_Product4_aq)) + t_Jerk_Extrem / 6.0F *
            (rtb_Product4_aq * rtb_Product4_aq * rtb_Product4_aq),
            rtb_Product1_j2z, &Jerk_Extrem, &ax_Max_Traj, &Ax_Extrem1,
            &Ax_Extrem2);

          /* End of Outputs for SubSystem: '<S582>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S582>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S592>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + t_Ax_Extrem2 *
            rtb_Product1_j2z) + t_Ax_Extrem1 / 2.0F * (rtb_Product1_j2z *
            rtb_Product1_j2z)) + t_Jerk_Extrem / 6.0F * (rtb_Product1_j2z *
            rtb_Product1_j2z * rtb_Product1_j2z), ((MultiportSwitch[2] +
            t_Ax_Extrem2 * rtb_Product4_aq) + t_Ax_Extrem1 / 2.0F *
            (rtb_Product4_aq * rtb_Product4_aq)) + t_Jerk_Extrem / 6.0F *
            (rtb_Product4_aq * rtb_Product4_aq * rtb_Product4_aq),
            rtb_Product1_j2z, rtb_Product4_aq, &Jerk_Extrem, &ax_Max_Traj,
            &Ax_Extrem1, &Ax_Extrem2);

          /* End of Outputs for SubSystem: '<S582>/If Action Subsystem2' */
        }

        /* End of If: '<S582>/If' */

        /* MinMax: '<S582>/Min' */
        rtb_Product1_j2z = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], rtb_KTt_h),
          Jerk_Extrem), ax_Max_Traj);

        /* Product: '<S587>/Product4' incorporates:
         *  Constant: '<S587>/Constant1'
         *  Constant: '<S587>/Constant2'
         *  Gain: '<S587>/Gain'
         *  Product: '<S587>/Product1'
         *  Product: '<S587>/Product2'
         *  Sum: '<S587>/Add'
         */
        rtb_Product2_jd = ((0.5F * t_Ax_Extrem1 * rtb_Product2_jd +
                            rtb_K_OsV_Os_c) + rtb_KTt_a * (0.166666672F *
          t_Jerk_Extrem)) * 0.0F * nDLookupTable1;

        /* Product: '<S587>/Product5' */
        rtb_KTt_a = rtb_Switch_ik * Longt_Spd_C1;

        /* Product: '<S589>/Divide9' incorporates:
         *  Constant: '<S589>/Constant5'
         */
        rtb_Product4_aq = t_Jerk_Extrem * 0.0416666679F;

        /* Sum: '<S589>/Add2' incorporates:
         *  Constant: '<S589>/Constant1'
         *  Constant: '<S589>/Constant2'
         *  Product: '<S589>/Divide1'
         *  Product: '<S589>/Divide3'
         */
        rtb_Product4_lc = 2.0F * rtb_Product4_aq * Longt_Spd_C1 + t_Ax_Extrem1 *
          0.166666672F;

        /* Outputs for Atomic SubSystem: '<S589>/SfD'
         *
         * Block description for '<S589>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], Longt_Spd_C1 * Longt_Spd_C1,
                  &rtb_K_OsV_Os_c, 0.01F);

        /* End of Outputs for SubSystem: '<S589>/SfD' */

        /* Sum: '<S589>/Add4' incorporates:
         *  Constant: '<S589>/Constant16'
         *  Product: '<S589>/Divide8'
         *  Product: '<S589>/Multiply7'
         *  Product: '<S589>/Multiply8'
         */
        rtb_Product1_ei = rtb_Product4_lc * rtb_Product4_lc - 4.0F *
          rtb_Product4_aq * rtb_K_OsV_Os_c;

        /* If: '<S589>/If' */
        if ((rtb_Product4_aq != 0.0F) && (rtb_Product1_ei >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem' incorporates:
           *  ActionPort: '<S599>/Action Port'
           */
          app_IfActionSubsystem_c(rtb_Product4_aq, rtb_Product4_lc,
            rtb_Product1_ei, Longt_Spd_C1, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem' */
        } else if ((rtb_Product4_aq == 0.0F) && (rtb_Product4_lc != 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S600>/Action Port'
           */
          app_IfActionSubsystem1_h(rtb_Product4_lc, rtb_K_OsV_Os_c, Longt_Spd_C1,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S601>/Action Port'
           */
          /* SignalConversion: '<S601>/Signal Conversion' */
          rtb_Switch1_g[0] = Longt_Spd_C1;
          rtb_Switch1_g[1] = Longt_Spd_C1;

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem2' */
        }

        /* End of If: '<S589>/If' */

        /* Sum: '<S597>/Add' incorporates:
         *  Gain: '<S597>/Gain'
         *  Gain: '<S597>/Gain1'
         *  Gain: '<S597>/Gain2'
         *  Product: '<S597>/Multiply'
         *  Product: '<S597>/Multiply1'
         *  Product: '<S597>/Multiply2'
         *  Product: '<S597>/Multiply3'
         */
        rtb_K_OsV_Os_c = ((t_Ax_Extrem2 * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                           0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
          MultiportSwitch[1])) + t_Ax_Extrem1 * rtb_Switch1_g[0] *
                          rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
          t_Jerk_Extrem * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0]
          * rtb_Switch1_g[0] * 0.0416666679F;

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Product: '<S589>/Multiply9'
         */
        app_B.Opt_mq = MultiportSwitch[1] * rtb_K_OsV_Os_c;

        /* Sum: '<S598>/Add' incorporates:
         *  Gain: '<S598>/Gain'
         *  Gain: '<S598>/Gain1'
         *  Gain: '<S598>/Gain2'
         *  Product: '<S598>/Multiply'
         *  Product: '<S598>/Multiply1'
         *  Product: '<S598>/Multiply2'
         *  Product: '<S598>/Multiply3'
         */
        rtb_Product4_aq = ((t_Ax_Extrem2 * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                            0.5F + (MultiportSwitch[2] * rtb_Switch1_g[1] +
          MultiportSwitch[1])) + t_Ax_Extrem1 * rtb_Switch1_g[1] *
                           rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.166666672F) +
          t_Jerk_Extrem * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1]
          * rtb_Switch1_g[1] * 0.0416666679F;

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Product: '<S589>/Multiply10'
         */
        app_B.LimitationViolate_p = MultiportSwitch[1] * rtb_Product4_aq;

        /* If: '<S589>/If1' */
        if ((app_B.Opt_mq < 0.0F) && (app_B.LimitationViolate_p >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S602>/Action Port'
           */
          app_IfActionSubsystem3(rtb_K_OsV_Os_c, &app_B.LimitationViolate_p);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem3' */
        } else if ((app_B.Opt_mq >= 0.0F) && (app_B.LimitationViolate_p < 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S603>/Action Port'
           */
          app_IfActionSubsystem4(rtb_Product4_aq, &app_B.LimitationViolate_p);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem4' */
        } else if ((app_B.Opt_mq < 0.0F) && (app_B.LimitationViolate_p < 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S604>/Action Port'
           */
          app_IfActionSubsystem5(rtb_K_OsV_Os_c, rtb_Product4_aq,
            &app_B.LimitationViolate_p);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S589>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S605>/Action Port'
           */
          app_IfActionSubsystem6(&app_B.LimitationViolate_p);

          /* End of Outputs for SubSystem: '<S589>/If Action Subsystem6' */
        }

        /* End of If: '<S589>/If1' */

        /* Product: '<S587>/Product6' */
        rtb_Product4_aq = rtb_ACC_t_FTCDsrdDistLv2_sg *
          app_B.LimitationViolate_p;

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Sum: '<S587>/Add1'
         */
        app_B.Opt_mq = (rtb_Product2_jd + rtb_KTt_a) + rtb_Product4_aq;

        /* Product: '<S586>/Product4' incorporates:
         *  Abs: '<S586>/Abs'
         *  MinMax: '<S582>/Min1'
         *  MinMax: '<S586>/Max5'
         */
        rtb_Product4_lc = rtb_Product_eqe * fmaxf(rtb_Product1_j2z, fabsf(fminf
          (fminf(fminf(MultiportSwitch[2], rtb_KTt_h), Jerk_Extrem), ax_Max_Traj)));

        /* Switch: '<S585>/Switch' incorporates:
         *  Constant: '<S585>/Invalid'
         *  Constant: '<S596>/Constant'
         *  Gain: '<S585>/Gain'
         *  Product: '<S585>/Divide1'
         *  RelationalOperator: '<S596>/Compare'
         */
        if (t_Jerk_Extrem != 0.0F) {
          rtb_Product1_ei = -t_Ax_Extrem1 / t_Jerk_Extrem;
        } else {
          rtb_Product1_ei = 0.0F;
        }

        /* End of Switch: '<S585>/Switch' */

        /* Product: '<S585>/Divide3' */
        rtb_Product2_hzb = t_Jerk_Extrem * rtb_Product1_ei;

        /* Sum: '<S585>/Add2' incorporates:
         *  Math: '<S585>/Square2'
         *  Product: '<S585>/Divide2'
         */
        rtb_Product4_p = (t_Ax_Extrem1 * rtb_Product1_ei + t_Ax_Extrem2) +
          rtb_Product2_hzb * rtb_Product2_hzb;

        /* Product: '<S585>/Divide5' incorporates:
         *  Constant: '<S585>/t_Start'
         */
        rtb_Product2_hzb = t_Jerk_Extrem * 0.0F;

        /* Sum: '<S585>/Add1' incorporates:
         *  Constant: '<S585>/t_Start'
         *  Math: '<S585>/Square1'
         *  Product: '<S585>/Divide4'
         */
        rtb_Product2_hzb = (t_Ax_Extrem1 * 0.0F + t_Ax_Extrem2) +
          rtb_Product2_hzb * rtb_Product2_hzb;

        /* Product: '<S585>/Divide7' */
        t_Ax_Extrem2_g = t_Jerk_Extrem * Longt_Spd_C1;

        /* Sum: '<S585>/Add3' incorporates:
         *  Math: '<S585>/Square3'
         *  Product: '<S585>/Divide6'
         */
        t_Ax_Extrem2_g = (t_Ax_Extrem1 * Longt_Spd_C1 + t_Ax_Extrem2) +
          t_Ax_Extrem2_g * t_Ax_Extrem2_g;

        /* MinMax: '<S585>/Min' */
        rtb_KTt_h = fmaxf(fmaxf(rtb_Product4_p, rtb_Product2_hzb),
                          t_Ax_Extrem2_g);

        /* MinMax: '<S585>/Min1' */
        rtb_Product2_hzb = fminf(fminf(rtb_Product4_p, rtb_Product2_hzb),
          t_Ax_Extrem2_g);

        /* Abs: '<S586>/Abs2' */
        rtb_Product2_hzb = fabsf(rtb_Product2_hzb);

        /* Product: '<S586>/Product1' incorporates:
         *  MinMax: '<S586>/Max6'
         */
        rtb_Gain1_bg = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_KTt_h,
          rtb_Product2_hzb);

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Constant: '<S552>/Constant'
         *  Sum: '<S586>/Add5'
         */
        app_B.LimitationViolate_p -= 0.277777791F;

        /* Product: '<S586>/Product2' incorporates:
         *  Constant: '<S586>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S586>/Max4'
         */
        rtb_Divide4_h1 = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf
          (app_B.LimitationViolate_p, 0.0F);

        /* Switch generated from: '<S583>/Switch2' incorporates:
         *  Sum: '<S586>/Add8'
         */
        app_B.LimitationViolate_p = (rtb_Product4_lc + rtb_Gain1_bg) +
          rtb_Divide4_h1;

        /* Logic: '<S583>/Logical Operator1' incorporates:
         *  RelationalOperator: '<S583>/Relational Operator2'
         *  Sum: '<S583>/Add'
         *  Sum: '<S583>/Add1'
         */
        rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = (app_B.Opt_mq +
          app_B.LimitationViolate_p < rtb_Product4_dp + j_traj_real_Spd);

        /* Switch generated from: '<S583>/Switch2' */
        if (!rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          /* Switch generated from: '<S583>/Switch2' */
          app_B.LimitationViolate_p = j_traj_real_Spd;

          /* Switch generated from: '<S583>/Switch2' */
          app_B.Opt_mq = rtb_Product4_dp;
        }

        /* Product: '<S616>/Product5' incorporates:
         *  Product: '<S616>/Product1'
         *  Product: '<S616>/Product6'
         */
        j_traj_real_Spd = MultiportSwitch[2] * c3;

        /* Product: '<S616>/Product3' incorporates:
         *  Math: '<S610>/Square7'
         *  Math: '<S615>/Square1'
         *  Product: '<S610>/Product7'
         *  Product: '<S615>/Product3'
         *  Product: '<S616>/Product2'
         *  Product: '<S616>/Product4'
         */
        rtb_KTt_h = c3 * c3;
        rtb_K_OsV_Os_c = rtb_KTt_h * c3;

        /* Product: '<S616>/Divide4' incorporates:
         *  Gain: '<S616>/Gain4'
         *  Gain: '<S616>/Gain5'
         *  Gain: '<S616>/Gain6'
         *  Product: '<S616>/Product3'
         *  Product: '<S616>/Product5'
         *  Sum: '<S616>/Add3'
         */
        rtb_Gain9_kp = (j_traj_real_Spd * 3.0F + 8.0F * MultiportSwitch[1]) *
          6.0F / rtb_K_OsV_Os_c;

        /* Gain: '<S616>/Gain1' incorporates:
         *  Gain: '<S616>/Gain2'
         *  Gain: '<S616>/Gain3'
         *  Product: '<S616>/Divide3'
         *  Sum: '<S616>/Add1'
         */
        rtb_Product2_hzb = -((2.0F * MultiportSwitch[1] + j_traj_real_Spd) *
                             6.0F / rtb_KTt_h);

        /* Gain: '<S616>/Gain9' incorporates:
         *  Gain: '<S616>/Gain7'
         *  Gain: '<S616>/Gain8'
         *  Product: '<S616>/Divide1'
         *  Product: '<S616>/Product2'
         *  Sum: '<S616>/Add2'
         */
        rtb_KTt_af = -((3.0F * MultiportSwitch[1] + j_traj_real_Spd) * 24.0F /
                       (rtb_K_OsV_Os_c * c3));

        /* Sum: '<S610>/Add1' incorporates:
         *  Constant: '<S610>/Constant3'
         *  Math: '<S610>/Square3'
         *  Product: '<S610>/Product3'
         */
        j_traj_real_Spd = rtb_Gain9_kp * rtb_Gain9_kp - rtb_Product2_hzb *
          rtb_KTt_af * 2.0F;

        /* Sqrt: '<S610>/Sqrt' incorporates:
         *  Abs: '<S610>/Abs'
         *  Sqrt: '<S610>/Sqrt1'
         */
        rtb_Product4_dp = sqrtf(fabsf(j_traj_real_Spd));

        /* Product: '<S610>/Divide2' incorporates:
         *  Gain: '<S610>/Gain'
         *  Sqrt: '<S610>/Sqrt'
         *  Sum: '<S610>/Add3'
         */
        t_Ax_Extrem2_g = (-rtb_Gain9_kp + rtb_Product4_dp) / rtb_KTt_af;

        /* Product: '<S610>/Divide3' incorporates:
         *  Gain: '<S610>/Gain1'
         *  Sum: '<S610>/Add4'
         */
        rtb_Min_p = (-rtb_Gain9_kp - rtb_Product4_dp) / rtb_KTt_af;

        /* Product: '<S610>/Product6' incorporates:
         *  Product: '<S615>/Product'
         */
        rtb_Product4_k0 = rtb_Product2_hzb * c3;

        /* Sum: '<S610>/Add6' incorporates:
         *  Constant: '<S610>/Constant10'
         *  Constant: '<S610>/Constant9'
         *  Product: '<S610>/Divide6'
         *  Product: '<S610>/Divide7'
         *  Product: '<S610>/Product6'
         */
        rtb_Product4_dp = ((rtb_Product4_k0 + MultiportSwitch[2]) + rtb_Gain9_kp
                           / 2.0F * rtb_KTt_h) + rtb_K_OsV_Os_c * (rtb_KTt_af /
          6.0F);

        /* If: '<S610>/If' incorporates:
         *  Constant: '<S610>/Constant1'
         *  Constant: '<S610>/Constant2'
         *  Constant: '<S610>/Constant5'
         *  Constant: '<S610>/Constant7'
         *  Constant: '<S610>/Constant8'
         *  Math: '<S610>/Square1'
         *  Math: '<S610>/Square2'
         *  Math: '<S610>/Square4'
         *  Math: '<S610>/Square5'
         *  Product: '<S610>/Divide'
         *  Product: '<S610>/Divide1'
         *  Product: '<S610>/Divide4'
         *  Product: '<S610>/Divide5'
         *  Product: '<S610>/Product1'
         *  Product: '<S610>/Product2'
         *  Product: '<S610>/Product4'
         *  Product: '<S610>/Product5'
         *  Sum: '<S610>/Add2'
         *  Sum: '<S610>/Add5'
         */
        if (j_traj_real_Spd < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S610>/If Action Subsystem' incorporates:
           *  ActionPort: '<S618>/Action Port'
           */
          app_IfActionSubsystem(rtb_Product4_dp, 0.0F, c3, &Ax_Extrem2_f,
                                &t_Ax_Extrem1_e, &rtb_K_OsV_Os_l, &Ax_Extrem1_n);

          /* End of Outputs for SubSystem: '<S610>/If Action Subsystem' */
        } else if (j_traj_real_Spd == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S610>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S619>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_Product2_hzb *
            t_Ax_Extrem2_g) + rtb_Gain9_kp / 2.0F * (t_Ax_Extrem2_g *
            t_Ax_Extrem2_g)) + rtb_KTt_af / 6.0F * (t_Ax_Extrem2_g *
            t_Ax_Extrem2_g * t_Ax_Extrem2_g), ((MultiportSwitch[2] +
            rtb_Product2_hzb * rtb_Min_p) + rtb_Gain9_kp / 2.0F * (rtb_Min_p *
            rtb_Min_p)) + rtb_KTt_af / 6.0F * (rtb_Min_p * rtb_Min_p * rtb_Min_p),
            t_Ax_Extrem2_g, &Ax_Extrem2_f, &t_Ax_Extrem1_e, &rtb_K_OsV_Os_l,
            &Ax_Extrem1_n);

          /* End of Outputs for SubSystem: '<S610>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S610>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S620>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_Product2_hzb *
            t_Ax_Extrem2_g) + rtb_Gain9_kp / 2.0F * (t_Ax_Extrem2_g *
            t_Ax_Extrem2_g)) + rtb_KTt_af / 6.0F * (t_Ax_Extrem2_g *
            t_Ax_Extrem2_g * t_Ax_Extrem2_g), ((MultiportSwitch[2] +
            rtb_Product2_hzb * rtb_Min_p) + rtb_Gain9_kp / 2.0F * (rtb_Min_p *
            rtb_Min_p)) + rtb_KTt_af / 6.0F * (rtb_Min_p * rtb_Min_p * rtb_Min_p),
            t_Ax_Extrem2_g, rtb_Min_p, &Ax_Extrem2_f, &t_Ax_Extrem1_e,
            &rtb_K_OsV_Os_l, &Ax_Extrem1_n);

          /* End of Outputs for SubSystem: '<S610>/If Action Subsystem2' */
        }

        /* End of If: '<S610>/If' */

        /* MinMax: '<S610>/Min' */
        j_traj_real_Spd = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], rtb_Product4_dp),
          Ax_Extrem2_f), t_Ax_Extrem1_e);

        /* Product: '<S615>/Product4' incorporates:
         *  Constant: '<S615>/Constant1'
         *  Constant: '<S615>/Constant2'
         *  Gain: '<S615>/Gain'
         *  Product: '<S615>/Product1'
         *  Product: '<S615>/Product2'
         *  Sum: '<S615>/Add'
         */
        t_Ax_Extrem2_g = ((0.5F * rtb_Gain9_kp * rtb_KTt_h + rtb_Product4_k0) +
                          rtb_K_OsV_Os_c * (0.166666672F * rtb_KTt_af)) * 0.0F *
          nDLookupTable1;

        /* Product: '<S615>/Product5' */
        rtb_KTt_h = rtb_Switch_ik * c3;

        /* Product: '<S617>/Divide9' incorporates:
         *  Constant: '<S617>/Constant5'
         */
        rtb_Min_p = rtb_KTt_af * 0.0416666679F;

        /* Sum: '<S617>/Add2' incorporates:
         *  Constant: '<S617>/Constant1'
         *  Constant: '<S617>/Constant2'
         *  Product: '<S617>/Divide1'
         *  Product: '<S617>/Divide3'
         */
        rtb_Product4_k0 = 2.0F * rtb_Min_p * c3 + rtb_Gain9_kp * 0.166666672F;

        /* Outputs for Atomic SubSystem: '<S617>/SfD'
         *
         * Block description for '<S617>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], c3 * c3, &rtb_K_OsV_Os_c, 0.01F);

        /* End of Outputs for SubSystem: '<S617>/SfD' */

        /* Sum: '<S617>/Add4' incorporates:
         *  Constant: '<S617>/Constant16'
         *  Product: '<S617>/Divide8'
         *  Product: '<S617>/Multiply7'
         *  Product: '<S617>/Multiply8'
         */
        rtb_Switch_ki = rtb_Product4_k0 * rtb_Product4_k0 - 4.0F * rtb_Min_p *
          rtb_K_OsV_Os_c;

        /* If: '<S617>/If' */
        if ((rtb_Min_p != 0.0F) && (rtb_Switch_ki >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem' incorporates:
           *  ActionPort: '<S627>/Action Port'
           */
          app_IfActionSubsystem_c(rtb_Min_p, rtb_Product4_k0, rtb_Switch_ki, c3,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem' */
        } else if ((rtb_Min_p == 0.0F) && (rtb_Product4_k0 != 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S628>/Action Port'
           */
          app_IfActionSubsystem1_h(rtb_Product4_k0, rtb_K_OsV_Os_c, c3,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S629>/Action Port'
           */
          /* SignalConversion: '<S629>/Signal Conversion' */
          rtb_Switch1_g[0] = c3;
          rtb_Switch1_g[1] = c3;

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem2' */
        }

        /* End of If: '<S617>/If' */

        /* Sum: '<S625>/Add' incorporates:
         *  Gain: '<S625>/Gain'
         *  Gain: '<S625>/Gain1'
         *  Gain: '<S625>/Gain2'
         *  Product: '<S625>/Multiply'
         *  Product: '<S625>/Multiply1'
         *  Product: '<S625>/Multiply2'
         *  Product: '<S625>/Multiply3'
         */
        rtb_K_OsV_Os_c = ((rtb_Product2_hzb * rtb_Switch1_g[0] * rtb_Switch1_g[0]
                           * 0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
          MultiportSwitch[1])) + rtb_Gain9_kp * rtb_Switch1_g[0] *
                          rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
          rtb_KTt_af * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
          rtb_Switch1_g[0] * 0.0416666679F;

        /* Product: '<S617>/Multiply9' */
        rtb_Min_p = MultiportSwitch[1] * rtb_K_OsV_Os_c;

        /* Sum: '<S626>/Add' incorporates:
         *  Gain: '<S626>/Gain'
         *  Gain: '<S626>/Gain1'
         *  Gain: '<S626>/Gain2'
         *  Product: '<S626>/Multiply'
         *  Product: '<S626>/Multiply1'
         *  Product: '<S626>/Multiply2'
         *  Product: '<S626>/Multiply3'
         */
        rtb_Switch_ki = ((rtb_Product2_hzb * rtb_Switch1_g[1] * rtb_Switch1_g[1]
                          * 0.5F + (MultiportSwitch[2] * rtb_Switch1_g[1] +
          MultiportSwitch[1])) + rtb_Gain9_kp * rtb_Switch1_g[1] *
                         rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.166666672F) +
          rtb_KTt_af * rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
          rtb_Switch1_g[1] * 0.0416666679F;

        /* Product: '<S617>/Multiply10' */
        rtb_Product4_k0 = MultiportSwitch[1] * rtb_Switch_ki;

        /* If: '<S617>/If1' */
        if ((rtb_Min_p < 0.0F) && (rtb_Product4_k0 >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S630>/Action Port'
           */
          app_IfActionSubsystem3(rtb_K_OsV_Os_c, &rtb_Product4_k0);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem3' */
        } else if ((rtb_Min_p >= 0.0F) && (rtb_Product4_k0 < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S631>/Action Port'
           */
          app_IfActionSubsystem4(rtb_Switch_ki, &rtb_Product4_k0);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem4' */
        } else if ((rtb_Min_p < 0.0F) && (rtb_Product4_k0 < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S632>/Action Port'
           */
          app_IfActionSubsystem5(rtb_K_OsV_Os_c, rtb_Switch_ki, &rtb_Product4_k0);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S617>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S633>/Action Port'
           */
          app_IfActionSubsystem6(&rtb_Product4_k0);

          /* End of Outputs for SubSystem: '<S617>/If Action Subsystem6' */
        }

        /* End of If: '<S617>/If1' */

        /* Product: '<S615>/Product6' */
        rtb_Min_p = rtb_ACC_t_FTCDsrdDistLv2_sg * rtb_Product4_k0;

        /* Sum: '<S615>/Add1' */
        rtb_Switch_ki = (t_Ax_Extrem2_g + rtb_KTt_h) + rtb_Min_p;

        /* Product: '<S614>/Product4' incorporates:
         *  Abs: '<S614>/Abs'
         *  MinMax: '<S610>/Min1'
         *  MinMax: '<S614>/Max5'
         */
        rtb_Gain1_jl = rtb_Product_eqe * fmaxf(j_traj_real_Spd, fabsf(fminf
          (fminf(fminf(MultiportSwitch[2], rtb_Product4_dp), Ax_Extrem2_f),
           t_Ax_Extrem1_e)));

        /* Switch: '<S613>/Switch' incorporates:
         *  Constant: '<S613>/Invalid'
         *  Constant: '<S624>/Constant'
         *  Gain: '<S613>/Gain'
         *  Product: '<S613>/Divide1'
         *  RelationalOperator: '<S624>/Compare'
         */
        if (rtb_KTt_af != 0.0F) {
          rtb_Product4_dp = -rtb_Gain9_kp / rtb_KTt_af;
        } else {
          rtb_Product4_dp = 0.0F;
        }

        /* End of Switch: '<S613>/Switch' */

        /* Product: '<S613>/Divide3' */
        rtb_Product2_jb = rtb_KTt_af * rtb_Product4_dp;

        /* Sum: '<S613>/Add2' incorporates:
         *  Math: '<S613>/Square2'
         *  Product: '<S613>/Divide2'
         */
        rtb_Product2_jb = (rtb_Gain9_kp * rtb_Product4_dp + rtb_Product2_hzb) +
          rtb_Product2_jb * rtb_Product2_jb;

        /* Product: '<S613>/Divide5' incorporates:
         *  Constant: '<S613>/t_Start'
         */
        rtb_Add2_l = rtb_KTt_af * 0.0F;

        /* Sum: '<S613>/Add1' incorporates:
         *  Constant: '<S613>/t_Start'
         *  Math: '<S613>/Square1'
         *  Product: '<S613>/Divide4'
         */
        rtb_Add2_l = (rtb_Gain9_kp * 0.0F + rtb_Product2_hzb) + rtb_Add2_l *
          rtb_Add2_l;

        /* Product: '<S613>/Divide7' */
        rtb_Product1_da = rtb_KTt_af * c3;

        /* Sum: '<S613>/Add3' incorporates:
         *  Math: '<S613>/Square3'
         *  Product: '<S613>/Divide6'
         */
        rtb_Product1_da = (rtb_Gain9_kp * c3 + rtb_Product2_hzb) +
          rtb_Product1_da * rtb_Product1_da;

        /* MinMax: '<S613>/Min' */
        rtb_K_OsV_Os_c = fmaxf(fmaxf(rtb_Product2_jb, rtb_Add2_l),
          rtb_Product1_da);

        /* MinMax: '<S613>/Min1' */
        rtb_Add2_l = fminf(fminf(rtb_Product2_jb, rtb_Add2_l), rtb_Product1_da);

        /* Abs: '<S614>/Abs2' */
        rtb_Add2_l = fabsf(rtb_Add2_l);

        /* Product: '<S614>/Product1' incorporates:
         *  MinMax: '<S614>/Max6'
         */
        rtb_K_OsV_Os_c = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_K_OsV_Os_c,
          rtb_Add2_l);

        /* Sum: '<S614>/Add5' incorporates:
         *  Constant: '<S553>/Constant'
         */
        rtb_Product4_k0 -= 0.277777791F;

        /* Product: '<S614>/Product2' incorporates:
         *  Constant: '<S614>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S614>/Max4'
         */
        rtb_Product1_da = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product4_k0,
          0.0F);

        /* Sum: '<S614>/Add8' */
        rtb_Add2_l = (rtb_Gain1_jl + rtb_K_OsV_Os_c) + rtb_Product1_da;

        /* Logic: '<S611>/Logical Operator1' incorporates:
         *  RelationalOperator: '<S611>/Relational Operator2'
         *  Sum: '<S611>/Add'
         *  Sum: '<S611>/Add1'
         */
        rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = (rtb_Switch_ki + rtb_Add2_l <
          app_B.Opt_mq + app_B.LimitationViolate_p);

        /* Switch generated from: '<S611>/Switch2' */
        app_B.Collision_p = false;

        /* Switch generated from: '<S611>/Switch2' incorporates:
         *  Switch generated from: '<S555>/Switch2'
         *  Switch generated from: '<S583>/Switch2'
         */
        if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
          /* Switch generated from: '<S611>/Switch2' */
          app_B.Ax_Extrem1_m = Ax_Extrem2_f;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.Ax_Extrem2_d = t_Ax_Extrem1_e;

          /* Sum: '<S557>/Add2' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.Jerk_Extrem_n = rtb_Product2_jb;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.t_end_l = c3;
        } else if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.Ax_Extrem1_m = Jerk_Extrem;

          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.Ax_Extrem2_d = ax_Max_Traj;

          /* Sum: '<S557>/Add2' incorporates:
           *  Switch generated from: '<S583>/Switch2'
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.Jerk_Extrem_n = rtb_Product4_p;

          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.t_end_l = Longt_Spd_C1;
        } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
          /* Switch generated from: '<S555>/Switch2' incorporates:
           *  Switch generated from: '<S583>/Switch2'
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.t_end_l = Longt_Spd_C0;
        } else {
          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S555>/Switch2'
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.Ax_Extrem1_m = app_B.Ax_Extrem1_nb;

          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S555>/Switch2'
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.Ax_Extrem2_d = app_B.Ax_Extrem2_k;

          /* Sum: '<S557>/Add2' incorporates:
           *  Switch generated from: '<S555>/Switch2'
           *  Switch generated from: '<S583>/Switch2'
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.Jerk_Extrem_n = app_B.Jerk_Extrem_h;

          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Switch generated from: '<S555>/Switch2'
           *  Switch generated from: '<S583>/Switch2'
           */
          app_B.t_end_l = s_traj_real_Spd;
        }

        /* Switch generated from: '<S611>/Switch2' */
        app_B.Traj_valid_ez = true;

        /* Switch generated from: '<S611>/Switch2' */
        if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
          /* MinMax: '<S554>/Min' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.ax_Max_Traj_mm = j_traj_real_Spd;

          /* Switch generated from: '<S611>/Switch2' incorporates:
           *  Constant: '<S553>/Constant1'
           */
          app_B.Traj_Numb_e = 23U;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.Opt_SubIterm_m[0] = t_Ax_Extrem2_g;
          app_B.Opt_SubIterm_m[1] = rtb_KTt_h;
          app_B.Opt_SubIterm_m[2] = rtb_Min_p;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.LmtViolt_SubIterm_e[0] = rtb_Gain1_jl;
          app_B.LmtViolt_SubIterm_e[1] = rtb_K_OsV_Os_c;
          app_B.LmtViolt_SubIterm_e[2] = rtb_Product1_da;

          /* Switch generated from: '<S583>/Switch2' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.LimitationViolate_p = rtb_Add2_l;

          /* Switch generated from: '<S583>/Switch2' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.Opt_mq = rtb_Switch_ki;

          /* Gain: '<S560>/Gain1' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.c3_f0 = rtb_Product2_hzb;

          /* Product: '<S560>/Divide4' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.c4_ps = rtb_Gain9_kp;

          /* Gain: '<S560>/Gain9' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.c5_i = rtb_KTt_af;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.t_Ax_Extrem1_nt = rtb_K_OsV_Os_l;

          /* Switch generated from: '<S611>/Switch2' */
          app_B.t_Ax_Extrem2_i = Ax_Extrem1_n;

          /* Switch: '<S557>/Switch' incorporates:
           *  Switch generated from: '<S611>/Switch2'
           */
          app_B.t_Jerk_Extrem_i = rtb_Product4_dp;
        } else {
          /* Switch generated from: '<S583>/Switch2' incorporates:
           *  Switch generated from: '<S555>/Switch2'
           */
          if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
            /* MinMax: '<S554>/Min' incorporates:
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.ax_Max_Traj_mm = rtb_Product1_j2z;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Constant: '<S552>/Constant1'
             */
            app_B.Traj_Numb_e = 22U;

            /* Switch generated from: '<S611>/Switch2' */
            app_B.Opt_SubIterm_m[0] = rtb_Product2_jd;
            app_B.Opt_SubIterm_m[1] = rtb_KTt_a;
            app_B.Opt_SubIterm_m[2] = rtb_Product4_aq;

            /* Switch generated from: '<S611>/Switch2' */
            app_B.LmtViolt_SubIterm_e[0] = rtb_Product4_lc;
            app_B.LmtViolt_SubIterm_e[1] = rtb_Gain1_bg;
            app_B.LmtViolt_SubIterm_e[2] = rtb_Divide4_h1;
          } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
            /* Switch generated from: '<S555>/Switch2' incorporates:
             *  Constant: '<S551>/Constant1'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.Traj_Numb_e = 21U;

            /* Switch generated from: '<S555>/Switch2' incorporates:
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.Opt_SubIterm_m[0] = v_traj_real_Spd;
            app_B.Opt_SubIterm_m[1] = a_traj_real_Spd_PrdtOneStp;
            app_B.Opt_SubIterm_m[2] = LimitationViolate;

            /* Switch generated from: '<S555>/Switch2' incorporates:
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.LmtViolt_SubIterm_e[0] = Opt;
            app_B.LmtViolt_SubIterm_e[1] = c4;
            app_B.LmtViolt_SubIterm_e[2] = c5;
          } else {
            /* MinMax: '<S554>/Min' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.ax_Max_Traj_mm = app_B.ax_Max_Traj_m;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             */
            app_B.Traj_Numb_e = app_B.Traj_Numb_d;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             */
            app_B.Opt_SubIterm_m[0] = app_B.Opt_SubIterm_e[0];
            app_B.Opt_SubIterm_m[1] = app_B.Opt_SubIterm_e[1];
            app_B.Opt_SubIterm_m[2] = app_B.Opt_SubIterm_e[2];

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             */
            app_B.LmtViolt_SubIterm_e[0] = app_B.LmtViolt_SubIterm_a[0];
            app_B.LmtViolt_SubIterm_e[1] = app_B.LmtViolt_SubIterm_a[1];
            app_B.LmtViolt_SubIterm_e[2] = app_B.LmtViolt_SubIterm_a[2];
          }

          if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
            /* Gain: '<S560>/Gain1' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c3_f0 = t_Ax_Extrem2;

            /* Product: '<S560>/Divide4' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c4_ps = t_Ax_Extrem1;

            /* Gain: '<S560>/Gain9' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c5_i = t_Jerk_Extrem;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             */
            app_B.t_Ax_Extrem1_nt = Ax_Extrem1;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             */
            app_B.t_Ax_Extrem2_i = Ax_Extrem2;

            /* Switch: '<S557>/Switch' incorporates:
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.t_Jerk_Extrem_i = rtb_Product1_ei;
          } else if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
          } else {
            /* Gain: '<S560>/Gain1' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c3_f0 = app_B.c3_f;

            /* Product: '<S560>/Divide4' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c4_ps = app_B.c4_p;

            /* Gain: '<S560>/Gain9' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.c5_i = app_B.c5_f;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             */
            app_B.t_Ax_Extrem1_nt = app_B.t_Ax_Extrem1_nf;

            /* Switch generated from: '<S611>/Switch2' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             */
            app_B.t_Ax_Extrem2_i = app_B.t_Ax_Extrem2_c;

            /* Switch: '<S557>/Switch' incorporates:
             *  Switch generated from: '<S555>/Switch2'
             *  Switch generated from: '<S583>/Switch2'
             *  Switch generated from: '<S611>/Switch2'
             */
            app_B.t_Jerk_Extrem_i = app_B.t_Jerk_Extrem_b;
          }
        }

        /* End of Outputs for SubSystem: '<S535>/Enabled Subsystem' */

        /* Switch generated from: '<S542>/Switch' */
        app_B.Collision_o = app_B.Collision_p;

        /* Switch generated from: '<S841>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.LimitationViolate_k = app_B.LimitationViolate_p;

        /* Switch generated from: '<S841>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.Opt_m = app_B.Opt_mq;

        /* Gain: '<S762>/Gain1' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.c3_f = app_B.c3_f0;

        /* Product: '<S762>/Divide4' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.c4_p = app_B.c4_ps;

        /* Gain: '<S762>/Gain9' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.c5_f = app_B.c5_i;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.t_Ax_Extrem1_nf = app_B.t_Ax_Extrem1_nt;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.t_Ax_Extrem2_c = app_B.t_Ax_Extrem2_i;

        /* Switch: '<S759>/Switch' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.t_Jerk_Extrem_b = app_B.t_Jerk_Extrem_i;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.Ax_Extrem1_nb = app_B.Ax_Extrem1_m;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.Ax_Extrem2_k = app_B.Ax_Extrem2_d;

        /* Sum: '<S759>/Add2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.Jerk_Extrem_h = app_B.Jerk_Extrem_n;

        /* Switch generated from: '<S542>/Switch' */
        app_B.t_end_m = app_B.t_end_l;

        /* Switch generated from: '<S542>/Switch' */
        app_B.Traj_valid_e = app_B.Traj_valid_ez;

        /* MinMax: '<S757>/Min' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.ax_Max_Traj_m = app_B.ax_Max_Traj_mm;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S542>/Switch'
         */
        app_B.Traj_Numb_d = app_B.Traj_Numb_e;

        /* Switch generated from: '<S542>/Switch' */
        app_B.Opt_SubIterm_e[0] = app_B.Opt_SubIterm_m[0];

        /* Switch generated from: '<S542>/Switch' */
        app_B.LmtViolt_SubIterm_a[0] = app_B.LmtViolt_SubIterm_e[0];

        /* Switch generated from: '<S542>/Switch' */
        app_B.Opt_SubIterm_e[1] = app_B.Opt_SubIterm_m[1];

        /* Switch generated from: '<S542>/Switch' */
        app_B.LmtViolt_SubIterm_a[1] = app_B.LmtViolt_SubIterm_e[1];

        /* Switch generated from: '<S542>/Switch' */
        app_B.Opt_SubIterm_e[2] = app_B.Opt_SubIterm_m[2];

        /* Switch generated from: '<S542>/Switch' */
        app_B.LmtViolt_SubIterm_a[2] = app_B.LmtViolt_SubIterm_e[2];
      }

      /* End of Switch: '<S544>/Switch1' */

      /* Switch: '<S544>/Switch2' incorporates:
       *  Constant: '<S544>/Constant3'
       *  Constant: '<S544>/Constant4'
       *  Product: '<S648>/Divide8'
       *  Product: '<S676>/Divide8'
       *  Product: '<S704>/Divide8'
       *  RelationalOperator: '<S544>/Equal1'
       *  Switch: '<S544>/Switch4'
       */
      if (rtb_Reshape[5] == s_traj_real_Spd) {
        rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = false;
      } else {
        rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = true;

        /* Outputs for Enabled SubSystem: '<S535>/Enabled Subsystem1' incorporates:
         *  EnablePort: '<S540>/Enable'
         */
        /* Product: '<S647>/Product5' incorporates:
         *  Constant: '<S544>/Constant4'
         *  Product: '<S647>/Product1'
         *  Product: '<S647>/Product6'
         *  Switch: '<S544>/Switch4'
         */
        a_traj_real_Spd_PrdtOneStp = MultiportSwitch[2] * rtb_Switch_ai;

        /* Product: '<S647>/Product3' incorporates:
         *  Math: '<S641>/Square7'
         *  Math: '<S646>/Square1'
         *  Product: '<S641>/Product7'
         *  Product: '<S646>/Product3'
         *  Product: '<S647>/Product2'
         *  Product: '<S647>/Product4'
         */
        s_traj_real_Spd = rtb_Switch_ai * rtb_Switch_ai;
        v_traj_real_Spd = s_traj_real_Spd * rtb_Switch_ai;

        /* Product: '<S647>/Divide4' incorporates:
         *  Gain: '<S647>/Gain4'
         *  Gain: '<S647>/Gain5'
         *  Gain: '<S647>/Gain6'
         *  Product: '<S647>/Product3'
         *  Product: '<S647>/Product5'
         *  Sum: '<S647>/Add3'
         */
        app_B.c4_po = (a_traj_real_Spd_PrdtOneStp * 3.0F + 8.0F *
                       MultiportSwitch[1]) * 6.0F / v_traj_real_Spd;

        /* Gain: '<S647>/Gain1' incorporates:
         *  Gain: '<S647>/Gain2'
         *  Gain: '<S647>/Gain3'
         *  Product: '<S647>/Divide3'
         *  Sum: '<S647>/Add1'
         */
        app_B.c3_k = -((2.0F * MultiportSwitch[1] + a_traj_real_Spd_PrdtOneStp) *
                       6.0F / s_traj_real_Spd);

        /* Gain: '<S647>/Gain9' incorporates:
         *  Gain: '<S647>/Gain7'
         *  Gain: '<S647>/Gain8'
         *  Product: '<S647>/Divide1'
         *  Product: '<S647>/Product2'
         *  Sum: '<S647>/Add2'
         */
        app_B.c5_p = -((3.0F * MultiportSwitch[1] + a_traj_real_Spd_PrdtOneStp) *
                       24.0F / (v_traj_real_Spd * rtb_Switch_ai));

        /* Sum: '<S641>/Add1' incorporates:
         *  Constant: '<S641>/Constant3'
         *  Math: '<S641>/Square3'
         *  Product: '<S641>/Product3'
         */
        rtb_Product2_jd = app_B.c4_po * app_B.c4_po - app_B.c3_k * app_B.c5_p *
          2.0F;

        /* Sqrt: '<S641>/Sqrt' incorporates:
         *  Abs: '<S641>/Abs'
         *  Sqrt: '<S641>/Sqrt1'
         */
        Longt_Spd_C0 = sqrtf(fabsf(rtb_Product2_jd));

        /* Product: '<S641>/Divide2' incorporates:
         *  Gain: '<S641>/Gain'
         *  Sqrt: '<S641>/Sqrt'
         *  Sum: '<S641>/Add3'
         */
        a_traj_real_Spd_PrdtOneStp = (-app_B.c4_po + Longt_Spd_C0) / app_B.c5_p;

        /* Product: '<S641>/Divide3' incorporates:
         *  Gain: '<S641>/Gain1'
         *  Sum: '<S641>/Add4'
         */
        j_traj_real_Spd = (-app_B.c4_po - Longt_Spd_C0) / app_B.c5_p;

        /* Product: '<S641>/Product6' incorporates:
         *  Product: '<S646>/Product'
         */
        Longt_Spd_C0 = app_B.c3_k * rtb_Switch_ai;

        /* Sum: '<S641>/Add6' incorporates:
         *  Constant: '<S641>/Constant10'
         *  Constant: '<S641>/Constant9'
         *  Product: '<S641>/Divide6'
         *  Product: '<S641>/Divide7'
         *  Product: '<S641>/Product6'
         */
        Longt_Spd_C1 = ((Longt_Spd_C0 + MultiportSwitch[2]) + app_B.c4_po / 2.0F
                        * s_traj_real_Spd) + v_traj_real_Spd * (app_B.c5_p /
          6.0F);

        /* If: '<S641>/If' incorporates:
         *  Constant: '<S641>/Constant1'
         *  Constant: '<S641>/Constant2'
         *  Constant: '<S641>/Constant5'
         *  Constant: '<S641>/Constant7'
         *  Constant: '<S641>/Constant8'
         *  Math: '<S641>/Square1'
         *  Math: '<S641>/Square2'
         *  Math: '<S641>/Square4'
         *  Math: '<S641>/Square5'
         *  Product: '<S641>/Divide'
         *  Product: '<S641>/Divide1'
         *  Product: '<S641>/Divide4'
         *  Product: '<S641>/Divide5'
         *  Product: '<S641>/Product1'
         *  Product: '<S641>/Product2'
         *  Product: '<S641>/Product4'
         *  Product: '<S641>/Product5'
         *  Sum: '<S641>/Add2'
         *  Sum: '<S641>/Add5'
         */
        if (rtb_Product2_jd < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S641>/If Action Subsystem' incorporates:
           *  ActionPort: '<S649>/Action Port'
           */
          app_IfActionSubsystem(Longt_Spd_C1, 0.0F, rtb_Switch_ai,
                                &app_B.Ax_Extrem1_c, &app_B.Ax_Extrem2_m2,
                                &app_B.t_Ax_Extrem1_a, &app_B.t_Ax_Extrem2_ci);

          /* End of Outputs for SubSystem: '<S641>/If Action Subsystem' */
        } else if (rtb_Product2_jd == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S641>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S650>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + app_B.c3_k *
            a_traj_real_Spd_PrdtOneStp) + app_B.c4_po / 2.0F *
            (a_traj_real_Spd_PrdtOneStp * a_traj_real_Spd_PrdtOneStp)) +
            app_B.c5_p / 6.0F * (a_traj_real_Spd_PrdtOneStp *
            a_traj_real_Spd_PrdtOneStp * a_traj_real_Spd_PrdtOneStp),
            ((MultiportSwitch[2] + app_B.c3_k * j_traj_real_Spd) + app_B.c4_po /
             2.0F * (j_traj_real_Spd * j_traj_real_Spd)) + app_B.c5_p / 6.0F *
            (j_traj_real_Spd * j_traj_real_Spd * j_traj_real_Spd),
            a_traj_real_Spd_PrdtOneStp, &app_B.Ax_Extrem1_c,
            &app_B.Ax_Extrem2_m2, &app_B.t_Ax_Extrem1_a, &app_B.t_Ax_Extrem2_ci);

          /* End of Outputs for SubSystem: '<S641>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S641>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S651>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + app_B.c3_k *
            a_traj_real_Spd_PrdtOneStp) + app_B.c4_po / 2.0F *
            (a_traj_real_Spd_PrdtOneStp * a_traj_real_Spd_PrdtOneStp)) +
            app_B.c5_p / 6.0F * (a_traj_real_Spd_PrdtOneStp *
            a_traj_real_Spd_PrdtOneStp * a_traj_real_Spd_PrdtOneStp),
            ((MultiportSwitch[2] + app_B.c3_k * j_traj_real_Spd) + app_B.c4_po /
             2.0F * (j_traj_real_Spd * j_traj_real_Spd)) + app_B.c5_p / 6.0F *
            (j_traj_real_Spd * j_traj_real_Spd * j_traj_real_Spd),
            a_traj_real_Spd_PrdtOneStp, j_traj_real_Spd, &app_B.Ax_Extrem1_c,
            &app_B.Ax_Extrem2_m2, &app_B.t_Ax_Extrem1_a, &app_B.t_Ax_Extrem2_ci);

          /* End of Outputs for SubSystem: '<S641>/If Action Subsystem2' */
        }

        /* End of If: '<S641>/If' */

        /* MinMax: '<S641>/Min' */
        app_B.ax_Max_Traj_o = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], Longt_Spd_C1),
          app_B.Ax_Extrem1_c), app_B.Ax_Extrem2_m2);

        /* Product: '<S646>/Product4' incorporates:
         *  Constant: '<S646>/Constant1'
         *  Constant: '<S646>/Constant2'
         *  Gain: '<S646>/Gain'
         *  Product: '<S646>/Product1'
         *  Product: '<S646>/Product2'
         *  Sum: '<S646>/Add'
         */
        s_traj_real_Spd = ((0.5F * app_B.c4_po * s_traj_real_Spd + Longt_Spd_C0)
                           + v_traj_real_Spd * (0.166666672F * app_B.c5_p)) *
          0.0F * nDLookupTable1;

        /* Product: '<S646>/Product5' */
        v_traj_real_Spd = rtb_Switch_ik * rtb_Switch_ai;

        /* Product: '<S648>/Divide9' incorporates:
         *  Constant: '<S648>/Constant5'
         */
        a_traj_real_Spd_PrdtOneStp = app_B.c5_p * 0.0416666679F;

        /* Sum: '<S648>/Add2' incorporates:
         *  Constant: '<S648>/Constant1'
         *  Constant: '<S648>/Constant2'
         *  Product: '<S648>/Divide1'
         *  Product: '<S648>/Divide3'
         */
        Longt_Spd_C0 = 2.0F * a_traj_real_Spd_PrdtOneStp * rtb_Switch_ai +
          app_B.c4_po * 0.166666672F;

        /* Outputs for Atomic SubSystem: '<S648>/SfD'
         *
         * Block description for '<S648>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], rtb_Switch_ai * rtb_Switch_ai,
                  &rtb_Product1_ei, 0.01F);

        /* End of Outputs for SubSystem: '<S648>/SfD' */

        /* Sum: '<S648>/Add4' incorporates:
         *  Constant: '<S648>/Constant16'
         *  Product: '<S648>/Divide8'
         *  Product: '<S648>/Multiply7'
         *  Product: '<S648>/Multiply8'
         */
        j_traj_real_Spd = Longt_Spd_C0 * Longt_Spd_C0 - 4.0F *
          a_traj_real_Spd_PrdtOneStp * rtb_Product1_ei;

        /* If: '<S648>/If' */
        if ((a_traj_real_Spd_PrdtOneStp != 0.0F) && (j_traj_real_Spd >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem' incorporates:
           *  ActionPort: '<S658>/Action Port'
           */
          app_IfActionSubsystem_c(a_traj_real_Spd_PrdtOneStp, Longt_Spd_C0,
            j_traj_real_Spd, rtb_Switch_ai, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem' */
        } else if ((a_traj_real_Spd_PrdtOneStp == 0.0F) && (Longt_Spd_C0 != 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S659>/Action Port'
           */
          app_IfActionSubsystem1_h(Longt_Spd_C0, rtb_Product1_ei, rtb_Switch_ai,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S660>/Action Port'
           */
          /* SignalConversion: '<S660>/Signal Conversion' */
          rtb_Switch1_g[0] = rtb_Switch_ai;
          rtb_Switch1_g[1] = rtb_Switch_ai;

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem2' */
        }

        /* End of If: '<S648>/If' */

        /* Sum: '<S656>/Add' incorporates:
         *  Gain: '<S656>/Gain'
         *  Gain: '<S656>/Gain1'
         *  Gain: '<S656>/Gain2'
         *  Product: '<S656>/Multiply'
         *  Product: '<S656>/Multiply1'
         *  Product: '<S656>/Multiply2'
         *  Product: '<S656>/Multiply3'
         */
        Longt_Spd_C0 = ((app_B.c3_k * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F
                         + (MultiportSwitch[2] * rtb_Switch1_g[0] +
                            MultiportSwitch[1])) + app_B.c4_po * rtb_Switch1_g[0]
                        * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
          app_B.c5_p * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
          rtb_Switch1_g[0] * 0.0416666679F;

        /* Product: '<S648>/Multiply9' */
        ax_Max_Traj = MultiportSwitch[1] * Longt_Spd_C0;

        /* Sum: '<S657>/Add' incorporates:
         *  Gain: '<S657>/Gain'
         *  Gain: '<S657>/Gain1'
         *  Gain: '<S657>/Gain2'
         *  Product: '<S657>/Multiply'
         *  Product: '<S657>/Multiply1'
         *  Product: '<S657>/Multiply2'
         *  Product: '<S657>/Multiply3'
         */
        j_traj_real_Spd = ((app_B.c3_k * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                            0.5F + (MultiportSwitch[2] * rtb_Switch1_g[1] +
          MultiportSwitch[1])) + app_B.c4_po * rtb_Switch1_g[1] * rtb_Switch1_g
                           [1] * rtb_Switch1_g[1] * 0.166666672F) + app_B.c5_p *
          rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
          rtb_Switch1_g[1] * 0.0416666679F;

        /* Product: '<S648>/Multiply10' */
        a_traj_real_Spd_PrdtOneStp = MultiportSwitch[1] * j_traj_real_Spd;

        /* If: '<S648>/If1' */
        if ((ax_Max_Traj < 0.0F) && (a_traj_real_Spd_PrdtOneStp >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S661>/Action Port'
           */
          app_IfActionSubsystem3(Longt_Spd_C0, &a_traj_real_Spd_PrdtOneStp);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem3' */
        } else if ((ax_Max_Traj >= 0.0F) && (a_traj_real_Spd_PrdtOneStp < 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S662>/Action Port'
           */
          app_IfActionSubsystem4(j_traj_real_Spd, &a_traj_real_Spd_PrdtOneStp);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem4' */
        } else if ((ax_Max_Traj < 0.0F) && (a_traj_real_Spd_PrdtOneStp < 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S663>/Action Port'
           */
          app_IfActionSubsystem5(Longt_Spd_C0, j_traj_real_Spd,
            &a_traj_real_Spd_PrdtOneStp);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S648>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S664>/Action Port'
           */
          app_IfActionSubsystem6(&a_traj_real_Spd_PrdtOneStp);

          /* End of Outputs for SubSystem: '<S648>/If Action Subsystem6' */
        }

        /* End of If: '<S648>/If1' */

        /* Product: '<S646>/Product6' */
        Longt_Spd_C0 = rtb_ACC_t_FTCDsrdDistLv2_sg * a_traj_real_Spd_PrdtOneStp;

        /* Sum: '<S646>/Add1' */
        ax_Max_Traj = (s_traj_real_Spd + v_traj_real_Spd) + Longt_Spd_C0;

        /* Product: '<S645>/Product4' incorporates:
         *  Abs: '<S645>/Abs'
         *  MinMax: '<S641>/Min1'
         *  MinMax: '<S645>/Max5'
         */
        Longt_Spd_C1 = rtb_Product_eqe * fmaxf(app_B.ax_Max_Traj_o, fabsf(fminf
          (fminf(fminf(MultiportSwitch[2], Longt_Spd_C1), app_B.Ax_Extrem1_c),
           app_B.Ax_Extrem2_m2)));

        /* Switch: '<S644>/Switch' incorporates:
         *  Constant: '<S655>/Constant'
         *  RelationalOperator: '<S655>/Compare'
         */
        if (app_B.c5_p != 0.0F) {
          /* Switch: '<S644>/Switch' incorporates:
           *  Gain: '<S644>/Gain'
           *  Product: '<S644>/Divide1'
           */
          app_B.t_Jerk_Extrem_o = -app_B.c4_po / app_B.c5_p;
        } else {
          /* Switch: '<S644>/Switch' incorporates:
           *  Constant: '<S644>/Invalid'
           */
          app_B.t_Jerk_Extrem_o = 0.0F;
        }

        /* End of Switch: '<S644>/Switch' */

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Product: '<S644>/Divide3'
         */
        app_B.Opt_h = app_B.c5_p * app_B.t_Jerk_Extrem_o;

        /* Sum: '<S644>/Add2' incorporates:
         *  Math: '<S644>/Square2'
         *  Product: '<S644>/Divide2'
         */
        app_B.Jerk_Extrem_m = (app_B.c4_po * app_B.t_Jerk_Extrem_o + app_B.c3_k)
          + app_B.Opt_h * app_B.Opt_h;

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Constant: '<S644>/t_Start'
         *  Math: '<S644>/Square1'
         *  Product: '<S644>/Divide4'
         *  Product: '<S644>/Divide5'
         *  Sum: '<S644>/Add1'
         */
        app_B.Opt_h = app_B.c5_p * 0.0F;
        app_B.Opt_h = (app_B.c4_po * 0.0F + app_B.c3_k) + app_B.Opt_h *
          app_B.Opt_h;

        /* Product: '<S644>/Divide7' */
        rtb_K_OsV_Os_l = app_B.c5_p * rtb_Switch_ai;

        /* Sum: '<S644>/Add3' incorporates:
         *  Math: '<S644>/Square3'
         *  Product: '<S644>/Divide6'
         */
        rtb_K_OsV_Os_l = (app_B.c4_po * rtb_Switch_ai + app_B.c3_k) +
          rtb_K_OsV_Os_l * rtb_K_OsV_Os_l;

        /* MinMax: '<S644>/Min' */
        rtb_Product2_jd = fmaxf(fmaxf(app_B.Jerk_Extrem_m, app_B.Opt_h),
          rtb_K_OsV_Os_l);

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Abs: '<S645>/Abs2'
         *  MinMax: '<S644>/Min1'
         */
        app_B.Opt_h = fminf(fminf(app_B.Jerk_Extrem_m, app_B.Opt_h),
                            rtb_K_OsV_Os_l);
        app_B.Opt_h = fabsf(app_B.Opt_h);

        /* Product: '<S645>/Product1' incorporates:
         *  MinMax: '<S645>/Max6'
         */
        j_traj_real_Spd = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product2_jd,
          app_B.Opt_h);

        /* Sum: '<S645>/Add5' incorporates:
         *  Constant: '<S638>/Constant'
         */
        a_traj_real_Spd_PrdtOneStp -= 0.277777791F;

        /* Product: '<S645>/Product2' incorporates:
         *  Constant: '<S645>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S645>/Max4'
         */
        LimitationViolate = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf
          (a_traj_real_Spd_PrdtOneStp, 0.0F);

        /* Sum: '<S645>/Add8' */
        a_traj_real_Spd_PrdtOneStp = (Longt_Spd_C1 + j_traj_real_Spd) +
          LimitationViolate;

        /* Logic: '<S642>/Logical Operator1' incorporates:
         *  Logic: '<S642>/Logical Operator2'
         *  Logic: '<S642>/Logical Operator3'
         *  RelationalOperator: '<S642>/Relational Operator2'
         *  RelationalOperator: '<S654>/Compare'
         *  Sum: '<S642>/Add'
         *  Sum: '<S642>/Add1'
         */
        rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = ((!app_B.Traj_valid_e) ||
          app_B.Collision_o || (ax_Max_Traj + a_traj_real_Spd_PrdtOneStp <
          app_B.Opt_m + app_B.LimitationViolate_k));

        /* Switch generated from: '<S642>/Switch2' */
        rtb_LogicalOperator1_pr = ((!rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) &&
          app_B.Collision_o);

        /* Switch generated from: '<S642>/Switch2' */
        rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d ||
          app_B.Traj_valid_e);

        /* Switch generated from: '<S642>/Switch2' */
        if (!rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          a_traj_real_Spd_PrdtOneStp = app_B.LimitationViolate_k;
          ax_Max_Traj = app_B.Opt_m;
        }

        /* Product: '<S675>/Product5' incorporates:
         *  Product: '<S675>/Product1'
         *  Product: '<S675>/Product6'
         */
        c4 = MultiportSwitch[2] * t_end;

        /* Product: '<S675>/Product3' incorporates:
         *  Math: '<S669>/Square7'
         *  Math: '<S674>/Square1'
         *  Product: '<S669>/Product7'
         *  Product: '<S674>/Product3'
         *  Product: '<S675>/Product2'
         *  Product: '<S675>/Product4'
         */
        Ax_Extrem2 = t_end * t_end;
        Jerk_Extrem = Ax_Extrem2 * t_end;

        /* Product: '<S675>/Divide4' incorporates:
         *  Gain: '<S675>/Gain4'
         *  Gain: '<S675>/Gain5'
         *  Gain: '<S675>/Gain6'
         *  Product: '<S675>/Product3'
         *  Product: '<S675>/Product5'
         *  Sum: '<S675>/Add3'
         */
        Opt = (c4 * 3.0F + 8.0F * MultiportSwitch[1]) * 6.0F / Jerk_Extrem;

        /* Gain: '<S675>/Gain1' incorporates:
         *  Gain: '<S675>/Gain2'
         *  Gain: '<S675>/Gain3'
         *  Product: '<S675>/Divide3'
         *  Sum: '<S675>/Add1'
         */
        c3 = -((2.0F * MultiportSwitch[1] + c4) * 6.0F / Ax_Extrem2);

        /* Gain: '<S675>/Gain9' incorporates:
         *  Gain: '<S675>/Gain7'
         *  Gain: '<S675>/Gain8'
         *  Product: '<S675>/Divide1'
         *  Product: '<S675>/Product2'
         *  Sum: '<S675>/Add2'
         */
        c4 = -((3.0F * MultiportSwitch[1] + c4) * 24.0F / (Jerk_Extrem * t_end));

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Constant: '<S669>/Constant3'
         *  Math: '<S669>/Square3'
         *  Product: '<S669>/Product3'
         *  Sum: '<S669>/Add1'
         */
        app_B.Opt_h = Opt * Opt - c3 * c4 * 2.0F;

        /* Sqrt: '<S669>/Sqrt' incorporates:
         *  Abs: '<S669>/Abs'
         *  Sqrt: '<S669>/Sqrt1'
         */
        c5 = sqrtf(fabsf(app_B.Opt_h));

        /* Product: '<S669>/Divide2' incorporates:
         *  Gain: '<S669>/Gain'
         *  Sqrt: '<S669>/Sqrt'
         *  Sum: '<S669>/Add3'
         */
        Ax_Extrem1 = (-Opt + c5) / c4;

        /* Product: '<S669>/Divide3' incorporates:
         *  Gain: '<S669>/Gain1'
         *  Sum: '<S669>/Add4'
         */
        rtb_KTt_a = (-Opt - c5) / c4;

        /* Product: '<S669>/Product6' incorporates:
         *  Product: '<S674>/Product'
         */
        rtb_Product1_j2z = c3 * t_end;

        /* Sum: '<S669>/Add6' incorporates:
         *  Constant: '<S669>/Constant10'
         *  Constant: '<S669>/Constant9'
         *  Product: '<S669>/Divide6'
         *  Product: '<S669>/Divide7'
         *  Product: '<S669>/Product6'
         */
        rtb_Product2_jd = ((rtb_Product1_j2z + MultiportSwitch[2]) + Opt / 2.0F *
                           Ax_Extrem2) + Jerk_Extrem * (c4 / 6.0F);

        /* If: '<S669>/If' incorporates:
         *  Constant: '<S669>/Constant1'
         *  Constant: '<S669>/Constant2'
         *  Constant: '<S669>/Constant5'
         *  Constant: '<S669>/Constant7'
         *  Constant: '<S669>/Constant8'
         *  Math: '<S669>/Square1'
         *  Math: '<S669>/Square2'
         *  Math: '<S669>/Square4'
         *  Math: '<S669>/Square5'
         *  Product: '<S669>/Divide'
         *  Product: '<S669>/Divide1'
         *  Product: '<S669>/Divide4'
         *  Product: '<S669>/Divide5'
         *  Product: '<S669>/Product1'
         *  Product: '<S669>/Product2'
         *  Product: '<S669>/Product4'
         *  Product: '<S669>/Product5'
         *  Sum: '<S669>/Add2'
         *  Sum: '<S669>/Add5'
         */
        if (app_B.Opt_h < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S669>/If Action Subsystem' incorporates:
           *  ActionPort: '<S677>/Action Port'
           */
          app_IfActionSubsystem(rtb_Product2_jd, 0.0F, t_end, &t_Ax_Extrem2,
                                &t_Jerk_Extrem, &c5, &t_Ax_Extrem1);

          /* End of Outputs for SubSystem: '<S669>/If Action Subsystem' */
        } else if (app_B.Opt_h == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S669>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S678>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + c3 * Ax_Extrem1) + Opt /
            2.0F * (Ax_Extrem1 * Ax_Extrem1)) + c4 / 6.0F * (Ax_Extrem1 *
            Ax_Extrem1 * Ax_Extrem1), ((MultiportSwitch[2] + c3 * rtb_KTt_a) +
            Opt / 2.0F * (rtb_KTt_a * rtb_KTt_a)) + c4 / 6.0F * (rtb_KTt_a *
            rtb_KTt_a * rtb_KTt_a), Ax_Extrem1, &t_Ax_Extrem2, &t_Jerk_Extrem,
            &c5, &t_Ax_Extrem1);

          /* End of Outputs for SubSystem: '<S669>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S669>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S679>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + c3 * Ax_Extrem1) + Opt /
            2.0F * (Ax_Extrem1 * Ax_Extrem1)) + c4 / 6.0F * (Ax_Extrem1 *
            Ax_Extrem1 * Ax_Extrem1), ((MultiportSwitch[2] + c3 * rtb_KTt_a) +
            Opt / 2.0F * (rtb_KTt_a * rtb_KTt_a)) + c4 / 6.0F * (rtb_KTt_a *
            rtb_KTt_a * rtb_KTt_a), Ax_Extrem1, rtb_KTt_a, &t_Ax_Extrem2,
            &t_Jerk_Extrem, &c5, &t_Ax_Extrem1);

          /* End of Outputs for SubSystem: '<S669>/If Action Subsystem2' */
        }

        /* End of If: '<S669>/If' */

        /* MinMax: '<S669>/Min' */
        Ax_Extrem1 = fmaxf(fmaxf(fmaxf(MultiportSwitch[2], rtb_Product2_jd),
          t_Ax_Extrem2), t_Jerk_Extrem);

        /* Product: '<S674>/Product4' incorporates:
         *  Constant: '<S674>/Constant1'
         *  Constant: '<S674>/Constant2'
         *  Gain: '<S674>/Gain'
         *  Product: '<S674>/Product1'
         *  Product: '<S674>/Product2'
         *  Sum: '<S674>/Add'
         */
        Ax_Extrem2 = ((0.5F * Opt * Ax_Extrem2 + rtb_Product1_j2z) + Jerk_Extrem
                      * (0.166666672F * c4)) * 0.0F * nDLookupTable1;

        /* Product: '<S674>/Product5' */
        Jerk_Extrem = rtb_Switch_ik * t_end;

        /* Product: '<S676>/Divide9' incorporates:
         *  Constant: '<S676>/Constant5'
         */
        rtb_Product1_j2z = c4 * 0.0416666679F;

        /* Sum: '<S676>/Add2' incorporates:
         *  Constant: '<S676>/Constant1'
         *  Constant: '<S676>/Constant2'
         *  Product: '<S676>/Divide1'
         *  Product: '<S676>/Divide3'
         */
        rtb_KTt_a = 2.0F * rtb_Product1_j2z * t_end + Opt * 0.166666672F;

        /* Outputs for Atomic SubSystem: '<S676>/SfD'
         *
         * Block description for '<S676>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], t_end * t_end, &rtb_Product1_ei, 0.01F);

        /* End of Outputs for SubSystem: '<S676>/SfD' */

        /* Sum: '<S676>/Add4' incorporates:
         *  Constant: '<S676>/Constant16'
         *  Product: '<S676>/Divide8'
         *  Product: '<S676>/Multiply7'
         *  Product: '<S676>/Multiply8'
         */
        rtb_Product4_dp = rtb_KTt_a * rtb_KTt_a - 4.0F * rtb_Product1_j2z *
          rtb_Product1_ei;

        /* If: '<S676>/If' */
        if ((rtb_Product1_j2z != 0.0F) && (rtb_Product4_dp >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem' incorporates:
           *  ActionPort: '<S686>/Action Port'
           */
          app_IfActionSubsystem_c(rtb_Product1_j2z, rtb_KTt_a, rtb_Product4_dp,
            t_end, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem' */
        } else if ((rtb_Product1_j2z == 0.0F) && (rtb_KTt_a != 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S687>/Action Port'
           */
          app_IfActionSubsystem1_h(rtb_KTt_a, rtb_Product1_ei, t_end,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S688>/Action Port'
           */
          /* SignalConversion: '<S688>/Signal Conversion' */
          rtb_Switch1_g[0] = t_end;
          rtb_Switch1_g[1] = t_end;

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem2' */
        }

        /* End of If: '<S676>/If' */

        /* Sum: '<S684>/Add' incorporates:
         *  Gain: '<S684>/Gain'
         *  Gain: '<S684>/Gain1'
         *  Gain: '<S684>/Gain2'
         *  Product: '<S684>/Multiply'
         *  Product: '<S684>/Multiply1'
         *  Product: '<S684>/Multiply2'
         *  Product: '<S684>/Multiply3'
         */
        rtb_Product1_j2z = ((c3 * rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.5F +
                             (MultiportSwitch[2] * rtb_Switch1_g[0] +
                              MultiportSwitch[1])) + Opt * rtb_Switch1_g[0] *
                            rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F)
          + c4 * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
          rtb_Switch1_g[0] * 0.0416666679F;

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Product: '<S676>/Multiply9'
         */
        app_B.Opt_h = MultiportSwitch[1] * rtb_Product1_j2z;

        /* Sum: '<S685>/Add' incorporates:
         *  Gain: '<S685>/Gain'
         *  Gain: '<S685>/Gain1'
         *  Gain: '<S685>/Gain2'
         *  Product: '<S685>/Multiply'
         *  Product: '<S685>/Multiply1'
         *  Product: '<S685>/Multiply2'
         *  Product: '<S685>/Multiply3'
         */
        rtb_KTt_a = ((c3 * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F +
                      (MultiportSwitch[2] * rtb_Switch1_g[1] + MultiportSwitch[1]))
                     + Opt * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                     rtb_Switch1_g[1] * 0.166666672F) + c4 * rtb_Switch1_g[1] *
          rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Product: '<S676>/Multiply10'
         */
        app_B.LimitationViolate_l = MultiportSwitch[1] * rtb_KTt_a;

        /* If: '<S676>/If1' */
        if ((app_B.Opt_h < 0.0F) && (app_B.LimitationViolate_l >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S689>/Action Port'
           */
          app_IfActionSubsystem3(rtb_Product1_j2z, &app_B.LimitationViolate_l);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem3' */
        } else if ((app_B.Opt_h >= 0.0F) && (app_B.LimitationViolate_l < 0.0F))
        {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S690>/Action Port'
           */
          app_IfActionSubsystem4(rtb_KTt_a, &app_B.LimitationViolate_l);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem4' */
        } else if ((app_B.Opt_h < 0.0F) && (app_B.LimitationViolate_l < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S691>/Action Port'
           */
          app_IfActionSubsystem5(rtb_Product1_j2z, rtb_KTt_a,
            &app_B.LimitationViolate_l);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S676>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S692>/Action Port'
           */
          app_IfActionSubsystem6(&app_B.LimitationViolate_l);

          /* End of Outputs for SubSystem: '<S676>/If Action Subsystem6' */
        }

        /* End of If: '<S676>/If1' */

        /* Product: '<S674>/Product6' */
        rtb_Product1_j2z = rtb_ACC_t_FTCDsrdDistLv2_sg *
          app_B.LimitationViolate_l;

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Sum: '<S674>/Add1'
         */
        app_B.Opt_h = (Ax_Extrem2 + Jerk_Extrem) + rtb_Product1_j2z;

        /* Product: '<S673>/Product4' incorporates:
         *  Abs: '<S673>/Abs'
         *  MinMax: '<S669>/Min1'
         *  MinMax: '<S673>/Max5'
         */
        rtb_KTt_a = rtb_Product_eqe * fmaxf(Ax_Extrem1, fabsf(fminf(fminf(fminf
          (MultiportSwitch[2], rtb_Product2_jd), t_Ax_Extrem2), t_Jerk_Extrem)));

        /* Switch: '<S672>/Switch' incorporates:
         *  Constant: '<S672>/Invalid'
         *  Constant: '<S683>/Constant'
         *  Gain: '<S672>/Gain'
         *  Product: '<S672>/Divide1'
         *  RelationalOperator: '<S683>/Compare'
         */
        if (c4 != 0.0F) {
          rtb_Product4_dp = -Opt / c4;
        } else {
          rtb_Product4_dp = 0.0F;
        }

        /* End of Switch: '<S672>/Switch' */

        /* Product: '<S672>/Divide3' */
        rtb_KTt_h = c4 * rtb_Product4_dp;

        /* Sum: '<S672>/Add2' incorporates:
         *  Math: '<S672>/Square2'
         *  Product: '<S672>/Divide2'
         */
        rtb_Product2_hzb = (Opt * rtb_Product4_dp + c3) + rtb_KTt_h * rtb_KTt_h;

        /* Product: '<S672>/Divide5' incorporates:
         *  Constant: '<S672>/t_Start'
         */
        rtb_KTt_h = c4 * 0.0F;

        /* Sum: '<S672>/Add1' incorporates:
         *  Constant: '<S672>/t_Start'
         *  Math: '<S672>/Square1'
         *  Product: '<S672>/Divide4'
         */
        rtb_KTt_h = (Opt * 0.0F + c3) + rtb_KTt_h * rtb_KTt_h;

        /* Product: '<S672>/Divide7' */
        rtb_K_OsV_Os_l = c4 * t_end;

        /* Sum: '<S672>/Add3' incorporates:
         *  Math: '<S672>/Square3'
         *  Product: '<S672>/Divide6'
         */
        rtb_K_OsV_Os_l = (Opt * t_end + c3) + rtb_K_OsV_Os_l * rtb_K_OsV_Os_l;

        /* MinMax: '<S672>/Min' */
        rtb_Product2_jd = fmaxf(fmaxf(rtb_Product2_hzb, rtb_KTt_h),
          rtb_K_OsV_Os_l);

        /* MinMax: '<S672>/Min1' */
        rtb_KTt_h = fminf(fminf(rtb_Product2_hzb, rtb_KTt_h), rtb_K_OsV_Os_l);

        /* Abs: '<S673>/Abs2' */
        rtb_KTt_h = fabsf(rtb_KTt_h);

        /* Product: '<S673>/Product1' incorporates:
         *  MinMax: '<S673>/Max6'
         */
        rtb_K_OsV_Os_c = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product2_jd,
          rtb_KTt_h);

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Constant: '<S639>/Constant'
         *  Sum: '<S673>/Add5'
         */
        app_B.LimitationViolate_l -= 0.277777791F;

        /* Product: '<S673>/Product2' incorporates:
         *  Constant: '<S673>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S673>/Max4'
         */
        rtb_Product4_aq = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf
          (app_B.LimitationViolate_l, 0.0F);

        /* Switch generated from: '<S670>/Switch2' incorporates:
         *  Sum: '<S673>/Add8'
         */
        app_B.LimitationViolate_l = (rtb_KTt_a + rtb_K_OsV_Os_c) +
          rtb_Product4_aq;

        /* Logic: '<S670>/Logical Operator1' incorporates:
         *  Logic: '<S670>/Logical Operator2'
         *  Logic: '<S670>/Logical Operator3'
         *  RelationalOperator: '<S670>/Relational Operator2'
         *  RelationalOperator: '<S682>/Compare'
         *  Sum: '<S670>/Add'
         *  Sum: '<S670>/Add1'
         */
        rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = ((!rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) ||
          rtb_LogicalOperator1_pr || (app_B.Opt_h + app_B.LimitationViolate_l <
          ax_Max_Traj + a_traj_real_Spd_PrdtOneStp));

        /* Switch generated from: '<S670>/Switch2' */
        rtb_LogicalOperator1_pr = ((!rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) &&
          rtb_LogicalOperator1_pr);

        /* Switch generated from: '<S670>/Switch2' */
        rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f ||
          rtb_DFIn_is_CCFM_BntStsDsbl_bl_l);

        /* Switch generated from: '<S670>/Switch2' */
        if (!rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
          /* Switch generated from: '<S670>/Switch2' */
          app_B.LimitationViolate_l = a_traj_real_Spd_PrdtOneStp;

          /* Switch generated from: '<S670>/Switch2' */
          app_B.Opt_h = ax_Max_Traj;
        }

        /* Product: '<S703>/Product5' incorporates:
         *  Product: '<S703>/Product1'
         *  Product: '<S703>/Product6'
         */
        a_traj_real_Spd_PrdtOneStp = MultiportSwitch[2] * Merge3;

        /* Product: '<S703>/Product3' incorporates:
         *  Math: '<S697>/Square7'
         *  Math: '<S702>/Square1'
         *  Product: '<S697>/Product7'
         *  Product: '<S702>/Product3'
         *  Product: '<S703>/Product2'
         *  Product: '<S703>/Product4'
         */
        rtb_Product2_jd = Merge3 * Merge3;
        rtb_Product1_ei = rtb_Product2_jd * Merge3;

        /* Product: '<S703>/Divide4' incorporates:
         *  Gain: '<S703>/Gain4'
         *  Gain: '<S703>/Gain5'
         *  Gain: '<S703>/Gain6'
         *  Product: '<S703>/Product3'
         *  Product: '<S703>/Product5'
         *  Sum: '<S703>/Add3'
         */
        rtb_Product4_lc = (a_traj_real_Spd_PrdtOneStp * 3.0F + 8.0F *
                           MultiportSwitch[1]) * 6.0F / rtb_Product1_ei;

        /* Gain: '<S703>/Gain1' incorporates:
         *  Gain: '<S703>/Gain2'
         *  Gain: '<S703>/Gain3'
         *  Product: '<S703>/Divide3'
         *  Sum: '<S703>/Add1'
         */
        rtb_KTt_h = -((2.0F * MultiportSwitch[1] + a_traj_real_Spd_PrdtOneStp) *
                      6.0F / rtb_Product2_jd);

        /* Gain: '<S703>/Gain9' incorporates:
         *  Gain: '<S703>/Gain7'
         *  Gain: '<S703>/Gain8'
         *  Product: '<S703>/Divide1'
         *  Product: '<S703>/Product2'
         *  Sum: '<S703>/Add2'
         */
        rtb_Gain1_bg = -((3.0F * MultiportSwitch[1] + a_traj_real_Spd_PrdtOneStp)
                         * 24.0F / (rtb_Product1_ei * Merge3));

        /* Sum: '<S697>/Add1' incorporates:
         *  Constant: '<S697>/Constant3'
         *  Math: '<S697>/Square3'
         *  Product: '<S697>/Product3'
         */
        a_traj_real_Spd_PrdtOneStp = rtb_Product4_lc * rtb_Product4_lc -
          rtb_KTt_h * rtb_Gain1_bg * 2.0F;

        /* Sqrt: '<S697>/Sqrt' incorporates:
         *  Abs: '<S697>/Abs'
         *  Sqrt: '<S697>/Sqrt1'
         */
        ax_Max_Traj = sqrtf(fabsf(a_traj_real_Spd_PrdtOneStp));

        /* Product: '<S697>/Divide2' incorporates:
         *  Gain: '<S697>/Gain'
         *  Sqrt: '<S697>/Sqrt'
         *  Sum: '<S697>/Add3'
         */
        rtb_K_OsV_Os_l = (-rtb_Product4_lc + ax_Max_Traj) / rtb_Gain1_bg;

        /* Product: '<S697>/Divide3' incorporates:
         *  Gain: '<S697>/Gain1'
         *  Sum: '<S697>/Add4'
         */
        Ax_Extrem1_n = (-rtb_Product4_lc - ax_Max_Traj) / rtb_Gain1_bg;

        /* Product: '<S697>/Product6' incorporates:
         *  Product: '<S702>/Product'
         */
        Ax_Extrem2_f = rtb_KTt_h * Merge3;

        /* Sum: '<S697>/Add6' incorporates:
         *  Constant: '<S697>/Constant10'
         *  Constant: '<S697>/Constant9'
         *  Product: '<S697>/Divide6'
         *  Product: '<S697>/Divide7'
         *  Product: '<S697>/Product6'
         */
        ax_Max_Traj = ((Ax_Extrem2_f + MultiportSwitch[2]) + rtb_Product4_lc /
                       2.0F * rtb_Product2_jd) + rtb_Product1_ei * (rtb_Gain1_bg
          / 6.0F);

        /* If: '<S697>/If' incorporates:
         *  Constant: '<S697>/Constant1'
         *  Constant: '<S697>/Constant2'
         *  Constant: '<S697>/Constant5'
         *  Constant: '<S697>/Constant7'
         *  Constant: '<S697>/Constant8'
         *  Math: '<S697>/Square1'
         *  Math: '<S697>/Square2'
         *  Math: '<S697>/Square4'
         *  Math: '<S697>/Square5'
         *  Product: '<S697>/Divide'
         *  Product: '<S697>/Divide1'
         *  Product: '<S697>/Divide4'
         *  Product: '<S697>/Divide5'
         *  Product: '<S697>/Product1'
         *  Product: '<S697>/Product2'
         *  Product: '<S697>/Product4'
         *  Product: '<S697>/Product5'
         *  Sum: '<S697>/Add2'
         *  Sum: '<S697>/Add5'
         */
        if (a_traj_real_Spd_PrdtOneStp < 0.0F) {
          /* Outputs for IfAction SubSystem: '<S697>/If Action Subsystem' incorporates:
           *  ActionPort: '<S705>/Action Port'
           */
          app_IfActionSubsystem(ax_Max_Traj, 0.0F, Merge3, &rtb_Product4_p,
                                &rtb_KTt_af, &rtb_Divide4_h1, &rtb_Gain9_kp);

          /* End of Outputs for SubSystem: '<S697>/If Action Subsystem' */
        } else if (a_traj_real_Spd_PrdtOneStp == 0.0F) {
          /* Outputs for IfAction SubSystem: '<S697>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S706>/Action Port'
           */
          app_IfActionSubsystem1(((MultiportSwitch[2] + rtb_KTt_h *
            rtb_K_OsV_Os_l) + rtb_Product4_lc / 2.0F * (rtb_K_OsV_Os_l *
            rtb_K_OsV_Os_l)) + rtb_Gain1_bg / 6.0F * (rtb_K_OsV_Os_l *
            rtb_K_OsV_Os_l * rtb_K_OsV_Os_l), ((MultiportSwitch[2] + rtb_KTt_h *
            Ax_Extrem1_n) + rtb_Product4_lc / 2.0F * (Ax_Extrem1_n *
            Ax_Extrem1_n)) + rtb_Gain1_bg / 6.0F * (Ax_Extrem1_n * Ax_Extrem1_n *
            Ax_Extrem1_n), rtb_K_OsV_Os_l, &rtb_Product4_p, &rtb_KTt_af,
            &rtb_Divide4_h1, &rtb_Gain9_kp);

          /* End of Outputs for SubSystem: '<S697>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S697>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S707>/Action Port'
           */
          app_IfActionSubsystem2(((MultiportSwitch[2] + rtb_KTt_h *
            rtb_K_OsV_Os_l) + rtb_Product4_lc / 2.0F * (rtb_K_OsV_Os_l *
            rtb_K_OsV_Os_l)) + rtb_Gain1_bg / 6.0F * (rtb_K_OsV_Os_l *
            rtb_K_OsV_Os_l * rtb_K_OsV_Os_l), ((MultiportSwitch[2] + rtb_KTt_h *
            Ax_Extrem1_n) + rtb_Product4_lc / 2.0F * (Ax_Extrem1_n *
            Ax_Extrem1_n)) + rtb_Gain1_bg / 6.0F * (Ax_Extrem1_n * Ax_Extrem1_n *
            Ax_Extrem1_n), rtb_K_OsV_Os_l, Ax_Extrem1_n, &rtb_Product4_p,
            &rtb_KTt_af, &rtb_Divide4_h1, &rtb_Gain9_kp);

          /* End of Outputs for SubSystem: '<S697>/If Action Subsystem2' */
        }

        /* End of If: '<S697>/If' */

        /* MinMax: '<S697>/Min' */
        a_traj_real_Spd_PrdtOneStp = fmaxf(fmaxf(fmaxf(MultiportSwitch[2],
          ax_Max_Traj), rtb_Product4_p), rtb_KTt_af);

        /* Product: '<S702>/Product4' incorporates:
         *  Constant: '<S702>/Constant1'
         *  Constant: '<S702>/Constant2'
         *  Gain: '<S702>/Gain'
         *  Product: '<S702>/Product1'
         *  Product: '<S702>/Product2'
         *  Sum: '<S702>/Add'
         */
        rtb_K_OsV_Os_l = ((0.5F * rtb_Product4_lc * rtb_Product2_jd +
                           Ax_Extrem2_f) + rtb_Product1_ei * (0.166666672F *
          rtb_Gain1_bg)) * 0.0F * nDLookupTable1;

        /* Product: '<S702>/Product5' */
        rtb_Product2_jd = rtb_Switch_ik * Merge3;

        /* Product: '<S704>/Divide9' incorporates:
         *  Constant: '<S704>/Constant5'
         */
        nDLookupTable1 = rtb_Gain1_bg * 0.0416666679F;

        /* Sum: '<S704>/Add2' incorporates:
         *  Constant: '<S704>/Constant1'
         *  Constant: '<S704>/Constant2'
         *  Product: '<S704>/Divide1'
         *  Product: '<S704>/Divide3'
         */
        rtb_Switch_ik = 2.0F * nDLookupTable1 * Merge3 + rtb_Product4_lc *
          0.166666672F;

        /* Outputs for Atomic SubSystem: '<S704>/SfD'
         *
         * Block description for '<S704>/SfD':
         *  Safe Divide
         */
        app_SfD_i(MultiportSwitch[1], Merge3 * Merge3, &rtb_Product1_ei, 0.01F);

        /* End of Outputs for SubSystem: '<S704>/SfD' */

        /* Sum: '<S704>/Add4' incorporates:
         *  Constant: '<S704>/Constant16'
         *  Product: '<S704>/Divide8'
         *  Product: '<S704>/Multiply7'
         *  Product: '<S704>/Multiply8'
         */
        Ax_Extrem1_n = rtb_Switch_ik * rtb_Switch_ik - 4.0F * nDLookupTable1 *
          rtb_Product1_ei;

        /* If: '<S704>/If' */
        if ((nDLookupTable1 != 0.0F) && (Ax_Extrem1_n >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem' incorporates:
           *  ActionPort: '<S714>/Action Port'
           */
          app_IfActionSubsystem_c(nDLookupTable1, rtb_Switch_ik, Ax_Extrem1_n,
            Merge3, rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem' */
        } else if ((nDLookupTable1 == 0.0F) && (rtb_Switch_ik != 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem1' incorporates:
           *  ActionPort: '<S715>/Action Port'
           */
          app_IfActionSubsystem1_h(rtb_Switch_ik, rtb_Product1_ei, Merge3,
            rtb_Switch1_g);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem1' */
        } else {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem2' incorporates:
           *  ActionPort: '<S716>/Action Port'
           */
          /* SignalConversion: '<S716>/Signal Conversion' */
          rtb_Switch1_g[0] = Merge3;
          rtb_Switch1_g[1] = Merge3;

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem2' */
        }

        /* End of If: '<S704>/If' */

        /* Sum: '<S712>/Add' incorporates:
         *  Gain: '<S712>/Gain'
         *  Gain: '<S712>/Gain1'
         *  Gain: '<S712>/Gain2'
         *  Product: '<S712>/Multiply'
         *  Product: '<S712>/Multiply1'
         *  Product: '<S712>/Multiply2'
         *  Product: '<S712>/Multiply3'
         */
        rtb_Product1_ei = ((rtb_KTt_h * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
                            0.5F + (MultiportSwitch[2] * rtb_Switch1_g[0] +
          MultiportSwitch[1])) + rtb_Product4_lc * rtb_Switch1_g[0] *
                           rtb_Switch1_g[0] * rtb_Switch1_g[0] * 0.166666672F) +
          rtb_Gain1_bg * rtb_Switch1_g[0] * rtb_Switch1_g[0] * rtb_Switch1_g[0] *
          rtb_Switch1_g[0] * 0.0416666679F;

        /* Product: '<S704>/Multiply9' */
        nDLookupTable1 = MultiportSwitch[1] * rtb_Product1_ei;

        /* Sum: '<S713>/Add' incorporates:
         *  Gain: '<S713>/Gain'
         *  Gain: '<S713>/Gain1'
         *  Gain: '<S713>/Gain2'
         *  Product: '<S713>/Multiply'
         *  Product: '<S713>/Multiply1'
         *  Product: '<S713>/Multiply2'
         *  Product: '<S713>/Multiply3'
         */
        Ax_Extrem1_n = ((rtb_KTt_h * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.5F
                         + (MultiportSwitch[2] * rtb_Switch1_g[1] +
                            MultiportSwitch[1])) + rtb_Product4_lc *
                        rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] *
                        0.166666672F) + rtb_Gain1_bg * rtb_Switch1_g[1] *
          rtb_Switch1_g[1] * rtb_Switch1_g[1] * rtb_Switch1_g[1] * 0.0416666679F;

        /* Product: '<S704>/Multiply10' */
        rtb_Switch_ik = MultiportSwitch[1] * Ax_Extrem1_n;

        /* If: '<S704>/If1' */
        if ((nDLookupTable1 < 0.0F) && (rtb_Switch_ik >= 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem3' incorporates:
           *  ActionPort: '<S717>/Action Port'
           */
          app_IfActionSubsystem3(rtb_Product1_ei, &rtb_Switch_ik);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem3' */
        } else if ((nDLookupTable1 >= 0.0F) && (rtb_Switch_ik < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem4' incorporates:
           *  ActionPort: '<S718>/Action Port'
           */
          app_IfActionSubsystem4(Ax_Extrem1_n, &rtb_Switch_ik);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem4' */
        } else if ((nDLookupTable1 < 0.0F) && (rtb_Switch_ik < 0.0F)) {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem5' incorporates:
           *  ActionPort: '<S719>/Action Port'
           */
          app_IfActionSubsystem5(rtb_Product1_ei, Ax_Extrem1_n, &rtb_Switch_ik);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem5' */
        } else {
          /* Outputs for IfAction SubSystem: '<S704>/If Action Subsystem6' incorporates:
           *  ActionPort: '<S720>/Action Port'
           */
          app_IfActionSubsystem6(&rtb_Switch_ik);

          /* End of Outputs for SubSystem: '<S704>/If Action Subsystem6' */
        }

        /* End of If: '<S704>/If1' */

        /* Product: '<S702>/Product6' */
        nDLookupTable1 = rtb_ACC_t_FTCDsrdDistLv2_sg * rtb_Switch_ik;

        /* Sum: '<S702>/Add1' */
        Ax_Extrem1_n = (rtb_K_OsV_Os_l + rtb_Product2_jd) + nDLookupTable1;

        /* Product: '<S701>/Product4' incorporates:
         *  Abs: '<S701>/Abs'
         *  MinMax: '<S697>/Min1'
         *  MinMax: '<S701>/Max5'
         */
        rtb_Product_eqe *= fmaxf(a_traj_real_Spd_PrdtOneStp, fabsf(fminf(fminf
          (fminf(MultiportSwitch[2], ax_Max_Traj), rtb_Product4_p), rtb_KTt_af)));

        /* Switch: '<S700>/Switch' incorporates:
         *  Constant: '<S700>/Invalid'
         *  Constant: '<S711>/Constant'
         *  Gain: '<S700>/Gain'
         *  Product: '<S700>/Divide1'
         *  RelationalOperator: '<S711>/Compare'
         */
        if (rtb_Gain1_bg != 0.0F) {
          ax_Max_Traj = -rtb_Product4_lc / rtb_Gain1_bg;
        } else {
          ax_Max_Traj = 0.0F;
        }

        /* End of Switch: '<S700>/Switch' */

        /* Product: '<S700>/Divide3' */
        t_Ax_Extrem2_g = rtb_Gain1_bg * ax_Max_Traj;

        /* Sum: '<S700>/Add2' incorporates:
         *  Math: '<S700>/Square2'
         *  Product: '<S700>/Divide2'
         */
        t_Ax_Extrem2_g = (rtb_Product4_lc * ax_Max_Traj + rtb_KTt_h) +
          t_Ax_Extrem2_g * t_Ax_Extrem2_g;

        /* Product: '<S700>/Divide5' incorporates:
         *  Constant: '<S700>/t_Start'
         */
        Ax_Extrem2_f = rtb_Gain1_bg * 0.0F;

        /* Sum: '<S700>/Add1' incorporates:
         *  Constant: '<S700>/t_Start'
         *  Math: '<S700>/Square1'
         *  Product: '<S700>/Divide4'
         */
        Ax_Extrem2_f = (rtb_Product4_lc * 0.0F + rtb_KTt_h) + Ax_Extrem2_f *
          Ax_Extrem2_f;

        /* Product: '<S700>/Divide7' */
        t_Ax_Extrem1_e = rtb_Gain1_bg * Merge3;

        /* Sum: '<S700>/Add3' incorporates:
         *  Math: '<S700>/Square3'
         *  Product: '<S700>/Divide6'
         */
        t_Ax_Extrem1_e = (rtb_Product4_lc * Merge3 + rtb_KTt_h) + t_Ax_Extrem1_e
          * t_Ax_Extrem1_e;

        /* MinMax: '<S700>/Min' */
        rtb_Product1_ei = fmaxf(fmaxf(t_Ax_Extrem2_g, Ax_Extrem2_f),
          t_Ax_Extrem1_e);

        /* MinMax: '<S700>/Min1' */
        Ax_Extrem2_f = fminf(fminf(t_Ax_Extrem2_g, Ax_Extrem2_f), t_Ax_Extrem1_e);

        /* Abs: '<S701>/Abs2' */
        Ax_Extrem2_f = fabsf(Ax_Extrem2_f);

        /* Product: '<S701>/Product1' incorporates:
         *  MinMax: '<S701>/Max6'
         */
        rtb_Product1_ei = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Product1_ei,
          Ax_Extrem2_f);

        /* Sum: '<S701>/Add5' incorporates:
         *  Constant: '<S640>/Constant'
         */
        rtb_Switch_ik -= 0.277777791F;

        /* Product: '<S701>/Product2' incorporates:
         *  Constant: '<S701>/Constant5'
         *  Lookup_n-D: '<S500>/n-D Lookup Table5'
         *  MinMax: '<S701>/Max4'
         */
        t_Ax_Extrem1_e = rtb_ACC_t_FTCDsrdDistLv2_sg * fmaxf(rtb_Switch_ik, 0.0F);

        /* Sum: '<S701>/Add8' */
        Ax_Extrem2_f = (rtb_Product_eqe + rtb_Product1_ei) + t_Ax_Extrem1_e;

        /* Logic: '<S698>/Logical Operator1' incorporates:
         *  Logic: '<S698>/Logical Operator2'
         *  Logic: '<S698>/Logical Operator3'
         *  RelationalOperator: '<S698>/Relational Operator2'
         *  RelationalOperator: '<S710>/Compare'
         *  Sum: '<S698>/Add'
         *  Sum: '<S698>/Add1'
         */
        rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p = ((!rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) ||
          rtb_LogicalOperator1_pr || (Ax_Extrem1_n + Ax_Extrem2_f < app_B.Opt_h
          + app_B.LimitationViolate_l));

        /* Switch generated from: '<S698>/Switch2' */
        app_B.Collision_e = ((!rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) &&
                             rtb_LogicalOperator1_pr);

        /* Switch generated from: '<S698>/Switch2' incorporates:
         *  Switch generated from: '<S642>/Switch2'
         *  Switch generated from: '<S670>/Switch2'
         */
        if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
          /* Switch generated from: '<S698>/Switch2' */
          app_B.Ax_Extrem1_c = rtb_Product4_p;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.Ax_Extrem2_m2 = rtb_KTt_af;

          /* Sum: '<S644>/Add2' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.Jerk_Extrem_m = t_Ax_Extrem2_g;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.t_end_b = Merge3;
        } else if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.Ax_Extrem1_c = t_Ax_Extrem2;

          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.Ax_Extrem2_m2 = t_Jerk_Extrem;

          /* Sum: '<S644>/Add2' incorporates:
           *  Switch generated from: '<S670>/Switch2'
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.Jerk_Extrem_m = rtb_Product2_hzb;

          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.t_end_b = t_end;
        } else if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          /* Switch generated from: '<S642>/Switch2' incorporates:
           *  Switch generated from: '<S670>/Switch2'
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.t_end_b = rtb_Switch_ai;
        } else {
          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S642>/Switch2'
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.Ax_Extrem1_c = app_B.Ax_Extrem1_nb;

          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S642>/Switch2'
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.Ax_Extrem2_m2 = app_B.Ax_Extrem2_k;

          /* Sum: '<S644>/Add2' incorporates:
           *  Switch generated from: '<S642>/Switch2'
           *  Switch generated from: '<S670>/Switch2'
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.Jerk_Extrem_m = app_B.Jerk_Extrem_h;

          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Switch generated from: '<S642>/Switch2'
           *  Switch generated from: '<S670>/Switch2'
           */
          app_B.t_end_b = app_B.t_end_m;
        }

        /* Switch generated from: '<S698>/Switch2' */
        app_B.Traj_valid_d = (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p ||
                              rtb_DFIn_is_CCFM_BntStsDsbl_bl_l);

        /* Switch generated from: '<S698>/Switch2' */
        if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
          /* MinMax: '<S641>/Min' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.ax_Max_Traj_o = a_traj_real_Spd_PrdtOneStp;

          /* Switch generated from: '<S698>/Switch2' incorporates:
           *  Constant: '<S640>/Constant1'
           */
          app_B.Traj_Numb_n = 26U;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.Opt_SubIterm_i[0] = rtb_K_OsV_Os_l;
          app_B.Opt_SubIterm_i[1] = rtb_Product2_jd;
          app_B.Opt_SubIterm_i[2] = nDLookupTable1;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.LmtViolt_SubIterm_i[0] = rtb_Product_eqe;
          app_B.LmtViolt_SubIterm_i[1] = rtb_Product1_ei;
          app_B.LmtViolt_SubIterm_i[2] = t_Ax_Extrem1_e;

          /* Switch generated from: '<S670>/Switch2' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.LimitationViolate_l = Ax_Extrem2_f;

          /* Switch generated from: '<S670>/Switch2' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.Opt_h = Ax_Extrem1_n;

          /* Gain: '<S647>/Gain1' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.c3_k = rtb_KTt_h;

          /* Product: '<S647>/Divide4' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.c4_po = rtb_Product4_lc;

          /* Gain: '<S647>/Gain9' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.c5_p = rtb_Gain1_bg;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.t_Ax_Extrem1_a = rtb_Divide4_h1;

          /* Switch generated from: '<S698>/Switch2' */
          app_B.t_Ax_Extrem2_ci = rtb_Gain9_kp;

          /* Switch: '<S644>/Switch' incorporates:
           *  Switch generated from: '<S698>/Switch2'
           */
          app_B.t_Jerk_Extrem_o = ax_Max_Traj;
        } else {
          /* Switch generated from: '<S670>/Switch2' incorporates:
           *  Switch generated from: '<S642>/Switch2'
           */
          if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
            /* MinMax: '<S641>/Min' incorporates:
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.ax_Max_Traj_o = Ax_Extrem1;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Constant: '<S639>/Constant1'
             */
            app_B.Traj_Numb_n = 25U;

            /* Switch generated from: '<S698>/Switch2' */
            app_B.Opt_SubIterm_i[0] = Ax_Extrem2;
            app_B.Opt_SubIterm_i[1] = Jerk_Extrem;
            app_B.Opt_SubIterm_i[2] = rtb_Product1_j2z;

            /* Switch generated from: '<S698>/Switch2' */
            app_B.LmtViolt_SubIterm_i[0] = rtb_KTt_a;
            app_B.LmtViolt_SubIterm_i[1] = rtb_K_OsV_Os_c;
            app_B.LmtViolt_SubIterm_i[2] = rtb_Product4_aq;
          } else if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
            /* Switch generated from: '<S642>/Switch2' incorporates:
             *  Constant: '<S638>/Constant1'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.Traj_Numb_n = 24U;

            /* Switch generated from: '<S642>/Switch2' incorporates:
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.Opt_SubIterm_i[0] = s_traj_real_Spd;
            app_B.Opt_SubIterm_i[1] = v_traj_real_Spd;
            app_B.Opt_SubIterm_i[2] = Longt_Spd_C0;

            /* Switch generated from: '<S642>/Switch2' incorporates:
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.LmtViolt_SubIterm_i[0] = Longt_Spd_C1;
            app_B.LmtViolt_SubIterm_i[1] = j_traj_real_Spd;
            app_B.LmtViolt_SubIterm_i[2] = LimitationViolate;
          } else {
            /* MinMax: '<S641>/Min' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.ax_Max_Traj_o = app_B.ax_Max_Traj_m;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             */
            app_B.Traj_Numb_n = app_B.Traj_Numb_d;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             */
            app_B.Opt_SubIterm_i[0] = app_B.Opt_SubIterm_e[0];
            app_B.Opt_SubIterm_i[1] = app_B.Opt_SubIterm_e[1];
            app_B.Opt_SubIterm_i[2] = app_B.Opt_SubIterm_e[2];

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             */
            app_B.LmtViolt_SubIterm_i[0] = app_B.LmtViolt_SubIterm_a[0];
            app_B.LmtViolt_SubIterm_i[1] = app_B.LmtViolt_SubIterm_a[1];
            app_B.LmtViolt_SubIterm_i[2] = app_B.LmtViolt_SubIterm_a[2];
          }

          if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
            /* Gain: '<S647>/Gain1' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c3_k = c3;

            /* Product: '<S647>/Divide4' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c4_po = Opt;

            /* Gain: '<S647>/Gain9' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c5_p = c4;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             */
            app_B.t_Ax_Extrem1_a = c5;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             */
            app_B.t_Ax_Extrem2_ci = t_Ax_Extrem1;

            /* Switch: '<S644>/Switch' incorporates:
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.t_Jerk_Extrem_o = rtb_Product4_dp;
          } else if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
          } else {
            /* Gain: '<S647>/Gain1' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c3_k = app_B.c3_f;

            /* Product: '<S647>/Divide4' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c4_po = app_B.c4_p;

            /* Gain: '<S647>/Gain9' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.c5_p = app_B.c5_f;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             */
            app_B.t_Ax_Extrem1_a = app_B.t_Ax_Extrem1_nf;

            /* Switch generated from: '<S698>/Switch2' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             */
            app_B.t_Ax_Extrem2_ci = app_B.t_Ax_Extrem2_c;

            /* Switch: '<S644>/Switch' incorporates:
             *  Switch generated from: '<S642>/Switch2'
             *  Switch generated from: '<S670>/Switch2'
             *  Switch generated from: '<S698>/Switch2'
             */
            app_B.t_Jerk_Extrem_o = app_B.t_Jerk_Extrem_b;
          }
        }

        /* End of Outputs for SubSystem: '<S535>/Enabled Subsystem1' */

        /* Gain: '<S762>/Gain1' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.c3_f = app_B.c3_k;
      }

      /* End of Switch: '<S544>/Switch2' */

      /* Product: '<S538>/Product12' incorporates:
       *  Constant: '<S538>/Constant2'
       */
      app_B.Product12 = 0.166666672F * app_B.c3_f;

      /* Switch generated from: '<S541>/Switch' */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        /* Product: '<S762>/Divide4' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.c4_p = app_B.c4_po;

        /* Gain: '<S762>/Gain9' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.c5_f = app_B.c5_p;
      }

      /* Product: '<S538>/Product13' incorporates:
       *  Constant: '<S538>/Constant3'
       */
      app_B.Product13 = 0.0416666679F * app_B.c4_p;

      /* Product: '<S538>/Product16' incorporates:
       *  Constant: '<S538>/Constant4'
       */
      app_B.Product16 = 0.00833333377F * app_B.c5_f;

      /* SignalConversion generated from: '<S535>/Traj_B_Batch_Out' */
      app_B.Longt_Spd_C0_m = MultiportSwitch[0];

      /* Switch generated from: '<S541>/Switch' */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        /* Switch generated from: '<S542>/Switch' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Collision_o = app_B.Collision_e;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Ax_Extrem1_nb = app_B.Ax_Extrem1_c;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Ax_Extrem2_k = app_B.Ax_Extrem2_m2;

        /* Sum: '<S759>/Add2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Jerk_Extrem_h = app_B.Jerk_Extrem_m;

        /* Switch generated from: '<S542>/Switch' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.t_end_m = app_B.t_end_b;

        /* Switch generated from: '<S542>/Switch' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Traj_valid_e = app_B.Traj_valid_d;

        /* MinMax: '<S757>/Min' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.ax_Max_Traj_m = app_B.ax_Max_Traj_o;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Traj_Numb_d = app_B.Traj_Numb_n;

        /* Switch generated from: '<S541>/Switch' */
        app_B.Opt_SubIterm_e[0] = app_B.Opt_SubIterm_i[0];

        /* Switch generated from: '<S541>/Switch' */
        app_B.LmtViolt_SubIterm_a[0] = app_B.LmtViolt_SubIterm_i[0];

        /* Switch generated from: '<S541>/Switch' */
        app_B.Opt_SubIterm_e[1] = app_B.Opt_SubIterm_i[1];

        /* Switch generated from: '<S541>/Switch' */
        app_B.LmtViolt_SubIterm_a[1] = app_B.LmtViolt_SubIterm_i[1];

        /* Switch generated from: '<S541>/Switch' */
        app_B.Opt_SubIterm_e[2] = app_B.Opt_SubIterm_i[2];

        /* Switch generated from: '<S541>/Switch' */
        app_B.LmtViolt_SubIterm_a[2] = app_B.LmtViolt_SubIterm_i[2];

        /* Switch generated from: '<S841>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.LimitationViolate_k = app_B.LimitationViolate_l;

        /* Switch generated from: '<S841>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.Opt_m = app_B.Opt_h;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.t_Ax_Extrem1_nf = app_B.t_Ax_Extrem1_a;

        /* Switch generated from: '<S870>/Switch2' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.t_Ax_Extrem2_c = app_B.t_Ax_Extrem2_ci;

        /* Switch: '<S759>/Switch' incorporates:
         *  Switch generated from: '<S541>/Switch'
         */
        app_B.t_Jerk_Extrem_b = app_B.t_Jerk_Extrem_o;
      }

      /* Switch: '<S544>/Switch5' incorporates:
       *  Constant: '<S544>/Constant6'
       *  Constant: '<S544>/Constant8'
       *  Constant: '<S727>/Constant'
       *  RelationalOperator: '<S727>/Compare'
       *  Sum: '<S544>/Add3'
       *  Switch: '<S544>/Switch3'
       *  UnitDelay: '<S544>/Unit Delay'
       */
      if ((int32_T)app_DW.UnitDelay_DSTATE_it >= 255) {
        app_DW.UnitDelay_DSTATE_it = 0U;
      }

      app_DW.UnitDelay_DSTATE_it = (uint8_T)(uint32_T)((uint32_T)
        app_DW.UnitDelay_DSTATE_it + 1U);

      /* End of Switch: '<S544>/Switch5' */
      /* End of Outputs for SubSystem: '<S502>/Trj_RePlan' */

      /* Outputs for Function Call SubSystem: '<S502>/Trj_RePlan1' */
      /* Update for UnitDelay: '<S501>/Unit Delay' incorporates:
       *  UnitDelay: '<S544>/Unit Delay'
       */
      app_Trj_RePlan1(app_DW.UnitDelay_DSTATE_it, app_B.Add2, app_B.Product_e,
                      app_B.Product12, app_B.Product13, app_B.Product16,
                      app_B.Longt_Spd_C0_m, app_B.t_end_m, app_B.Collision_o,
                      app_B.Ax_Extrem1_nb, app_B.Ax_Extrem2_k,
                      app_B.Jerk_Extrem_h, app_B.Traj_valid_e,
                      app_B.ax_Max_Traj_m, app_B.Traj_Numb_d,
                      app_B.Opt_SubIterm_e, app_B.LmtViolt_SubIterm_a,
                      app_B.LimitationViolate_k, app_B.Opt_m, app_B.c3_f,
                      app_B.c4_p, app_B.c5_f, app_B.t_Ax_Extrem1_nf,
                      app_B.t_Ax_Extrem2_c, app_B.t_Jerk_Extrem_b,
                      &s_traj_real_Spd, &v_traj_real_Spd,
                      &rtb_ACC_t_FTCDsrdDistLv2_sg, &j_traj_real_Spd,
                      &a_traj_real_Spd_PrdtOneStp, &Longt_Spd_C0, &Longt_Spd_C1,
                      &rtb_Product_eqe, &nDLookupTable1, &rtb_Switch_ik,
                      &rtb_Switch_ai, &DataTypeConversion2,
                      &rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m, &LimitationViolate,
                      &Opt, &c3, &c4, &c5, &t_Ax_Extrem1, &t_Ax_Extrem2,
                      &t_Jerk_Extrem, &Ax_Extrem1, &Ax_Extrem2, &Jerk_Extrem,
                      &t_end, &rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d, &ax_Max_Traj,
                      &Traj_Numb, MultiportSwitch, LmtViolt_SubIterm, &Merge2_a,
                      &Merge3, &app_DW.UnitDelay_DSTATE_f,
                      &app_ConstB.Trj_RePlan1, &app_DW.Trj_RePlan1);

      /* End of Outputs for SubSystem: '<S502>/Trj_RePlan1' */
    } else {
      /* Outputs for Function Call SubSystem: '<S502>/Trj_RePlan1' */
      /* Update for UnitDelay: '<S501>/Unit Delay' incorporates:
       *  UnitDelay: '<S544>/Unit Delay'
       */
      app_Trj_RePlan1(app_DW.UnitDelay_DSTATE_it, app_B.Add2, app_B.Product_e,
                      app_B.Product12, app_B.Product13, app_B.Product16,
                      app_B.Longt_Spd_C0_m, app_B.t_end_m, app_B.Collision_o,
                      app_B.Ax_Extrem1_nb, app_B.Ax_Extrem2_k,
                      app_B.Jerk_Extrem_h, app_B.Traj_valid_e,
                      app_B.ax_Max_Traj_m, app_B.Traj_Numb_d,
                      app_B.Opt_SubIterm_e, app_B.LmtViolt_SubIterm_a,
                      app_B.LimitationViolate_k, app_B.Opt_m, app_B.c3_f,
                      app_B.c4_p, app_B.c5_f, app_B.t_Ax_Extrem1_nf,
                      app_B.t_Ax_Extrem2_c, app_B.t_Jerk_Extrem_b,
                      &s_traj_real_Spd, &v_traj_real_Spd,
                      &rtb_ACC_t_FTCDsrdDistLv2_sg, &j_traj_real_Spd,
                      &a_traj_real_Spd_PrdtOneStp, &Longt_Spd_C0, &Longt_Spd_C1,
                      &rtb_Product_eqe, &nDLookupTable1, &rtb_Switch_ik,
                      &rtb_Switch_ai, &DataTypeConversion2,
                      &rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m, &LimitationViolate,
                      &Opt, &c3, &c4, &c5, &t_Ax_Extrem1, &t_Ax_Extrem2,
                      &t_Jerk_Extrem, &Ax_Extrem1, &Ax_Extrem2, &Jerk_Extrem,
                      &t_end, &rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d, &ax_Max_Traj,
                      &Traj_Numb, MultiportSwitch, LmtViolt_SubIterm, &Merge2_a,
                      &Merge3, &app_DW.UnitDelay_DSTATE_f,
                      &app_ConstB.Trj_RePlan1, &app_DW.Trj_RePlan1);

      /* End of Outputs for SubSystem: '<S502>/Trj_RePlan1' */
    }

    /* End of Chart: '<S502>/TRP_Scheduling' */

    /* Gain: '<S137>/Gain2' incorporates:
     *  Constant: '<S92>/Constant19'
     *  MinMax: '<S155>/MinMax2'
     */
    rtb_Add_g0 = 2.0F * fmaxf(rtb_Add_g0, -5.0F);

    /* Gain: '<S137>/Gain3' incorporates:
     *  Constant: '<S92>/Constant21'
     *  MinMax: '<S156>/MinMax2'
     */
    rtb_Product_iz = 2.0F * fminf(rtb_Product_iz, 3.0F);

    /* Gain: '<S137>/Gain1' incorporates:
     *  Constant: '<S158>/k_j_ActvAccJerkMin_sg'
     *  Lookup_n-D: '<S158>/1-D Lookup Table'
     *  MinMax: '<S158>/MinMax1'
     *  Switch: '<S158>/Switch'
     */
    j_traj_real_Spd = -2.0F * fmaxf(fmaxf(3.0F, rtb_a_traj_FEMid),
      app_ConstB.MultiportSwitch_l);

    /* MinMax: '<S159>/MinMax1' incorporates:
     *  Constant: '<S92>/Constant15'
     */
    rtb_uDLookupTable5_h = fminf(fminf(fminf(app_ConstB.MultiportSwitch_k,
      rtb_uDLookupTable5_h), rtb_a_traj_FEMid), 10.0F);

    /* Gain: '<S137>/Gain' */
    LimitationViolate = 2.0F * rtb_uDLookupTable5_h;

    /* Logic: '<S481>/OR' incorporates:
     *  Logic: '<S238>/AND'
     *  Logic: '<S238>/AND1'
     *  Logic: '<S481>/NOT'
     *  Switch: '<S175>/Switch3'
     *  UnitDelay: '<S140>/Unit Delay'
     *  UnitDelay: '<S140>/Unit Delay1'
     */
    rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = ((rtb_DFIn_is_AEBStsDsbl_bl &&
      app_B.Collision_b) || ((!app_B.Traj_Valid) && rtb_DFIn_is_AEBStsDsbl_bl) ||
      rtb_OR_f);

    /* MATLAB Function: '<S484>/MATLAB Function' incorporates:
     *  UnitDelay generated from: '<S140>/Unit Delay4'
     */
    Opt = app_DW.UnitDelay4_7_DSTATE * app_DW.UnitDelay4_7_DSTATE;
    rtb_uDLookupTable5_h = (Opt * app_B.c4_traj / 2.0F + (app_B.c3_traj *
      app_DW.UnitDelay4_7_DSTATE + app_DW.UnitDelay4_1_DSTATE)) + app_B.c5_traj *
      rt_powf_snf(app_DW.UnitDelay4_7_DSTATE, 3.0F) / 6.0F;
    Opt = Opt * app_B.c5_traj / 2.0F + (app_B.c4_traj *
      app_DW.UnitDelay4_7_DSTATE + app_B.c3_traj);
    c3 = app_B.t_end_mp * app_B.t_end_mp;
    c4 = (c3 * app_B.c4_traj / 2.0F + (app_B.c3_traj * app_B.t_end_mp +
           app_DW.UnitDelay4_1_DSTATE)) + app_B.c5_traj * rt_powf_snf
      (app_B.t_end_mp, 3.0F) / 6.0F;
    c3 = c3 * app_B.c5_traj / 2.0F + (app_B.c4_traj * app_B.t_end_mp +
      app_B.c3_traj);

    /* Switch: '<S484>/Switch' incorporates:
     *  MinMax: '<S484>/Max'
     *  MinMax: '<S484>/Max1'
     *  MinMax: '<S484>/Max2'
     *  MinMax: '<S484>/Max3'
     *  RelationalOperator: '<S484>/Relational Operator'
     *  UnitDelay generated from: '<S140>/Unit Delay3'
     *  UnitDelay generated from: '<S140>/Unit Delay4'
     */
    if (app_DW.UnitDelay4_7_DSTATE < app_B.t_Jerk_Extrem_n) {
      rtb_Switch1_g[0] = fmaxf(fmaxf(Opt, app_B.Jerk_Extrem_o), c3);
      rtb_Switch1_g[1] = fminf(fminf(Opt, app_B.Jerk_Extrem_o), c3);
    } else {
      rtb_Switch1_g[0] = fmaxf(Opt, c3);
      rtb_Switch1_g[1] = fminf(Opt, c3);
    }

    /* End of Switch: '<S484>/Switch' */

    /* Logic: '<S484>/OR' incorporates:
     *  RelationalOperator: '<S484>/Relational Operator1'
     *  RelationalOperator: '<S484>/Relational Operator2'
     */
    rtb_OR_f = ((rtb_Switch1_g[0] > LimitationViolate) || (rtb_Switch1_g[1] <
      j_traj_real_Spd));

    /* Switch: '<S484>/Switch1' incorporates:
     *  Logic: '<S484>/AND'
     *  MinMax: '<S484>/Max4'
     *  MinMax: '<S484>/Max5'
     *  RelationalOperator: '<S484>/Relational Operator3'
     *  RelationalOperator: '<S484>/Relational Operator4'
     *  RelationalOperator: '<S484>/Relational Operator5'
     *  Switch: '<S484>/Switch2'
     *  UnitDelay generated from: '<S140>/Unit Delay3'
     *  UnitDelay generated from: '<S140>/Unit Delay4'
     */
    if (app_DW.UnitDelay4_7_DSTATE < app_B.t_Ax_Extrem1_l) {
      rtb_Switch1_g[0] = fmaxf(fmaxf(fmaxf(rtb_uDLookupTable5_h, c4),
        app_B.Ax_Extrem1_bf), app_B.Ax_Extrem2_f0);
      rtb_Switch1_g[1] = fminf(fminf(fminf(rtb_uDLookupTable5_h, c4),
        app_B.Ax_Extrem1_bf), app_B.Ax_Extrem2_f0);
    } else if ((app_DW.UnitDelay4_7_DSTATE > app_B.t_Ax_Extrem1_l) &&
               (app_DW.UnitDelay4_7_DSTATE < app_B.t_Ax_Extrem2_cz)) {
      /* Switch: '<S484>/Switch2' incorporates:
       *  MinMax: '<S484>/Max6'
       *  MinMax: '<S484>/Max7'
       */
      rtb_Switch1_g[0] = fmaxf(fmaxf(rtb_uDLookupTable5_h, c4),
        app_B.Ax_Extrem2_f0);
      rtb_Switch1_g[1] = fminf(fminf(rtb_uDLookupTable5_h, c4),
        app_B.Ax_Extrem2_f0);
    } else {
      /* Switch: '<S484>/Switch2' incorporates:
       *  MinMax: '<S484>/Max8'
       *  MinMax: '<S484>/Max9'
       */
      rtb_Switch1_g[0] = fmaxf(rtb_uDLookupTable5_h, c4);
      rtb_Switch1_g[1] = fminf(rtb_uDLookupTable5_h, c4);
    }

    /* End of Switch: '<S484>/Switch1' */

    /* Logic: '<S484>/OR2' incorporates:
     *  Logic: '<S484>/OR1'
     *  RelationalOperator: '<S484>/Relational Operator6'
     *  RelationalOperator: '<S484>/Relational Operator7'
     */
    rtb_OR_f = (rtb_OR_f || ((rtb_Switch1_g[0] > rtb_Product_iz) ||
      (rtb_Switch1_g[1] < rtb_Add_g0)));

    /* Logic: '<S483>/OR' incorporates:
     *  Constant: '<S483>/Constant'
     *  Constant: '<S483>/Constant1'
     *  Constant: '<S483>/Constant3'
     *  Constant: '<S485>/Constant'
     *  Logic: '<S483>/AND'
     *  RelationalOperator: '<S483>/Equal'
     *  RelationalOperator: '<S483>/Equal1'
     *  RelationalOperator: '<S483>/Relational Operator'
     *  RelationalOperator: '<S485>/Relational Operator'
     *  Sum: '<S485>/Minus'
     *  UnitDelay: '<S137>/Unit Delay3'
     *  UnitDelay generated from: '<S140>/Unit Delay4'
     *  UnitDelay: '<S140>/Unit Delay5'
     *  UnitDelay: '<S483>/Unit Delay'
     */
    rtb_OR_f = ((app_B.t_end_mp - app_DW.UnitDelay4_7_DSTATE < 1.0F) ||
                (((int32_T)app_DW.UnitDelay_DSTATE_ie == 1) && ((int32_T)
      app_DW.UnitDelay3_DSTATE == 2)) || rtb_OR_f || (app_DW.UnitDelay5_DSTATE_e
      >= k_TRPLon_t_DistNrmRePlanTm_sg));

    /* Chart: '<S238>/Chart' incorporates:
     *  Logic: '<S238>/OR1'
     */
    app_Chart_b(longt_out_isCtrlEngage, rtb_LogicalOperator9_kf,
                rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m, rtb_OR_f,
                &m_TRP_Replan_Level_Dis);

    /* Switch: '<S137>/Switch2' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S137>/Constant4'
     *  SignalConversion: '<S911>/Signal Copy2'
     */
    if (k_TRPLon_is_Use_dst_target_bl) {
      rtb_ARB_F_PCTWhlDrvnToq_sg = m_dst_target;
    } else {
      rtb_ARB_F_PCTWhlDrvnToq_sg = rtb_uDLookupTable;
    }

    /* End of Switch: '<S137>/Switch2' */

    /* Product: '<S239>/Product4' incorporates:
     *  Constant: '<S239>/Constant1'
     *  Lookup_n-D: '<S239>/1-D Lookup Table8'
     *  Sum: '<S120>/Add1'
     */
    Opt = look1_iflf_binlcapw(rtb_ARB_F_PCTWhlDrvnToq_sg, app_ConstP.pooled86,
      k_TRPLon_cof_Kt_TblData_sg, 10U) * k_TRPLon_Gx_TrajKtWght_sg;

    /* Product: '<S239>/Product1' incorporates:
     *  DataTypeConversion: '<S1060>/Data Type Conversion7'
     *  Lookup_n-D: '<S239>/1-D Lookup Table2'
     *  Lookup_n-D: '<S239>/1-D Lookup Table3'
     *  Sum: '<S120>/Add1'
     *  UnitDelay: '<S1060>/spdD3'
     */
    c3 = look1_iflf_binlcapw((real32_T)app_DW.spdD3_DSTATE, app_ConstP.pooled43,
      app_ConstP.uDLookupTable2_tableData, 12U) * look1_iflf_binlcapw
      (rtb_ARB_F_PCTWhlDrvnToq_sg, app_ConstP.pooled87,
       app_ConstP.uDLookupTable3_tableData, 9U);

    /* Sum: '<S239>/Add' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  Constant: '<S239>/Constant6'
     *  SignalConversion: '<S911>/Signal Copy2'
     *  Sum: '<S239>/Subtract'
     */
    c4 = (rtb_uDLookupTable - rtb_ARB_F_PCTWhlDrvnToq_sg) - 1.0F;

    /* Abs: '<S239>/Abs' */
    rtb_uDLookupTable5_h = fabsf(rtb_ACC_t_FTCDsrdDistLv1_sg);

    /* Product: '<S239>/Product2' incorporates:
     *  Lookup_n-D: '<S239>/1-D Lookup Table4'
     *  Lookup_n-D: '<S239>/1-D Lookup Table5'
     *  Lookup_n-D: '<S239>/1-D Lookup Table6'
     *  Sum: '<S120>/Add1'
     */
    Ax_Extrem2_j = look1_iflf_binlcapw(rtb_ARB_F_PCTWhlDrvnToq_sg,
      app_ConstP.pooled87, app_ConstP.uDLookupTable6_tableData, 9U) *
      look1_iflf_binlcapw(rtb_uDLookupTable5_h, app_ConstP.pooled86,
                          app_ConstP.uDLookupTable4_tableData, 10U);

    /* Lookup_n-D: '<S239>/1-D Lookup Table5' */
    rtb_uDLookupTable5_h = look1_iflf_binlcapw(rtb_uDLookupTable5_h,
      app_ConstP.pooled86, app_ConstP.uDLookupTable5_tableData, 10U);

    /* Product: '<S239>/Product3' incorporates:
     *  Lookup_n-D: '<S239>/1-D Lookup Table7'
     *  Sum: '<S120>/Add1'
     */
    c5 = look1_iflf_binlcapw(rtb_ARB_F_PCTWhlDrvnToq_sg, app_ConstP.pooled87,
      app_ConstP.uDLookupTable7_tableData, 9U) * rtb_uDLookupTable5_h;

    /* Saturate: '<S239>/Saturation' */
    if (c5 > 50.0F) {
      /* Saturate: '<S239>/Saturation' */
      c5 = 50.0F;
    } else {
      if (c5 < 4.0F) {
        /* Saturate: '<S239>/Saturation' */
        c5 = 4.0F;
      }
    }

    /* End of Saturate: '<S239>/Saturation' */

    /* Gain: '<S234>/Gain' */
    rtb_ACC_t_FTCDsrdDistLv1_sg = -rtb_ARB_F_PCTWhlDrvnToq_sg;

    /* MultiPortSwitch: '<S234>/Multiport Switch' */
    switch (m_TRP_Replan_Level_Dis) {
     case RPL_Disable:
      /* Switch: '<S176>/Switch' incorporates:
       *  Constant: '<S234>/Constant3'
       *  MultiPortSwitch: '<S234>/Multiport Switch'
       */
      app_DW.UnitDelay_DSTATE_i5 = 0.0F;
      app_DW.UnitDelay1_DSTATE_c = 0.0F;

      /* MultiPortSwitch: '<S234>/Multiport Switch' incorporates:
       *  Constant: '<S234>/Constant3'
       */
      rtb_t_min = 0.0F;
      break;

     case RPL_Init:
      /* Switch: '<S176>/Switch' incorporates:
       *  DataTypeConversion: '<S1060>/Data Type Conversion7'
       *  Delay: '<S176>/Resettable Delay'
       *  MultiPortSwitch: '<S234>/Multiport Switch'
       *  UnitDelay: '<S1060>/spdD3'
       */
      app_DW.UnitDelay_DSTATE_i5 = app_DW.ResettableDelay_DSTATE_d;
      app_DW.UnitDelay1_DSTATE_c = (real32_T)app_DW.spdD3_DSTATE;

      /* MultiPortSwitch: '<S234>/Multiport Switch' incorporates:
       *  DataTypeConversion: '<S1023>/Data Type Conversion30'
       */
      rtb_t_min = rtb_Gain5_i;
      break;

     case RPL_RePlan:
      /* Switch: '<S176>/Switch' incorporates:
       *  DataTypeConversion: '<S1060>/Data Type Conversion7'
       *  Delay: '<S176>/Resettable Delay'
       *  MultiPortSwitch: '<S234>/Multiport Switch'
       *  UnitDelay: '<S1060>/spdD3'
       */
      app_DW.UnitDelay_DSTATE_i5 = app_DW.ResettableDelay_DSTATE_d;
      app_DW.UnitDelay1_DSTATE_c = (real32_T)app_DW.spdD3_DSTATE;

      /* MultiPortSwitch: '<S234>/Multiport Switch' incorporates:
       *  UnitDelay: '<S137>/Unit Delay2'
       */
      rtb_t_min = app_DW.UnitDelay2_DSTATE_b;
      break;
     default: break;
    }

    /* End of MultiPortSwitch: '<S234>/Multiport Switch' */

    /* Sum: '<S234>/Minus' incorporates:
     *  Inport: '<Root>/Obj_01_v'
     *  UnitDelay generated from: '<S140>/Unit Delay4'
     */
    rtb_uDLookupTable5_h = app_DW.UnitDelay1_DSTATE_c - arg_Obj_01_v;

    /* Logic: '<S238>/OR' */
    rtb_OR_f = (rtb_LogicalOperator9_kf || rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m ||
                rtb_OR_f);

    /* Chart: '<S140>/TRP_Scheduling' */
    if (m_TRP_Replan_Level_Dis == RPL_Disable) {
      /* Outputs for Function Call SubSystem: '<S140>/Longt_Dist_Keep1' */
      /* Merge: '<S241>/Merge4' incorporates:
       *  Constant: '<S236>/Constant2'
       *  SignalConversion generated from: '<S236>/t_None'
       */
      app_DW.UnitDelay4_7_DSTATE = 0.0F;

      /* Merge: '<S241>/Merge6' incorporates:
       *  Constant: '<S236>/Constant8'
       *  SignalConversion generated from: '<S236>/s_trajNone_real_dis'
       */
      c5 = 0.0F;

      /* Merge: '<S241>/Merge7' incorporates:
       *  Constant: '<S236>/Constant9'
       *  SignalConversion generated from: '<S236>/v_trajNone_real_dis'
       */
      t_Ax_Extrem1 = 0.0F;

      /* Merge: '<S241>/Merge8' incorporates:
       *  Constant: '<S236>/Constant10'
       *  SignalConversion generated from: '<S236>/a_trajNone_real_dis'
       */
      t_Ax_Extrem2 = 0.0F;

      /* Merge: '<S241>/Merge12' incorporates:
       *  Constant: '<S236>/Constant14'
       *  SignalConversion generated from: '<S236>/a_trajNone_real_dis_prdtOneStp'
       */
      Jerk_Extrem = 0.0F;

      /* End of Outputs for SubSystem: '<S140>/Longt_Dist_Keep1' */
    } else if ((m_TRP_Replan_Level_Dis == RPL_Init) || (m_TRP_Replan_Level_Dis ==
                RPL_RePlan) || (m_TRP_Replan_Level_Dis == RPL_Normal)) {
      /* Outputs for Function Call SubSystem: '<S140>/Longt_Dist_RePlan' */
      /* Product: '<S245>/Divide' incorporates:
       *  Constant: '<S245>/Constant'
       *  Sum: '<S245>/Add'
       */
      rtb_Gain1_pv = (Ax_Extrem2_j - c5) / 5.0F;

      /* MATLAB Function: '<S245>/MATLAB Function' */
      for (i_0 = 0; i_0 < 6; i_0++) {
        rtb_Reshape[i_0] = (((real32_T)i_0 + 1.0F) - 1.0F) * rtb_Gain1_pv + c5;
      }

      /* End of MATLAB Function: '<S245>/MATLAB Function' */

      /* MATLAB Function: '<S389>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[5], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &app_B.c5_traj,
                           &app_B.c4_traj, &app_B.c3_traj);

      /* MATLAB Function: '<S393>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(app_B.c5_traj, app_B.c4_traj, app_B.c3_traj,
                            rtb_Reshape[5], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &c5, &t_Ax_Extrem1,
                            &t_Ax_Extrem2, &t_Jerk_Extrem, &Ax_Extrem1,
                            &Ax_Extrem2);

      /* Switch: '<S391>/Switch' incorporates:
       *  Constant: '<S398>/Constant'
       *  Gain: '<S391>/Gain2'
       *  RelationalOperator: '<S398>/Compare'
       *  Sum: '<S391>/Add2'
       */
      app_B.Collision_b = (-c5 + c4 < 0.0F);

      /* Switch: '<S391>/Switch1' */
      app_B.Traj_Valid = !app_B.Collision_b;

      /* Logic: '<S388>/OR' incorporates:
       *  RelationalOperator: '<S388>/Equal'
       *  RelationalOperator: '<S388>/Equal1'
       */
      rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m = (app_B.Collision_b ||
        (!app_B.Traj_Valid));

      /* MATLAB Function: '<S371>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[4], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &t_Ax_Extrem1,
                           &t_Ax_Extrem2, &t_Ax_Extrem1_j);

      /* MATLAB Function: '<S375>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(t_Ax_Extrem1, t_Ax_Extrem2, t_Ax_Extrem1_j,
                            rtb_Reshape[4], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &app_B.Ax_Extrem1_bf,
                            &t_Jerk_Extrem, &Ax_Extrem1, &Ax_Extrem2,
                            &Jerk_Extrem, &ax_Max_Traj);

      /* Switch: '<S373>/Switch' incorporates:
       *  Constant: '<S380>/Constant'
       *  Gain: '<S373>/Gain2'
       *  RelationalOperator: '<S380>/Compare'
       *  Sum: '<S373>/Add2'
       */
      rtb_LogicalOperator3_n0p = (-app_B.Ax_Extrem1_bf + c4 < 0.0F);

      /* Switch: '<S373>/Switch1' */
      rtb_RelationalOperator7_oa = !rtb_LogicalOperator3_n0p;

      /* Logic: '<S370>/OR' incorporates:
       *  RelationalOperator: '<S370>/Equal'
       *  RelationalOperator: '<S370>/Equal1'
       */
      rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d = (rtb_LogicalOperator3_n0p ||
        (!rtb_RelationalOperator7_oa));

      /* MATLAB Function: '<S353>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[3], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &Ax_Extrem1, &Ax_Extrem2,
                           &t_Ax_Extrem2_l);

      /* MATLAB Function: '<S357>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(Ax_Extrem1, Ax_Extrem2, t_Ax_Extrem2_l, rtb_Reshape
                            [3], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &t_Jerk_Extrem,
                            &Jerk_Extrem, &ax_Max_Traj, &rtb_Product1_j2z,
                            &rtb_Product2_jd, &rtb_KTt_a);

      /* Switch: '<S355>/Switch' incorporates:
       *  Constant: '<S362>/Constant'
       *  Gain: '<S355>/Gain2'
       *  RelationalOperator: '<S362>/Compare'
       *  Sum: '<S355>/Add2'
       */
      rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o = (-t_Jerk_Extrem + c4 < 0.0F);

      /* Switch: '<S355>/Switch1' */
      rtb_LogicalOperator2_hs = !rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o;

      /* Logic: '<S352>/OR' incorporates:
       *  RelationalOperator: '<S352>/Equal'
       *  RelationalOperator: '<S352>/Equal1'
       */
      rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f = (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o
        || (!rtb_LogicalOperator2_hs));

      /* MATLAB Function: '<S335>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[2], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &ax_Max_Traj,
                           &rtb_Product1_j2z, &rtb_Min_h);

      /* MATLAB Function: '<S339>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(ax_Max_Traj, rtb_Product1_j2z, rtb_Min_h,
                            rtb_Reshape[2], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &Jerk_Extrem,
                            &rtb_Product2_jd, &rtb_KTt_a, &rtb_Product4_dp,
                            &rtb_KTt_h, &rtb_K_OsV_Os_c);

      /* Switch: '<S337>/Switch' incorporates:
       *  Constant: '<S344>/Constant'
       *  Gain: '<S337>/Gain2'
       *  RelationalOperator: '<S344>/Compare'
       *  Sum: '<S337>/Add2'
       */
      rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl = (-Jerk_Extrem + c4 < 0.0F);

      /* Switch: '<S337>/Switch1' */
      rtb_LogicalOperator9_o = !rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;

      /* Logic: '<S334>/OR' incorporates:
       *  RelationalOperator: '<S334>/Equal'
       *  RelationalOperator: '<S334>/Equal1'
       */
      rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p = (rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl ||
        (!rtb_LogicalOperator9_o));

      /* MATLAB Function: '<S281>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[1], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Product2_jd,
                           &rtb_KTt_a, &rtb_Product4_j);

      /* MATLAB Function: '<S285>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(rtb_Product2_jd, rtb_KTt_a, rtb_Product4_j,
                            rtb_Reshape[1], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &t_Ax_Extrem1_k,
                            &rtb_Product4_dp, &rtb_KTt_h, &rtb_K_OsV_Os_c,
                            &rtb_Product4_aq, &rtb_Product4_lc);

      /* Switch: '<S283>/Switch' incorporates:
       *  Constant: '<S290>/Constant'
       *  Gain: '<S283>/Gain2'
       *  RelationalOperator: '<S290>/Compare'
       *  Sum: '<S283>/Add2'
       */
      rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = (-t_Ax_Extrem1_k + c4 < 0.0F);

      /* Switch: '<S283>/Switch1' */
      rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = !rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;

      /* Logic: '<S280>/OR' incorporates:
       *  RelationalOperator: '<S280>/Equal'
       *  RelationalOperator: '<S280>/Equal1'
       */
      rtb_DFIn_is_CCFM_BntStsDsbl_bl_l = (rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f
        || (!rtb_DFIn_is_CCFM_TCSStsFlt_bl_d));

      /* MATLAB Function: '<S263>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_f(rtb_Reshape[0], rtb_t_min, rtb_uDLookupTable5_h,
                           rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_KTt_h,
                           &rtb_K_OsV_Os_c, &rtb_Switch_ddv);

      /* MATLAB Function: '<S267>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gv(rtb_KTt_h, rtb_K_OsV_Os_c, rtb_Switch_ddv,
                            rtb_Reshape[0], rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Product4_dp,
                            &rtb_Product4_aq, &rtb_Product4_lc, &rtb_Product1_ei,
                            &rtb_Product2_hzb, &rtb_Gain1_bg);

      /* Switch: '<S265>/Switch' incorporates:
       *  Constant: '<S272>/Constant'
       *  Gain: '<S265>/Gain2'
       *  RelationalOperator: '<S272>/Compare'
       *  Sum: '<S265>/Add2'
       */
      rtb_DFIn_is_CCFM_VSEStsFlt_bl_d = (-rtb_Product4_dp + c4 < 0.0F);

      /* Switch: '<S265>/Switch1' */
      rtb_LogicalOperator2_fg = !rtb_DFIn_is_CCFM_VSEStsFlt_bl_d;

      /* Logic: '<S262>/OR' incorporates:
       *  RelationalOperator: '<S262>/Equal'
       *  RelationalOperator: '<S262>/Equal1'
       */
      rtb_LogicalOperator1_pr = (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d ||
        (!rtb_LogicalOperator2_fg));

      /* MATLAB Function: '<S261>/MATLAB Function' */
      app_MATLABFunction(rtb_KTt_h, rtb_K_OsV_Os_c, rtb_Switch_ddv, rtb_Reshape
                         [0], rtb_t_min, &rtb_Product4_aq, &rtb_Product4_lc,
                         &rtb_Product1_ei, &rtb_Product2_hzb, &rtb_Gain1_bg,
                         &rtb_Divide4_h1);

      /* Sum: '<S265>/Add1' incorporates:
       *  Constant: '<S265>/Constant2'
       *  Constant: '<S265>/Constant3'
       *  MinMax: '<S265>/Max2'
       *  MinMax: '<S265>/Max3'
       *  Sum: '<S265>/Subtract2'
       *  Sum: '<S265>/Subtract3'
       */
      rtb_Product4_p = fmaxf(rtb_Add_g0 - rtb_Product4_lc, 0.0F) + fmaxf
        (rtb_Product4_aq - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S264>/MATLAB Function' */
      app_MATLABFunction_g(rtb_KTt_h, rtb_K_OsV_Os_c, rtb_Switch_ddv,
                           rtb_Reshape[0], &Ax_Extrem2_f, &rtb_Gain9_kp,
                           &rtb_Product4_lc, &rtb_Product4_aq);

      /* MinMax: '<S265>/Max' incorporates:
       *  Constant: '<S265>/Constant'
       *  Sum: '<S265>/Subtract'
       */
      rtb_KTt_af = fmaxf(j_traj_real_Spd - rtb_Gain9_kp, 0.0F);

      /* MATLAB Function: '<S268>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(rtb_KTt_h, rtb_K_OsV_Os_c, rtb_Switch_ddv,
                           rtb_Reshape[0], rtb_t_min, rtb_uDLookupTable5_h,
                           &rtb_Gain9_kp, &rtb_K_OsV_Os_l, &Ax_Extrem1_n,
                           &t_Ax_Extrem1_e, &t_Ax_Extrem2_g);

      /* Sum: '<S265>/Add4' incorporates:
       *  Constant: '<S265>/Constant1'
       *  Constant: '<S265>/Constant5'
       *  Gain: '<S265>/Gain1'
       *  MinMax: '<S265>/Max1'
       *  MinMax: '<S265>/Max5'
       *  Product: '<S265>/Product'
       *  Product: '<S265>/Product2'
       *  Sum: '<S265>/Add'
       *  Sum: '<S265>/Subtract1'
       *  Sum: '<S265>/Subtract5'
       */
      t_Ax_Extrem1_e = (((fmaxf(Ax_Extrem2_f - LimitationViolate, 0.0F) +
                          rtb_KTt_af) + rtb_Product4_p) + rtb_Gain9_kp) + fmaxf(
        -c3 + rtb_Product4_dp, 0.0F);

      /* MATLAB Function: '<S266>/MATLAB Function' */
      app_MATLABFunction_p(rtb_KTt_h, rtb_K_OsV_Os_c, rtb_Switch_ddv,
                           rtb_Reshape[0], &Ax_Extrem2_f);

      /* RelationalOperator: '<S262>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Constant: '<S246>/Constant14'
       *  Constant: '<S246>/Constant18'
       *  Constant: '<S246>/Constant19'
       *  Product: '<S262>/Product'
       *  Product: '<S262>/Product1'
       *  Product: '<S262>/Product2'
       *  Product: '<S262>/Product3'
       *  Product: '<S262>/Product4'
       *  Product: '<S262>/Product5'
       *  Sum: '<S262>/Add'
       *  Sum: '<S262>/Add1'
       */
      rtb_LogicalOperator3_d = ((1.0E+6F * k_TRPLon_cof_TrajLimVlatnWght_sg +
        1.0E+6F * k_TRPLon_cof_TrajJerkWght_sg) + 0.0F * Opt < (t_Ax_Extrem1_e *
        k_TRPLon_cof_TrajLimVlatnWght_sg + Ax_Extrem2_f *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[0] * Opt);

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant14'
       *  Constant: '<S246>/Constant18'
       *  Constant: '<S246>/Constant19'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_K_OsV_Os_bx = 0.0F;
        t_Ax_Extrem1_e = 1.0E+6F;
        Ax_Extrem2_f = 1.0E+6F;
      } else if (rtb_LogicalOperator3_d) {
        /* Switch generated from: '<S262>/Switch1' incorporates:
         *  Constant: '<S246>/Constant14'
         */
        rtb_K_OsV_Os_bx = 0.0F;

        /* Switch generated from: '<S262>/Switch1' incorporates:
         *  Constant: '<S246>/Constant19'
         */
        t_Ax_Extrem1_e = 1.0E+6F;

        /* Switch generated from: '<S262>/Switch1' incorporates:
         *  Constant: '<S246>/Constant18'
         */
        Ax_Extrem2_f = 1.0E+6F;
      } else {
        rtb_K_OsV_Os_bx = rtb_Reshape[0];
      }

      /* MATLAB Function: '<S279>/MATLAB Function' */
      app_MATLABFunction(rtb_Product2_jd, rtb_KTt_a, rtb_Product4_j,
                         rtb_Reshape[1], rtb_t_min, &rtb_Product4_p, &rtb_KTt_af,
                         &rtb_K_OsV_Os_l, &Ax_Extrem1_n, &rtb_Product4_dp,
                         &rtb_Gain9_kp);

      /* Sum: '<S283>/Add1' incorporates:
       *  Constant: '<S283>/Constant2'
       *  Constant: '<S283>/Constant3'
       *  MinMax: '<S283>/Max2'
       *  MinMax: '<S283>/Max3'
       *  Sum: '<S283>/Subtract2'
       *  Sum: '<S283>/Subtract3'
       */
      t_Ax_Extrem2_g = fmaxf(rtb_Add_g0 - rtb_KTt_af, 0.0F) + fmaxf
        (rtb_Product4_p - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S282>/MATLAB Function' */
      app_MATLABFunction_g(rtb_Product2_jd, rtb_KTt_a, rtb_Product4_j,
                           rtb_Reshape[1], &rtb_Add2_l, &rtb_K_OsV_Os_b,
                           &rtb_KTt_af, &rtb_Product4_p);

      /* MinMax: '<S283>/Max' incorporates:
       *  Constant: '<S283>/Constant'
       *  Sum: '<S283>/Subtract'
       */
      rtb_Min_p = fmaxf(j_traj_real_Spd - rtb_K_OsV_Os_b, 0.0F);

      /* MATLAB Function: '<S286>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(rtb_Product2_jd, rtb_KTt_a, rtb_Product4_j,
                           rtb_Reshape[1], rtb_t_min, rtb_uDLookupTable5_h,
                           &rtb_K_OsV_Os_b, &rtb_Product4_k0, &rtb_Switch_ki,
                           &rtb_Gain1_jl, &rtb_Product1_da);

      /* Sum: '<S283>/Add4' incorporates:
       *  Constant: '<S283>/Constant1'
       *  Constant: '<S283>/Constant5'
       *  Gain: '<S283>/Gain1'
       *  MinMax: '<S283>/Max1'
       *  MinMax: '<S283>/Max5'
       *  Product: '<S283>/Product'
       *  Product: '<S283>/Product2'
       *  Sum: '<S283>/Add'
       *  Sum: '<S283>/Subtract1'
       *  Sum: '<S283>/Subtract5'
       */
      rtb_Product1_da = (((fmaxf(rtb_Add2_l - LimitationViolate, 0.0F) +
                           rtb_Min_p) + t_Ax_Extrem2_g) + rtb_K_OsV_Os_b) +
        fmaxf(-c3 + t_Ax_Extrem1_k, 0.0F);

      /* MATLAB Function: '<S284>/MATLAB Function' */
      app_MATLABFunction_p(rtb_Product2_jd, rtb_KTt_a, rtb_Product4_j,
                           rtb_Reshape[1], &rtb_Add2_l);

      /* RelationalOperator: '<S280>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S280>/Product'
       *  Product: '<S280>/Product1'
       *  Product: '<S280>/Product2'
       *  Product: '<S280>/Product3'
       *  Product: '<S280>/Product4'
       *  Product: '<S280>/Product5'
       *  Sum: '<S280>/Add'
       *  Sum: '<S280>/Add1'
       */
      rtb_LogicalOperator4_jt = ((t_Ax_Extrem1_e *
        k_TRPLon_cof_TrajLimVlatnWght_sg + Ax_Extrem2_f *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt < (rtb_Product1_da
        * k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Add2_l *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[1] * Opt);

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Product1_da = t_Ax_Extrem1_e;
        rtb_Add2_l = Ax_Extrem2_f;
      } else if (rtb_LogicalOperator4_jt) {
        /* Switch generated from: '<S280>/Switch1' */
        rtb_Product1_da = t_Ax_Extrem1_e;

        /* Switch generated from: '<S280>/Switch1' */
        rtb_Add2_l = Ax_Extrem2_f;
      } else {
        rtb_K_OsV_Os_bx = rtb_Reshape[1];
      }

      /* MATLAB Function: '<S333>/MATLAB Function' */
      app_MATLABFunction(ax_Max_Traj, rtb_Product1_j2z, rtb_Min_h, rtb_Reshape[2],
                         rtb_t_min, &Ax_Extrem2_f, &t_Ax_Extrem1_e,
                         &t_Ax_Extrem2_g, &rtb_Min_p, &rtb_Product4_k0,
                         &rtb_Switch_ki);

      /* Sum: '<S337>/Add1' incorporates:
       *  Constant: '<S337>/Constant2'
       *  Constant: '<S337>/Constant3'
       *  MinMax: '<S337>/Max2'
       *  MinMax: '<S337>/Max3'
       *  Sum: '<S337>/Subtract2'
       *  Sum: '<S337>/Subtract3'
       */
      rtb_Product2_jb = fmaxf(rtb_Add_g0 - t_Ax_Extrem1_e, 0.0F) + fmaxf
        (Ax_Extrem2_f - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S336>/MATLAB Function' */
      app_MATLABFunction_g(ax_Max_Traj, rtb_Product1_j2z, rtb_Min_h,
                           rtb_Reshape[2], &rtb_Gain9_e, &rtb_Gain1_jl,
                           &t_Ax_Extrem1_e, &Ax_Extrem2_f);

      /* MinMax: '<S337>/Max' incorporates:
       *  Constant: '<S337>/Constant'
       *  Sum: '<S337>/Subtract'
       */
      rtb_Gain1_az = fmaxf(j_traj_real_Spd - rtb_Gain1_jl, 0.0F);

      /* MATLAB Function: '<S340>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(ax_Max_Traj, rtb_Product1_j2z, rtb_Min_h,
                           rtb_Reshape[2], rtb_t_min, rtb_uDLookupTable5_h,
                           &rtb_Gain1_jl, &rtb_Divide4_b0, &rtb_Product4_no,
                           &rtb_KTt_m0, &rtb_Product1_hd);

      /* Sum: '<S337>/Add4' incorporates:
       *  Constant: '<S337>/Constant1'
       *  Constant: '<S337>/Constant5'
       *  Gain: '<S337>/Gain1'
       *  MinMax: '<S337>/Max1'
       *  MinMax: '<S337>/Max5'
       *  Product: '<S337>/Product'
       *  Product: '<S337>/Product2'
       *  Sum: '<S337>/Add'
       *  Sum: '<S337>/Subtract1'
       *  Sum: '<S337>/Subtract5'
       */
      rtb_Product4_no = (((fmaxf(rtb_Gain9_e - LimitationViolate, 0.0F) +
                           rtb_Gain1_az) + rtb_Product2_jb) + rtb_Gain1_jl) +
        fmaxf(-c3 + Jerk_Extrem, 0.0F);

      /* MATLAB Function: '<S338>/MATLAB Function' */
      app_MATLABFunction_p(ax_Max_Traj, rtb_Product1_j2z, rtb_Min_h,
                           rtb_Reshape[2], &rtb_Gain9_e);

      /* RelationalOperator: '<S334>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S334>/Product'
       *  Product: '<S334>/Product1'
       *  Product: '<S334>/Product2'
       *  Product: '<S334>/Product3'
       *  Product: '<S334>/Product4'
       *  Product: '<S334>/Product5'
       *  Sum: '<S334>/Add'
       *  Sum: '<S334>/Add1'
       */
      rtb_LogicalOperator5_m = ((rtb_Product1_da *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Add2_l *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt < (rtb_Product4_no
        * k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Gain9_e *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[2] * Opt);

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Product4_no = rtb_Product1_da;
        rtb_Gain9_e = rtb_Add2_l;
      } else if (rtb_LogicalOperator5_m) {
        /* Switch generated from: '<S334>/Switch1' */
        rtb_Product4_no = rtb_Product1_da;

        /* Switch generated from: '<S334>/Switch1' */
        rtb_Gain9_e = rtb_Add2_l;
      } else {
        rtb_K_OsV_Os_bx = rtb_Reshape[2];
      }

      /* MATLAB Function: '<S351>/MATLAB Function' */
      app_MATLABFunction(Ax_Extrem1, Ax_Extrem2, t_Ax_Extrem2_l, rtb_Reshape[3],
                         rtb_t_min, &rtb_Add2_l, &rtb_Product1_da,
                         &rtb_Product2_jb, &rtb_Gain1_az, &Jerk_Extrem,
                         &rtb_Gain1_jl);

      /* Sum: '<S355>/Add1' incorporates:
       *  Constant: '<S355>/Constant2'
       *  Constant: '<S355>/Constant3'
       *  MinMax: '<S355>/Max2'
       *  MinMax: '<S355>/Max3'
       *  Sum: '<S355>/Subtract2'
       *  Sum: '<S355>/Subtract3'
       */
      rtb_KTt_m0 = fmaxf(rtb_Add_g0 - rtb_Product1_da, 0.0F) + fmaxf(rtb_Add2_l
        - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S354>/MATLAB Function' */
      app_MATLABFunction_g(Ax_Extrem1, Ax_Extrem2, t_Ax_Extrem2_l, rtb_Reshape[3],
                           &Ax_Extrem1_b, &rtb_Divide4_b0, &rtb_Product1_da,
                           &rtb_Add2_l);

      /* MinMax: '<S355>/Max' incorporates:
       *  Constant: '<S355>/Constant'
       *  Sum: '<S355>/Subtract'
       */
      rtb_Product1_hd = fmaxf(j_traj_real_Spd - rtb_Divide4_b0, 0.0F);

      /* MATLAB Function: '<S358>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(Ax_Extrem1, Ax_Extrem2, t_Ax_Extrem2_l, rtb_Reshape[3],
                           rtb_t_min, rtb_uDLookupTable5_h, &rtb_Divide4_b0,
                           &rtb_Add2_fb, &rtb_Product1_n3, &rtb_Product2_pl1,
                           &rtb_Divide4_b);

      /* Sum: '<S355>/Add4' incorporates:
       *  Constant: '<S355>/Constant1'
       *  Constant: '<S355>/Constant5'
       *  Gain: '<S355>/Gain1'
       *  MinMax: '<S355>/Max1'
       *  MinMax: '<S355>/Max5'
       *  Product: '<S355>/Product'
       *  Product: '<S355>/Product2'
       *  Sum: '<S355>/Add'
       *  Sum: '<S355>/Subtract1'
       *  Sum: '<S355>/Subtract5'
       */
      rtb_Product2_pl1 = (((fmaxf(Ax_Extrem1_b - LimitationViolate, 0.0F) +
                            rtb_Product1_hd) + rtb_KTt_m0) + rtb_Divide4_b0) +
        fmaxf(-c3 + t_Jerk_Extrem, 0.0F);

      /* MATLAB Function: '<S356>/MATLAB Function' */
      app_MATLABFunction_p(Ax_Extrem1, Ax_Extrem2, t_Ax_Extrem2_l, rtb_Reshape[3],
                           &Ax_Extrem1_b);

      /* RelationalOperator: '<S352>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S352>/Product'
       *  Product: '<S352>/Product1'
       *  Product: '<S352>/Product2'
       *  Product: '<S352>/Product3'
       *  Product: '<S352>/Product4'
       *  Product: '<S352>/Product5'
       *  Sum: '<S352>/Add'
       *  Sum: '<S352>/Add1'
       */
      rtb_LogicalOperator10_mo = ((rtb_Product4_no *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Gain9_e *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt <
        (rtb_Product2_pl1 * k_TRPLon_cof_TrajLimVlatnWght_sg + Ax_Extrem1_b *
         k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[3] * Opt);

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Product2_pl1 = rtb_Product4_no;
        Ax_Extrem1_b = rtb_Gain9_e;
      } else if (rtb_LogicalOperator10_mo) {
        /* Switch generated from: '<S352>/Switch1' */
        rtb_Product2_pl1 = rtb_Product4_no;

        /* Switch generated from: '<S352>/Switch1' */
        Ax_Extrem1_b = rtb_Gain9_e;
      } else {
        rtb_K_OsV_Os_bx = rtb_Reshape[3];
      }

      /* MATLAB Function: '<S369>/MATLAB Function' */
      app_MATLABFunction(t_Ax_Extrem1, t_Ax_Extrem2, t_Ax_Extrem1_j,
                         rtb_Reshape[4], rtb_t_min, &rtb_Gain9_e,
                         &rtb_Product4_no, &rtb_KTt_m0, &rtb_Product1_hd,
                         &t_Jerk_Extrem, &rtb_Divide4_b0);

      /* Sum: '<S373>/Add1' incorporates:
       *  Constant: '<S373>/Constant2'
       *  Constant: '<S373>/Constant3'
       *  MinMax: '<S373>/Max2'
       *  MinMax: '<S373>/Max3'
       *  Sum: '<S373>/Subtract2'
       *  Sum: '<S373>/Subtract3'
       */
      rtb_Product1_n3 = fmaxf(rtb_Add_g0 - rtb_Product4_no, 0.0F) + fmaxf
        (rtb_Gain9_e - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S372>/MATLAB Function' */
      app_MATLABFunction_g(t_Ax_Extrem1, t_Ax_Extrem2, t_Ax_Extrem1_j,
                           rtb_Reshape[4], &rtb_Add2_fb, &app_B.Ax_Extrem2_f0,
                           &rtb_Product4_no, &rtb_Gain9_e);

      /* MinMax: '<S373>/Max' incorporates:
       *  Constant: '<S373>/Constant'
       *  Sum: '<S373>/Subtract'
       */
      rtb_Divide4_b = fmaxf(j_traj_real_Spd - app_B.Ax_Extrem2_f0, 0.0F);

      /* MATLAB Function: '<S376>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(t_Ax_Extrem1, t_Ax_Extrem2, t_Ax_Extrem1_j,
                           rtb_Reshape[4], rtb_t_min, rtb_uDLookupTable5_h,
                           &app_B.Ax_Extrem2_f0, &rtb_Gain9_b, &rtb_Product4_e5,
                           &rtb_KTt_b, &rtb_K_OsV_Os_au);

      /* Sum: '<S373>/Add4' incorporates:
       *  Constant: '<S373>/Constant1'
       *  Constant: '<S373>/Constant5'
       *  Gain: '<S373>/Gain1'
       *  MinMax: '<S373>/Max1'
       *  MinMax: '<S373>/Max5'
       *  Product: '<S373>/Product'
       *  Product: '<S373>/Product2'
       *  Sum: '<S373>/Add'
       *  Sum: '<S373>/Subtract1'
       *  Sum: '<S373>/Subtract5'
       */
      rtb_Product1_n3 = (((fmaxf(rtb_Add2_fb - LimitationViolate, 0.0F) +
                           rtb_Divide4_b) + rtb_Product1_n3) +
                         app_B.Ax_Extrem2_f0) + fmaxf(-c3 + app_B.Ax_Extrem1_bf,
        0.0F);

      /* MATLAB Function: '<S374>/MATLAB Function' */
      app_MATLABFunction_p(t_Ax_Extrem1, t_Ax_Extrem2, t_Ax_Extrem1_j,
                           rtb_Reshape[4], &rtb_Add2_fb);

      /* RelationalOperator: '<S370>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S370>/Product'
       *  Product: '<S370>/Product1'
       *  Product: '<S370>/Product2'
       *  Product: '<S370>/Product3'
       *  Product: '<S370>/Product4'
       *  Product: '<S370>/Product5'
       *  Sum: '<S370>/Add'
       *  Sum: '<S370>/Add1'
       */
      rtb_LogicalOperator2_e5 = ((rtb_Product2_pl1 *
        k_TRPLon_cof_TrajLimVlatnWght_sg + Ax_Extrem1_b *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt < (rtb_Product1_n3
        * k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Add2_fb *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[4] * Opt);

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Product1_n3 = rtb_Product2_pl1;
        rtb_Add2_fb = Ax_Extrem1_b;
      } else if (rtb_LogicalOperator2_e5) {
        /* Switch generated from: '<S370>/Switch1' */
        rtb_Product1_n3 = rtb_Product2_pl1;

        /* Switch generated from: '<S370>/Switch1' */
        rtb_Add2_fb = Ax_Extrem1_b;
      } else {
        rtb_K_OsV_Os_bx = rtb_Reshape[4];
      }

      /* MATLAB Function: '<S387>/MATLAB Function' */
      app_MATLABFunction(app_B.c5_traj, app_B.c4_traj, app_B.c3_traj,
                         rtb_Reshape[5], rtb_t_min, &app_B.Jerk_Extrem_o,
                         &app_B.t_Jerk_Extrem_n, &app_B.t_Ax_Extrem1_l,
                         &app_B.t_Ax_Extrem2_cz, &app_B.Ax_Extrem1_bf,
                         &app_B.Ax_Extrem2_f0);

      /* Sum: '<S391>/Add1' incorporates:
       *  Constant: '<S391>/Constant2'
       *  Constant: '<S391>/Constant3'
       *  MinMax: '<S391>/Max2'
       *  MinMax: '<S391>/Max3'
       *  Sum: '<S391>/Subtract2'
       *  Sum: '<S391>/Subtract3'
       */
      rtb_Product2_pl1 = fmaxf(rtb_Add_g0 - app_B.t_Jerk_Extrem_n, 0.0F) + fmaxf
        (app_B.Jerk_Extrem_o - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S390>/MATLAB Function' */
      app_MATLABFunction_g(app_B.c5_traj, app_B.c4_traj, app_B.c3_traj,
                           rtb_Reshape[5], &t_Ax_Extrem1_k, &Ax_Extrem1_b,
                           &app_B.t_Jerk_Extrem_n, &app_B.Jerk_Extrem_o);

      /* MinMax: '<S391>/Max' incorporates:
       *  Constant: '<S391>/Constant'
       *  Sum: '<S391>/Subtract'
       */
      rtb_Divide4_b = fmaxf(j_traj_real_Spd - Ax_Extrem1_b, 0.0F);

      /* MATLAB Function: '<S394>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_m(app_B.c5_traj, app_B.c4_traj, app_B.c3_traj,
                           rtb_Reshape[5], rtb_t_min, rtb_uDLookupTable5_h,
                           &Ax_Extrem1_b, &rtb_Gain9_b, &rtb_Product4_e5,
                           &rtb_KTt_b, &rtb_K_OsV_Os_au);

      /* Sum: '<S391>/Add4' incorporates:
       *  Constant: '<S391>/Constant1'
       *  Constant: '<S391>/Constant5'
       *  Gain: '<S391>/Gain1'
       *  MinMax: '<S391>/Max1'
       *  MinMax: '<S391>/Max5'
       *  Product: '<S391>/Product'
       *  Product: '<S391>/Product2'
       *  Sum: '<S391>/Add'
       *  Sum: '<S391>/Subtract1'
       *  Sum: '<S391>/Subtract5'
       */
      rtb_K_OsV_Os_b = (((fmaxf(t_Ax_Extrem1_k - LimitationViolate, 0.0F) +
                          rtb_Divide4_b) + rtb_Product2_pl1) + Ax_Extrem1_b) +
        fmaxf(-c3 + c5, 0.0F);

      /* MATLAB Function: '<S392>/MATLAB Function' */
      app_MATLABFunction_p(app_B.c5_traj, app_B.c4_traj, app_B.c3_traj,
                           rtb_Reshape[5], &t_Ax_Extrem1_k);

      /* RelationalOperator: '<S388>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S388>/Product'
       *  Product: '<S388>/Product1'
       *  Product: '<S388>/Product2'
       *  Product: '<S388>/Product3'
       *  Product: '<S388>/Product4'
       *  Product: '<S388>/Product5'
       *  Sum: '<S388>/Add'
       *  Sum: '<S388>/Add1'
       */
      rtb_DFIn_is_CCFM_BntStsDsbl_bl_p = ((rtb_Product1_n3 *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Add2_fb *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt < (rtb_K_OsV_Os_b *
        k_TRPLon_cof_TrajLimVlatnWght_sg + t_Ax_Extrem1_k *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Reshape[5] * Opt);

      /* Switch generated from: '<S388>/Switch' */
      if ((!rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) &&
          (!rtb_DFIn_is_CCFM_BntStsDsbl_bl_p)) {
        /* Switch generated from: '<S388>/Switch1' */
        rtb_K_OsV_Os_bx = rtb_Reshape[5];
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant17'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_LogicalOperator2_fg = false;
      } else {
        rtb_LogicalOperator2_fg = ((!rtb_LogicalOperator3_d) &&
          rtb_LogicalOperator2_fg);
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = rtb_LogicalOperator2_fg;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = rtb_LogicalOperator2_fg;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_LogicalOperator9_o = rtb_DFIn_is_CCFM_TCSStsFlt_bl_d;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_LogicalOperator9_o = rtb_DFIn_is_CCFM_TCSStsFlt_bl_d;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_LogicalOperator2_hs = rtb_LogicalOperator9_o;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_LogicalOperator2_hs = rtb_LogicalOperator9_o;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_RelationalOperator7_oa = rtb_LogicalOperator2_hs;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_RelationalOperator7_oa = rtb_LogicalOperator2_hs;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        /* Switch: '<S391>/Switch1' */
        app_B.Traj_Valid = rtb_RelationalOperator7_oa;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S388>/Switch1'
           */
          app_B.Traj_Valid = rtb_RelationalOperator7_oa;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant16'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_RelationalOperator7_oa = true;
      } else {
        rtb_RelationalOperator7_oa = (rtb_LogicalOperator3_d ||
          rtb_DFIn_is_CCFM_VSEStsFlt_bl_d);
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = rtb_RelationalOperator7_oa;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = rtb_RelationalOperator7_oa;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl =
          rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl =
            rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o =
          rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o =
            rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_LogicalOperator3_n0p = rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_LogicalOperator3_n0p = rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        /* Switch: '<S391>/Switch' */
        app_B.Collision_b = rtb_LogicalOperator3_n0p;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S388>/Switch1'
           */
          app_B.Collision_b = rtb_LogicalOperator3_n0p;
        }
      }

      /* Switch: '<S259>/Switch' incorporates:
       *  Constant: '<S259>/Constant1'
       *  Constant: '<S259>/Constant5'
       *  Constant: '<S259>/Constant9'
       *  Logic: '<S259>/OR'
       *  RelationalOperator: '<S259>/Equal'
       *  RelationalOperator: '<S259>/Equal1'
       *  RelationalOperator: '<S259>/Equal2'
       *  Switch: '<S259>/Switch1'
       */
      if ((!app_B.Traj_Valid) || app_B.Collision_b) {
        rtb_LogicalOperator3_n0p = false;
        rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o = false;
      } else {
        rtb_LogicalOperator3_n0p = true;
        rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o = !(rtb_K_OsV_Os_bx ==
          Ax_Extrem2_j);
      }

      /* End of Switch: '<S259>/Switch' */

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant1'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Switch_ddv = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant1'
           */
          rtb_Switch_ddv = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Product4_j = rtb_Switch_ddv;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_Product4_j = rtb_Switch_ddv;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Min_h = rtb_Product4_j;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_Min_h = rtb_Product4_j;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        t_Ax_Extrem2_l = rtb_Min_h;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          t_Ax_Extrem2_l = rtb_Min_h;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        t_Ax_Extrem1_j = t_Ax_Extrem2_l;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          t_Ax_Extrem1_j = t_Ax_Extrem2_l;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.c3_traj = t_Ax_Extrem1_j;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.c3_traj = t_Ax_Extrem1_j;
        }
      }

      /* Gain: '<S259>/Gain' */
      Ax_Extrem2_j = 0.75F * rtb_Gain1_pv;

      /* Sum: '<S259>/Subtract' */
      rtb_Add2_o = rtb_K_OsV_Os_bx - Ax_Extrem2_j;

      /* MATLAB Function: '<S407>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(rtb_Add2_o, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &t_Ax_Extrem1_j,
                            &t_Ax_Extrem2_l, &t_Ax_Extrem2_a);

      /* MATLAB Function: '<S411>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(t_Ax_Extrem1_j, t_Ax_Extrem2_l, t_Ax_Extrem2_a,
                            rtb_Add2_o, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Min_h, &c5,
                            &Ax_Extrem1_b, &rtb_Product4_j, &rtb_Switch_ddv,
                            &rtb_Product2_pl1);

      /* Switch: '<S409>/Switch' incorporates:
       *  Constant: '<S416>/Constant'
       *  Gain: '<S409>/Gain2'
       *  RelationalOperator: '<S416>/Compare'
       *  Sum: '<S409>/Add2'
       */
      rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl = (-rtb_Min_h + c4 < 0.0F);

      /* Switch: '<S409>/Switch1' */
      rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f =
        !rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;

      /* Logic: '<S406>/OR' incorporates:
       *  RelationalOperator: '<S406>/Equal'
       *  RelationalOperator: '<S406>/Equal1'
       */
      rtb_RelationalOperator7_oa = (rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl ||
        (!rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f));

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        rtb_K_OsV_Os_b = rtb_Product1_n3;
        t_Ax_Extrem1_k = rtb_Add2_fb;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          rtb_K_OsV_Os_b = rtb_Product1_n3;

          /* Switch generated from: '<S388>/Switch1' */
          t_Ax_Extrem1_k = rtb_Add2_fb;
        }
      }

      /* MATLAB Function: '<S405>/MATLAB Function' */
      app_MATLABFunction_a(t_Ax_Extrem1_j, t_Ax_Extrem2_l, t_Ax_Extrem2_a,
                           rtb_Add2_o, rtb_t_min, &rtb_Product4_j,
                           &rtb_Switch_ddv, &rtb_Add2_fb, &rtb_Product1_n3, &c5,
                           &Ax_Extrem1_b);

      /* Sum: '<S409>/Add1' incorporates:
       *  Constant: '<S409>/Constant2'
       *  Constant: '<S409>/Constant3'
       *  MinMax: '<S409>/Max2'
       *  MinMax: '<S409>/Max3'
       *  Sum: '<S409>/Subtract2'
       *  Sum: '<S409>/Subtract3'
       */
      rtb_Divide4_b = fmaxf(rtb_Add_g0 - rtb_Switch_ddv, 0.0F) + fmaxf
        (rtb_Product4_j - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S408>/MATLAB Function' */
      app_MATLABFunction_k(t_Ax_Extrem1_j, t_Ax_Extrem2_l, t_Ax_Extrem2_a,
                           rtb_Add2_o, &rtb_Product1_a4, &rtb_Product2_pl1,
                           &rtb_Switch_ddv, &rtb_Product4_j);

      /* MinMax: '<S409>/Max' incorporates:
       *  Constant: '<S409>/Constant'
       *  Sum: '<S409>/Subtract'
       */
      rtb_Gain9_b = fmaxf(j_traj_real_Spd - rtb_Product2_pl1, 0.0F);

      /* MATLAB Function: '<S412>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(t_Ax_Extrem1_j, t_Ax_Extrem2_l, t_Ax_Extrem2_a,
                           rtb_Add2_o, rtb_t_min, rtb_uDLookupTable5_h,
                           &rtb_Product2_pl1, &rtb_Product4_e5, &rtb_KTt_b,
                           &rtb_K_OsV_Os_au, &rtb_Add1_fd);

      /* Sum: '<S409>/Add4' incorporates:
       *  Constant: '<S409>/Constant1'
       *  Constant: '<S409>/Constant5'
       *  Gain: '<S409>/Gain1'
       *  MinMax: '<S409>/Max1'
       *  MinMax: '<S409>/Max5'
       *  Product: '<S409>/Product'
       *  Product: '<S409>/Product2'
       *  Sum: '<S409>/Add'
       *  Sum: '<S409>/Subtract1'
       *  Sum: '<S409>/Subtract5'
       */
      rtb_Product2_mv = (((fmaxf(rtb_Product1_a4 - LimitationViolate, 0.0F) +
                           rtb_Gain9_b) + rtb_Divide4_b) + rtb_Product2_pl1) +
        fmaxf(-c3 + rtb_Min_h, 0.0F);

      /* MATLAB Function: '<S410>/MATLAB Function' */
      app_MATLABFunction_k0(t_Ax_Extrem1_j, t_Ax_Extrem2_l, t_Ax_Extrem2_a,
                            rtb_Add2_o, &rtb_Product1_a4);

      /* RelationalOperator: '<S406>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S406>/Product'
       *  Product: '<S406>/Product1'
       *  Product: '<S406>/Product2'
       *  Product: '<S406>/Product3'
       *  Product: '<S406>/Product4'
       *  Product: '<S406>/Product5'
       *  Sum: '<S406>/Add'
       *  Sum: '<S406>/Add1'
       */
      rtb_LogicalOperator2_hs = ((rtb_K_OsV_Os_b *
        k_TRPLon_cof_TrajLimVlatnWght_sg + t_Ax_Extrem1_k *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt < (rtb_Product2_mv
        * k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Product1_a4 *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Add2_o * Opt);

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        t_Ax_Extrem2_a = app_B.c3_traj;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          t_Ax_Extrem2_a = app_B.c3_traj;
        }
      }

      /* Gain: '<S259>/Gain1' */
      rtb_Switch_hv = 0.5F * rtb_Gain1_pv;

      /* Sum: '<S259>/Subtract1' */
      Ax_Extrem2_i = rtb_K_OsV_Os_bx - rtb_Switch_hv;

      /* MATLAB Function: '<S425>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(Ax_Extrem2_i, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Divide4_b,
                            &rtb_Gain9_b, &rtb_Product4_jc);

      /* MATLAB Function: '<S429>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(rtb_Divide4_b, rtb_Gain9_b, rtb_Product4_jc,
                            Ax_Extrem2_i, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Product4_e5,
                            &rtb_Min_h, &rtb_Product2_pl1, &rtb_KTt_b,
                            &rtb_K_OsV_Os_au, &rtb_Add1_fd);

      /* Switch: '<S427>/Switch' incorporates:
       *  Constant: '<S434>/Constant'
       *  Gain: '<S427>/Gain2'
       *  RelationalOperator: '<S434>/Compare'
       *  Sum: '<S427>/Add2'
       */
      rtb_LogicalOperator9_o = (-rtb_Product4_e5 + c4 < 0.0F);

      /* Switch: '<S427>/Switch1' */
      rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = !rtb_LogicalOperator9_o;

      /* Logic: '<S424>/OR' incorporates:
       *  RelationalOperator: '<S424>/Equal'
       *  RelationalOperator: '<S424>/Equal1'
       */
      rtb_DFIn_is_CCFM_VSEStsFlt_bl_d = (rtb_LogicalOperator9_o ||
        (!rtb_DFIn_is_CCFM_TCSStsFlt_bl_d));

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_Product2_mv = rtb_K_OsV_Os_b;
        rtb_Product1_a4 = t_Ax_Extrem1_k;
        rtb_Add2_o = rtb_K_OsV_Os_bx;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_Product2_mv = rtb_K_OsV_Os_b;

          /* Switch generated from: '<S406>/Switch1' */
          rtb_Product1_a4 = t_Ax_Extrem1_k;

          /* Switch generated from: '<S406>/Switch1' */
          rtb_Add2_o = rtb_K_OsV_Os_bx;
        }
      }

      /* MATLAB Function: '<S423>/MATLAB Function' */
      app_MATLABFunction_a(rtb_Divide4_b, rtb_Gain9_b, rtb_Product4_jc,
                           Ax_Extrem2_i, rtb_t_min, &rtb_KTt_b, &rtb_K_OsV_Os_au,
                           &rtb_Add1_fd, &Ax_Extrem1_ny, &rtb_Min_h,
                           &rtb_Product2_pl1);

      /* Sum: '<S427>/Add1' incorporates:
       *  Constant: '<S427>/Constant2'
       *  Constant: '<S427>/Constant3'
       *  MinMax: '<S427>/Max2'
       *  MinMax: '<S427>/Max3'
       *  Sum: '<S427>/Subtract2'
       *  Sum: '<S427>/Subtract3'
       */
      rtb_Min_l = fmaxf(rtb_Add_g0 - rtb_K_OsV_Os_au, 0.0F) + fmaxf(rtb_KTt_b -
        rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S426>/MATLAB Function' */
      app_MATLABFunction_k(rtb_Divide4_b, rtb_Gain9_b, rtb_Product4_jc,
                           Ax_Extrem2_i, &t_Ax_Extrem1_f, &Ax_Extrem2_e,
                           &rtb_K_OsV_Os_au, &rtb_KTt_b);

      /* MinMax: '<S427>/Max' incorporates:
       *  Constant: '<S427>/Constant'
       *  Sum: '<S427>/Subtract'
       */
      rtb_Product4_ge = fmaxf(j_traj_real_Spd - Ax_Extrem2_e, 0.0F);

      /* MATLAB Function: '<S430>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(rtb_Divide4_b, rtb_Gain9_b, rtb_Product4_jc,
                           Ax_Extrem2_i, rtb_t_min, rtb_uDLookupTable5_h,
                           &Ax_Extrem2_e, &rtb_Divide4_aa, &rtb_Gain9_m,
                           &Ax_Extrem1_o, &t_Ax_Extrem2_e);

      /* Sum: '<S427>/Add4' incorporates:
       *  Constant: '<S427>/Constant1'
       *  Constant: '<S427>/Constant5'
       *  Gain: '<S427>/Gain1'
       *  MinMax: '<S427>/Max1'
       *  MinMax: '<S427>/Max5'
       *  Product: '<S427>/Product'
       *  Product: '<S427>/Product2'
       *  Sum: '<S427>/Add'
       *  Sum: '<S427>/Subtract1'
       *  Sum: '<S427>/Subtract5'
       */
      t_Ax_Extrem2_e = (((fmaxf(t_Ax_Extrem1_f - LimitationViolate, 0.0F) +
                          rtb_Product4_ge) + rtb_Min_l) + Ax_Extrem2_e) + fmaxf(
        -c3 + rtb_Product4_e5, 0.0F);

      /* MATLAB Function: '<S428>/MATLAB Function' */
      app_MATLABFunction_k0(rtb_Divide4_b, rtb_Gain9_b, rtb_Product4_jc,
                            Ax_Extrem2_i, &t_Ax_Extrem1_f);

      /* RelationalOperator: '<S424>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S424>/Product'
       *  Product: '<S424>/Product1'
       *  Product: '<S424>/Product2'
       *  Product: '<S424>/Product3'
       *  Product: '<S424>/Product4'
       *  Product: '<S424>/Product5'
       *  Sum: '<S424>/Add'
       *  Sum: '<S424>/Add1'
       */
      rtb_LogicalOperator2_fg = ((rtb_Product2_mv *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Product1_a4 *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Add2_o * Opt < (t_Ax_Extrem2_e *
        k_TRPLon_cof_TrajLimVlatnWght_sg + t_Ax_Extrem1_f *
        k_TRPLon_cof_TrajJerkWght_sg) + Ax_Extrem2_i * Opt);

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Product4_jc = t_Ax_Extrem2_a;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Product4_jc = t_Ax_Extrem2_a;
        }
      }

      /* Gain: '<S259>/Gain2' */
      rtb_Product4_ge = 0.25F * rtb_Gain1_pv;

      /* Sum: '<S259>/Subtract2' */
      app_B.t_end_mp = rtb_K_OsV_Os_bx - rtb_Product4_ge;

      /* MATLAB Function: '<S443>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(app_B.t_end_mp, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &t_Ax_Extrem2_a,
                            &rtb_Min_l, &Ax_Extrem1_o);

      /* MATLAB Function: '<S447>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(t_Ax_Extrem2_a, rtb_Min_l, Ax_Extrem1_o,
                            app_B.t_end_mp, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Gain1_pv,
                            &rtb_Product4_e5, &Ax_Extrem2_e, &rtb_Divide4_aa,
                            &rtb_Gain9_m, &rtb_Min_lp);

      /* Switch: '<S445>/Switch' incorporates:
       *  Constant: '<S452>/Constant'
       *  Gain: '<S445>/Gain2'
       *  RelationalOperator: '<S452>/Compare'
       *  Sum: '<S445>/Add2'
       */
      rtb_LogicalOperator3_ht = (-rtb_Gain1_pv + c4 < 0.0F);

      /* Switch: '<S445>/Switch1' */
      rtb_LogicalOperator4_ec = !rtb_LogicalOperator3_ht;

      /* Logic: '<S442>/OR' incorporates:
       *  RelationalOperator: '<S442>/Equal'
       *  RelationalOperator: '<S442>/Equal1'
       */
      rtb_DFIn_is_EPBCCCanclDsbl_bl = (rtb_LogicalOperator3_ht ||
        (!rtb_LogicalOperator4_ec));

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        t_Ax_Extrem2_e = rtb_Product2_mv;
        t_Ax_Extrem1_f = rtb_Product1_a4;
        Ax_Extrem2_i = rtb_Add2_o;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          t_Ax_Extrem2_e = rtb_Product2_mv;

          /* Switch generated from: '<S424>/Switch1' */
          t_Ax_Extrem1_f = rtb_Product1_a4;

          /* Switch generated from: '<S424>/Switch1' */
          Ax_Extrem2_i = rtb_Add2_o;
        }
      }

      /* MATLAB Function: '<S441>/MATLAB Function' */
      app_MATLABFunction_a(t_Ax_Extrem2_a, rtb_Min_l, Ax_Extrem1_o,
                           app_B.t_end_mp, rtb_t_min, &rtb_Add2_o,
                           &rtb_Product1_a4, &rtb_Product2_mv, &rtb_Divide4_aa,
                           &rtb_Product4_e5, &Ax_Extrem2_e);

      /* Sum: '<S445>/Add1' incorporates:
       *  Constant: '<S445>/Constant2'
       *  Constant: '<S445>/Constant3'
       *  MinMax: '<S445>/Max2'
       *  MinMax: '<S445>/Max3'
       *  Sum: '<S445>/Subtract2'
       *  Sum: '<S445>/Subtract3'
       */
      rtb_Add2_pgh = fmaxf(rtb_Add_g0 - rtb_Product1_a4, 0.0F) + fmaxf
        (rtb_Add2_o - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S444>/MATLAB Function' */
      app_MATLABFunction_k(t_Ax_Extrem2_a, rtb_Min_l, Ax_Extrem1_o,
                           app_B.t_end_mp, &rtb_Min_lp, &rtb_Gain9_m,
                           &rtb_Product1_a4, &rtb_Add2_o);

      /* MinMax: '<S445>/Max' incorporates:
       *  Constant: '<S445>/Constant'
       *  Sum: '<S445>/Subtract'
       */
      rtb_Switch_i = fmaxf(j_traj_real_Spd - rtb_Gain9_m, 0.0F);

      /* MATLAB Function: '<S448>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(t_Ax_Extrem2_a, rtb_Min_l, Ax_Extrem1_o,
                           app_B.t_end_mp, rtb_t_min, rtb_uDLookupTable5_h,
                           &rtb_Gain9_m, &rtb_Add8, &rtb_Product2_m2,
                           &rtb_Vx_Extrem1_New_mr, &rtb_Vx_Extrem2_New_ej);

      /* Sum: '<S445>/Add4' incorporates:
       *  Constant: '<S445>/Constant1'
       *  Constant: '<S445>/Constant5'
       *  Gain: '<S445>/Gain1'
       *  MinMax: '<S445>/Max1'
       *  MinMax: '<S445>/Max5'
       *  Product: '<S445>/Product'
       *  Product: '<S445>/Product2'
       *  Sum: '<S445>/Add'
       *  Sum: '<S445>/Subtract1'
       *  Sum: '<S445>/Subtract5'
       */
      rtb_Gain1_pv = (((fmaxf(rtb_Min_lp - LimitationViolate, 0.0F) +
                        rtb_Switch_i) + rtb_Add2_pgh) + rtb_Gain9_m) + fmaxf(-c3
        + rtb_Gain1_pv, 0.0F);

      /* MATLAB Function: '<S446>/MATLAB Function' */
      app_MATLABFunction_k0(t_Ax_Extrem2_a, rtb_Min_l, Ax_Extrem1_o,
                            app_B.t_end_mp, &rtb_Min_lp);

      /* RelationalOperator: '<S442>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S442>/Product'
       *  Product: '<S442>/Product1'
       *  Product: '<S442>/Product2'
       *  Product: '<S442>/Product3'
       *  Product: '<S442>/Product4'
       *  Product: '<S442>/Product5'
       *  Sum: '<S442>/Add'
       *  Sum: '<S442>/Add1'
       */
      rtb_LogicalOperator1_d2 = ((t_Ax_Extrem2_e *
        k_TRPLon_cof_TrajLimVlatnWght_sg + t_Ax_Extrem1_f *
        k_TRPLon_cof_TrajJerkWght_sg) + Ax_Extrem2_i * Opt < (rtb_Gain1_pv *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Min_lp *
        k_TRPLon_cof_TrajJerkWght_sg) + app_B.t_end_mp * Opt);

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.c3_traj = rtb_Product4_jc;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.c3_traj = rtb_Product4_jc;
        } else {
          app_B.c3_traj = Ax_Extrem1_o;
        }
      }

      /* Sum: '<S259>/Add' */
      rtb_t24 = rtb_K_OsV_Os_bx + rtb_Product4_ge;

      /* MATLAB Function: '<S461>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(rtb_t24, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Product4_jc,
                            &Ax_Extrem1_o, &rtb_c3_f3);

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          rtb_K_OsV_Os_b = t_Ax_Extrem2_e;
          t_Ax_Extrem1_k = t_Ax_Extrem1_f;

          /* Sum: '<S259>/Subtract2' */
          app_B.t_end_mp = Ax_Extrem2_i;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          rtb_K_OsV_Os_b = t_Ax_Extrem2_e;

          /* Switch generated from: '<S442>/Switch1' */
          t_Ax_Extrem1_k = t_Ax_Extrem1_f;

          /* Sum: '<S259>/Subtract2' incorporates:
           *  Switch generated from: '<S442>/Switch1'
           */
          app_B.t_end_mp = Ax_Extrem2_i;
        } else {
          rtb_K_OsV_Os_b = rtb_Gain1_pv;
          t_Ax_Extrem1_k = rtb_Min_lp;
        }
      } else {
        /* Sum: '<S259>/Subtract2' */
        app_B.t_end_mp = rtb_K_OsV_Os_bx;
      }

      /* MATLAB Function: '<S459>/MATLAB Function' */
      app_MATLABFunction_a(rtb_Product4_jc, Ax_Extrem1_o, rtb_c3_f3, rtb_t24,
                           rtb_t_min, &Ax_Extrem2_i, &t_Ax_Extrem1_f,
                           &t_Ax_Extrem2_e, &rtb_Min_lp, &rtb_Gain1_pv,
                           &rtb_Gain9_m);

      /* Sum: '<S463>/Subtract3' */
      rtb_Subtract5 = Ax_Extrem2_i - rtb_Product_iz;

      /* Sum: '<S463>/Add1' incorporates:
       *  Constant: '<S463>/Constant2'
       *  Constant: '<S463>/Constant3'
       *  MinMax: '<S463>/Max2'
       *  MinMax: '<S463>/Max3'
       *  Sum: '<S463>/Subtract2'
       */
      rtb_Add2_pgh = fmaxf(rtb_Add_g0 - t_Ax_Extrem1_f, 0.0F) + fmaxf
        (rtb_Subtract5, 0.0F);

      /* MATLAB Function: '<S462>/MATLAB Function' */
      app_MATLABFunction_k(rtb_Product4_jc, Ax_Extrem1_o, rtb_c3_f3, rtb_t24,
                           &rtb_JerkSqIntg_t_end_fq, &rtb_Subtract5,
                           &t_Ax_Extrem1_f, &Ax_Extrem2_i);

      /* Sum: '<S463>/Subtract' */
      rtb_Subtract5 = j_traj_real_Spd - rtb_Subtract5;

      /* MinMax: '<S463>/Max' incorporates:
       *  Constant: '<S463>/Constant'
       */
      rtb_Switch_i = fmaxf(rtb_Subtract5, 0.0F);

      /* Sum: '<S463>/Subtract1' */
      rtb_Subtract5 = rtb_JerkSqIntg_t_end_fq - LimitationViolate;

      /* MATLAB Function: '<S466>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(rtb_Product4_jc, Ax_Extrem1_o, rtb_c3_f3, rtb_t24,
                           rtb_t_min, rtb_uDLookupTable5_h, &rtb_Product4_ge,
                           &rtb_Add8, &rtb_Product2_m2, &rtb_Vx_Extrem1_New_mr,
                           &rtb_Vx_Extrem2_New_ej);

      /* MATLAB Function: '<S465>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(rtb_Product4_jc, Ax_Extrem1_o, rtb_c3_f3, rtb_t24,
                            rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg,
                            &rtb_JerkSqIntg_t_end_fq, &rtb_Add8,
                            &rtb_Product2_m2, &rtb_Vx_Extrem1_New_mr,
                            &rtb_Vx_Extrem2_New_ej, &rtb_Sx_Extrem2_New);

      /* Sum: '<S463>/Add4' incorporates:
       *  Constant: '<S463>/Constant1'
       *  Constant: '<S463>/Constant5'
       *  Gain: '<S463>/Gain1'
       *  MinMax: '<S463>/Max1'
       *  MinMax: '<S463>/Max5'
       *  Product: '<S463>/Product'
       *  Product: '<S463>/Product2'
       *  Sum: '<S463>/Add'
       *  Sum: '<S463>/Subtract5'
       */
      rtb_Lim_Violation_New_ck = (((rtb_Switch_i + fmaxf(rtb_Subtract5, 0.0F)) +
        rtb_Add2_pgh) + rtb_Product4_ge) + fmaxf(-c3 + rtb_JerkSqIntg_t_end_fq,
        0.0F);

      /* MATLAB Function: '<S464>/MATLAB Function' */
      app_MATLABFunction_k0(rtb_Product4_jc, Ax_Extrem1_o, rtb_c3_f3, rtb_t24,
                            &rtb_Product4_ge);

      /* RelationalOperator: '<S460>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S460>/Product'
       *  Product: '<S460>/Product1'
       *  Product: '<S460>/Product2'
       *  Product: '<S460>/Product3'
       *  Product: '<S460>/Product4'
       *  Product: '<S460>/Product5'
       *  Sum: '<S460>/Add'
       *  Sum: '<S460>/Add1'
       */
      rtb_LogicalOperator3_ox = ((rtb_K_OsV_Os_b *
        k_TRPLon_cof_TrajLimVlatnWght_sg + t_Ax_Extrem1_k *
        k_TRPLon_cof_TrajJerkWght_sg) + app_B.t_end_mp * Opt <
        (rtb_Lim_Violation_New_ck * k_TRPLon_cof_TrajLimVlatnWght_sg +
         rtb_Product4_ge * k_TRPLon_cof_TrajJerkWght_sg) + rtb_t24 * Opt);

      /* Switch: '<S463>/Switch' incorporates:
       *  Constant: '<S470>/Constant'
       *  Gain: '<S463>/Gain2'
       *  RelationalOperator: '<S470>/Compare'
       *  Sum: '<S463>/Add2'
       */
      rtb_LogicalOperator2_hk = (-rtb_JerkSqIntg_t_end_fq + c4 < 0.0F);

      /* Switch: '<S463>/Switch1' */
      rtb_DFIn_is_APAStsDsbl_bl = !rtb_LogicalOperator2_hk;

      /* Logic: '<S460>/OR' incorporates:
       *  RelationalOperator: '<S460>/Equal'
       *  RelationalOperator: '<S460>/Equal1'
       */
      rtb_DFIn_is_NRCDStsDsbl_bl = (rtb_LogicalOperator2_hk ||
        (!rtb_DFIn_is_APAStsDsbl_bl));

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_c3_f3 = app_B.c3_traj;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_c3_f3 = app_B.c3_traj;
        }
      }

      /* Sum: '<S259>/Add1' */
      rtb_Add2_pgh = rtb_K_OsV_Os_bx + rtb_Switch_hv;

      /* MATLAB Function: '<S299>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(rtb_Add2_pgh, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Switch_i,
                            &rtb_c4_ef, &rtb_c3_kk);

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_Lim_Violation_New_ck = rtb_K_OsV_Os_b;
        rtb_Product4_ge = t_Ax_Extrem1_k;
        rtb_t24 = app_B.t_end_mp;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_Lim_Violation_New_ck = rtb_K_OsV_Os_b;

          /* Switch generated from: '<S460>/Switch1' */
          rtb_Product4_ge = t_Ax_Extrem1_k;

          /* Switch generated from: '<S460>/Switch1' */
          rtb_t24 = app_B.t_end_mp;
        }
      }

      /* MATLAB Function: '<S297>/MATLAB Function' */
      app_MATLABFunction_a(rtb_Switch_i, rtb_c4_ef, rtb_c3_kk, rtb_Add2_pgh,
                           rtb_t_min, &rtb_Add8, &rtb_Product2_m2,
                           &rtb_Vx_Extrem1_New_mr, &rtb_Vx_Extrem2_New_ej,
                           &t_Ax_Extrem1_k, &rtb_K_OsV_Os_b);

      /* Sum: '<S301>/Add1' incorporates:
       *  Constant: '<S301>/Constant2'
       *  Constant: '<S301>/Constant3'
       *  MinMax: '<S301>/Max2'
       *  MinMax: '<S301>/Max3'
       *  Sum: '<S301>/Subtract2'
       *  Sum: '<S301>/Subtract3'
       */
      rtb_Switch_hv = fmaxf(rtb_Add_g0 - rtb_Product2_m2, 0.0F) + fmaxf(rtb_Add8
        - rtb_Product_iz, 0.0F);

      /* MATLAB Function: '<S300>/MATLAB Function' */
      app_MATLABFunction_k(rtb_Switch_i, rtb_c4_ef, rtb_c3_kk, rtb_Add2_pgh,
                           &rtb_JerkSqIntg_t_end_or, &rtb_Sx_Extrem2_New,
                           &rtb_Product2_m2, &rtb_Add8);

      /* MinMax: '<S301>/Max' incorporates:
       *  Constant: '<S301>/Constant'
       *  Sum: '<S301>/Subtract'
       */
      rtb_JerkSqIntg_t_end_fq = fmaxf(j_traj_real_Spd - rtb_Sx_Extrem2_New, 0.0F);

      /* MATLAB Function: '<S304>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(rtb_Switch_i, rtb_c4_ef, rtb_c3_kk, rtb_Add2_pgh,
                           rtb_t_min, rtb_uDLookupTable5_h, &rtb_Sx_Extrem2_New,
                           &rtb_t_Vx_Extrem1_New_go, &rtb_t_Vx_Extrem2_New_pk,
                           &rtb_Subtract5, &rtb_Vx_Extrem2_New_bwb);

      /* MATLAB Function: '<S303>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(rtb_Switch_i, rtb_c4_ef, rtb_c3_kk, rtb_Add2_pgh,
                            rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg,
                            &rtb_t_Vx_Extrem1_New_go, &rtb_t_Vx_Extrem2_New_pk,
                            &rtb_Subtract5, &rtb_Vx_Extrem2_New_bwb,
                            &rtb_Sx_Extrem1_New_g, &rtb_Sx_Extrem2_New_i0);

      /* Sum: '<S301>/Add4' incorporates:
       *  Constant: '<S301>/Constant1'
       *  Constant: '<S301>/Constant5'
       *  Gain: '<S301>/Gain1'
       *  MinMax: '<S301>/Max1'
       *  MinMax: '<S301>/Max5'
       *  Product: '<S301>/Product'
       *  Product: '<S301>/Product2'
       *  Sum: '<S301>/Add'
       *  Sum: '<S301>/Subtract1'
       *  Sum: '<S301>/Subtract5'
       */
      rtb_Sx_Extrem1_New_g = (((fmaxf(rtb_JerkSqIntg_t_end_or -
        LimitationViolate, 0.0F) + rtb_JerkSqIntg_t_end_fq) + rtb_Switch_hv) +
        rtb_Sx_Extrem2_New) + fmaxf(-c3 + rtb_t_Vx_Extrem1_New_go, 0.0F);

      /* MATLAB Function: '<S302>/MATLAB Function' */
      app_MATLABFunction_k0(rtb_Switch_i, rtb_c4_ef, rtb_c3_kk, rtb_Add2_pgh,
                            &rtb_JerkSqIntg_t_end_or);

      /* RelationalOperator: '<S298>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Product: '<S298>/Product'
       *  Product: '<S298>/Product1'
       *  Product: '<S298>/Product2'
       *  Product: '<S298>/Product3'
       *  Product: '<S298>/Product4'
       *  Product: '<S298>/Product5'
       *  Sum: '<S298>/Add'
       *  Sum: '<S298>/Add1'
       */
      rtb_LogicalOperator9_a = ((rtb_Lim_Violation_New_ck *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_Product4_ge *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_t24 * Opt < (rtb_Sx_Extrem1_New_g *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_JerkSqIntg_t_end_or *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Add2_pgh * Opt);

      /* Switch: '<S301>/Switch' incorporates:
       *  Constant: '<S308>/Constant'
       *  Gain: '<S301>/Gain2'
       *  RelationalOperator: '<S308>/Compare'
       *  Sum: '<S301>/Add2'
       */
      rtb_Collision_New_k = (-rtb_t_Vx_Extrem1_New_go + c4 < 0.0F);

      /* Switch: '<S301>/Switch1' */
      rtb_Traj_Valid_New_jh = !rtb_Collision_New_k;

      /* Logic: '<S298>/OR' incorporates:
       *  RelationalOperator: '<S298>/Equal'
       *  RelationalOperator: '<S298>/Equal1'
       */
      rtb_OR_p = (rtb_Collision_New_k || (!rtb_Traj_Valid_New_jh));

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_c3_kk = rtb_c3_f3;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_c3_kk = rtb_c3_f3;
        }
      }

      /* Sum: '<S259>/Add2' */
      rtb_K_OsV_Os_bx += Ax_Extrem2_j;

      /* MATLAB Function: '<S317>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_gl(rtb_K_OsV_Os_bx, rtb_t_min, rtb_uDLookupTable5_h,
                            rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_Vx_Extrem2_New_bwb,
                            &rtb_Sx_Extrem2_New_i0, &rtb_c3_ks);

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Add2_pgh = rtb_t24;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Add2_pgh = rtb_t24;
        }
      }

      /* MATLAB Function: '<S315>/MATLAB Function' */
      app_MATLABFunction_a(rtb_Vx_Extrem2_New_bwb, rtb_Sx_Extrem2_New_i0,
                           rtb_c3_ks, rtb_K_OsV_Os_bx, rtb_t_min, &rtb_t24,
                           &rtb_JerkSqIntg_t_end_fq, &rtb_c3_f3,
                           &rtb_t_Vx_Extrem2_New_pk, &rtb_t_Vx_Extrem1_New_go,
                           &rtb_Sx_Extrem2_New);

      /* Sum: '<S319>/Subtract3' */
      rtb_Subtract5 = rtb_t24 - rtb_Product_iz;

      /* Product: '<S319>/Product' incorporates:
       *  Constant: '<S319>/Constant2'
       *  Constant: '<S319>/Constant3'
       *  MinMax: '<S319>/Max2'
       *  MinMax: '<S319>/Max3'
       *  Sum: '<S319>/Add1'
       *  Sum: '<S319>/Subtract2'
       */
      rtb_Product_lk = fmaxf(rtb_Add_g0 - rtb_JerkSqIntg_t_end_fq, 0.0F) + fmaxf
        (rtb_Subtract5, 0.0F);

      /* MATLAB Function: '<S318>/MATLAB Function' */
      app_MATLABFunction_k(rtb_Vx_Extrem2_New_bwb, rtb_Sx_Extrem2_New_i0,
                           rtb_c3_ks, rtb_K_OsV_Os_bx, &rtb_JerkSqIntg_t_end_fq,
                           &rtb_Subtract5, &Ax_Extrem2_j, &rtb_t24);

      /* Sum: '<S319>/Subtract' */
      rtb_Subtract5 = j_traj_real_Spd - rtb_Subtract5;

      /* Product: '<S319>/Product1' incorporates:
       *  Constant: '<S319>/Constant'
       *  Constant: '<S319>/Constant1'
       *  MinMax: '<S319>/Max'
       *  MinMax: '<S319>/Max1'
       *  Sum: '<S319>/Add'
       *  Sum: '<S319>/Subtract1'
       */
      rtb_Subtract5 = fmaxf(rtb_JerkSqIntg_t_end_fq - LimitationViolate, 0.0F) +
        fmaxf(rtb_Subtract5, 0.0F);

      /* MATLAB Function: '<S322>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_n(rtb_Vx_Extrem2_New_bwb, rtb_Sx_Extrem2_New_i0,
                           rtb_c3_ks, rtb_K_OsV_Os_bx, rtb_t_min,
                           rtb_uDLookupTable5_h, &rtb_JerkSqIntg_t_end_fq,
                           &rtb_Switch_hv, &rtb_t_Vx_Extrem2_New_ks,
                           &rtb_Vx_Extrem1_New_i, &rtb_Vx_Extrem2_New_a);

      /* Product: '<S319>/Product2' */
      rtb_t_Vx_Extrem2_New_ks = rtb_JerkSqIntg_t_end_fq;

      /* MATLAB Function: '<S321>/MATLAB Function' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_MATLABFunction_aa(rtb_Vx_Extrem2_New_bwb, rtb_Sx_Extrem2_New_i0,
                            rtb_c3_ks, rtb_K_OsV_Os_bx, rtb_t_min,
                            rtb_uDLookupTable5_h, rtb_ACC_t_FTCDsrdDistLv1_sg,
                            &rtb_Switch_hv, &rtb_JerkSqIntg_t_end_fq,
                            &rtb_Vx_Extrem1_New_i, &rtb_Vx_Extrem2_New_a,
                            &rtb_Sx_Extrem1_New_c, &rtb_Sx_Extrem2_New_l);

      /* MATLAB Function: '<S320>/MATLAB Function' */
      app_MATLABFunction_k0(rtb_Vx_Extrem2_New_bwb, rtb_Sx_Extrem2_New_i0,
                            rtb_c3_ks, rtb_K_OsV_Os_bx, &rtb_JerkSqIntg_t_end_fq);

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Sx_Extrem1_New_g = rtb_Lim_Violation_New_ck;
        rtb_JerkSqIntg_t_end_or = rtb_Product4_ge;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Sx_Extrem1_New_g = rtb_Lim_Violation_New_ck;

          /* Switch generated from: '<S298>/Switch1' */
          rtb_JerkSqIntg_t_end_or = rtb_Product4_ge;
        }
      }

      /* RelationalOperator: '<S316>/Relational Operator' incorporates:
       *  Constant: '<S239>/Constant'
       *  Constant: '<S239>/Constant7'
       *  Constant: '<S319>/Constant5'
       *  Gain: '<S319>/Gain1'
       *  MinMax: '<S319>/Max5'
       *  Product: '<S316>/Product'
       *  Product: '<S316>/Product1'
       *  Product: '<S316>/Product2'
       *  Product: '<S316>/Product3'
       *  Product: '<S316>/Product4'
       *  Product: '<S316>/Product5'
       *  Sum: '<S316>/Add'
       *  Sum: '<S316>/Add1'
       *  Sum: '<S319>/Add4'
       *  Sum: '<S319>/Subtract5'
       */
      rtb_RelationalOperator_io = ((rtb_Sx_Extrem1_New_g *
        k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_JerkSqIntg_t_end_or *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_Add2_pgh * Opt < ((((rtb_Product_lk
        + rtb_Subtract5) + rtb_t_Vx_Extrem2_New_ks) + fmaxf(-c3 + rtb_Switch_hv,
        0.0F)) * k_TRPLon_cof_TrajLimVlatnWght_sg + rtb_JerkSqIntg_t_end_fq *
        k_TRPLon_cof_TrajJerkWght_sg) + rtb_K_OsV_Os_bx * Opt);

      /* Switch: '<S319>/Switch' incorporates:
       *  Constant: '<S326>/Constant'
       *  Gain: '<S319>/Gain2'
       *  RelationalOperator: '<S326>/Compare'
       *  Sum: '<S319>/Add2'
       */
      rtb_Collision_New_dt = (-rtb_Switch_hv + c4 < 0.0F);

      /* Switch: '<S319>/Switch1' */
      rtb_Traj_Valid_New_e = !rtb_Collision_New_dt;

      /* Logic: '<S316>/OR' incorporates:
       *  RelationalOperator: '<S316>/Equal'
       *  RelationalOperator: '<S316>/Equal1'
       */
      rtb_OR_cr = (rtb_Collision_New_dt || (!rtb_Traj_Valid_New_e));

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.c3_traj = rtb_c3_kk;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.c3_traj = rtb_c3_kk;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.c3_traj = rtb_c3_ks;
        }
      }

      /* Product: '<S237>/Divide1' incorporates:
       *  Constant: '<S237>/Constant2'
       */
      app_B.Longt_Dist_C3 = app_B.c3_traj / 6.0F;

      /* Product: '<S237>/Divide6' incorporates:
       *  Constant: '<S237>/Constant7'
       */
      app_B.Traj_Rel_C3 = app_B.c3_traj / 6.0F;

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant2'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_K_OsV_Os_c = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant2'
           */
          rtb_K_OsV_Os_c = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_KTt_a = rtb_K_OsV_Os_c;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_KTt_a = rtb_K_OsV_Os_c;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Product1_j2z = rtb_KTt_a;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_Product1_j2z = rtb_KTt_a;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        Ax_Extrem2 = rtb_Product1_j2z;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          Ax_Extrem2 = rtb_Product1_j2z;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        t_Ax_Extrem2 = Ax_Extrem2;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          t_Ax_Extrem2 = Ax_Extrem2;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.c4_traj = t_Ax_Extrem2;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.c4_traj = t_Ax_Extrem2;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        t_Ax_Extrem2_l = app_B.c4_traj;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          t_Ax_Extrem2_l = app_B.c4_traj;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Gain9_b = t_Ax_Extrem2_l;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Gain9_b = t_Ax_Extrem2_l;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.c4_traj = rtb_Gain9_b;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.c4_traj = rtb_Gain9_b;
        } else {
          app_B.c4_traj = rtb_Min_l;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        Ax_Extrem1_o = app_B.c4_traj;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          Ax_Extrem1_o = app_B.c4_traj;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_c4_ef = Ax_Extrem1_o;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_c4_ef = Ax_Extrem1_o;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.c4_traj = rtb_c4_ef;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.c4_traj = rtb_c4_ef;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.c4_traj = rtb_Sx_Extrem2_New_i0;
        }
      }

      /* Product: '<S237>/Divide2' incorporates:
       *  Constant: '<S237>/Constant3'
       */
      app_B.Longt_Dist_C4 = app_B.c4_traj / 24.0F;

      /* Product: '<S237>/Divide7' incorporates:
       *  Constant: '<S237>/Constant8'
       */
      app_B.Traj_Rel_C4 = app_B.c4_traj / 24.0F;

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant3'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_KTt_h = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant3'
           */
          rtb_KTt_h = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Product2_jd = rtb_KTt_h;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_Product2_jd = rtb_KTt_h;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        ax_Max_Traj = rtb_Product2_jd;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          ax_Max_Traj = rtb_Product2_jd;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        Ax_Extrem1 = ax_Max_Traj;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          Ax_Extrem1 = ax_Max_Traj;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        t_Ax_Extrem1 = Ax_Extrem1;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          t_Ax_Extrem1 = Ax_Extrem1;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.c5_traj = t_Ax_Extrem1;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.c5_traj = t_Ax_Extrem1;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        t_Ax_Extrem1_j = app_B.c5_traj;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          t_Ax_Extrem1_j = app_B.c5_traj;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Divide4_b = t_Ax_Extrem1_j;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Divide4_b = t_Ax_Extrem1_j;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.c5_traj = rtb_Divide4_b;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.c5_traj = rtb_Divide4_b;
        } else {
          app_B.c5_traj = t_Ax_Extrem2_a;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_Product4_jc = app_B.c5_traj;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_Product4_jc = app_B.c5_traj;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Switch_i = rtb_Product4_jc;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Switch_i = rtb_Product4_jc;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.c5_traj = rtb_Switch_i;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.c5_traj = rtb_Switch_i;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.c5_traj = rtb_Vx_Extrem2_New_bwb;
        }
      }

      /* Product: '<S237>/Divide3' incorporates:
       *  Constant: '<S237>/Constant5'
       */
      app_B.Longt_Dist_C5 = app_B.c5_traj / 120.0F;

      /* Product: '<S237>/Divide8' incorporates:
       *  Constant: '<S237>/Constant10'
       */
      app_B.Traj_Rel_C5 = app_B.c5_traj / 120.0F;

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant6'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Product4_lc = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant6'
           */
          rtb_Product4_lc = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_KTt_af = rtb_Product4_lc;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_KTt_af = rtb_Product4_lc;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        t_Ax_Extrem1_e = rtb_KTt_af;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          t_Ax_Extrem1_e = rtb_KTt_af;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Product1_da = t_Ax_Extrem1_e;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_Product1_da = t_Ax_Extrem1_e;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Product4_no = rtb_Product1_da;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_Product4_no = rtb_Product1_da;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.t_Jerk_Extrem_n = rtb_Product4_no;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.t_Jerk_Extrem_n = rtb_Product4_no;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_Switch_ddv = app_B.t_Jerk_Extrem_n;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_Switch_ddv = app_B.t_Jerk_Extrem_n;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_K_OsV_Os_au = rtb_Switch_ddv;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_K_OsV_Os_au = rtb_Switch_ddv;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.t_Jerk_Extrem_n = rtb_K_OsV_Os_au;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.t_Jerk_Extrem_n = rtb_K_OsV_Os_au;
        } else {
          app_B.t_Jerk_Extrem_n = rtb_Product1_a4;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        t_Ax_Extrem1_f = app_B.t_Jerk_Extrem_n;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          t_Ax_Extrem1_f = app_B.t_Jerk_Extrem_n;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Product2_m2 = t_Ax_Extrem1_f;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Product2_m2 = t_Ax_Extrem1_f;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.t_Jerk_Extrem_n = rtb_Product2_m2;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.t_Jerk_Extrem_n = rtb_Product2_m2;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.t_Jerk_Extrem_n = Ax_Extrem2_j;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant7'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Gain1_bg = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant7'
           */
          rtb_Gain1_bg = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Product4_dp = rtb_Gain1_bg;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_Product4_dp = rtb_Gain1_bg;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Product4_k0 = rtb_Product4_dp;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_Product4_k0 = rtb_Product4_dp;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        Jerk_Extrem = rtb_Product4_k0;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          Jerk_Extrem = rtb_Product4_k0;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        t_Jerk_Extrem = Jerk_Extrem;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          t_Jerk_Extrem = Jerk_Extrem;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.Ax_Extrem1_bf = t_Jerk_Extrem;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.Ax_Extrem1_bf = t_Jerk_Extrem;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        c5 = app_B.Ax_Extrem1_bf;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          c5 = app_B.Ax_Extrem1_bf;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Min_h = c5;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Min_h = c5;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.Ax_Extrem1_bf = rtb_Min_h;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.Ax_Extrem1_bf = rtb_Min_h;
        } else {
          app_B.Ax_Extrem1_bf = rtb_Product4_e5;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_Gain1_pv = app_B.Ax_Extrem1_bf;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_Gain1_pv = app_B.Ax_Extrem1_bf;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        t_Ax_Extrem1_k = rtb_Gain1_pv;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          t_Ax_Extrem1_k = rtb_Gain1_pv;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.Ax_Extrem1_bf = t_Ax_Extrem1_k;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.Ax_Extrem1_bf = t_Ax_Extrem1_k;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Ax_Extrem1_bf = rtb_t_Vx_Extrem1_New_go;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant8'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Divide4_h1 = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant8'
           */
          rtb_Divide4_h1 = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Gain9_kp = rtb_Divide4_h1;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_Gain9_kp = rtb_Divide4_h1;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Switch_ki = rtb_Gain9_kp;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_Switch_ki = rtb_Gain9_kp;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Gain1_jl = rtb_Switch_ki;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_Gain1_jl = rtb_Switch_ki;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Divide4_b0 = rtb_Gain1_jl;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_Divide4_b0 = rtb_Gain1_jl;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.Ax_Extrem2_f0 = rtb_Divide4_b0;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.Ax_Extrem2_f0 = rtb_Divide4_b0;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        Ax_Extrem1_b = app_B.Ax_Extrem2_f0;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          Ax_Extrem1_b = app_B.Ax_Extrem2_f0;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Product2_pl1 = Ax_Extrem1_b;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Product2_pl1 = Ax_Extrem1_b;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.Ax_Extrem2_f0 = rtb_Product2_pl1;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.Ax_Extrem2_f0 = rtb_Product2_pl1;
        } else {
          app_B.Ax_Extrem2_f0 = Ax_Extrem2_e;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_Gain9_m = app_B.Ax_Extrem2_f0;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_Gain9_m = app_B.Ax_Extrem2_f0;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_K_OsV_Os_b = rtb_Gain9_m;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_K_OsV_Os_b = rtb_Gain9_m;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.Ax_Extrem2_f0 = rtb_K_OsV_Os_b;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.Ax_Extrem2_f0 = rtb_K_OsV_Os_b;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Ax_Extrem2_f0 = rtb_Sx_Extrem2_New;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant9'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Product4_aq = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant9'
           */
          rtb_Product4_aq = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_Product4_p = rtb_Product4_aq;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_Product4_p = rtb_Product4_aq;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        Ax_Extrem2_f = rtb_Product4_p;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          Ax_Extrem2_f = rtb_Product4_p;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Add2_l = Ax_Extrem2_f;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_Add2_l = Ax_Extrem2_f;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Gain9_e = rtb_Add2_l;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_Gain9_e = rtb_Add2_l;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.Jerk_Extrem_o = rtb_Gain9_e;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.Jerk_Extrem_o = rtb_Gain9_e;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_Product4_j = app_B.Jerk_Extrem_o;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_Product4_j = app_B.Jerk_Extrem_o;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_KTt_b = rtb_Product4_j;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_KTt_b = rtb_Product4_j;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.Jerk_Extrem_o = rtb_KTt_b;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.Jerk_Extrem_o = rtb_KTt_b;
        } else {
          app_B.Jerk_Extrem_o = rtb_Add2_o;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        Ax_Extrem2_i = app_B.Jerk_Extrem_o;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          Ax_Extrem2_i = app_B.Jerk_Extrem_o;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Add8 = Ax_Extrem2_i;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Add8 = Ax_Extrem2_i;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.Jerk_Extrem_o = rtb_Add8;

          /* Sum: '<S259>/Subtract2' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.t_end_mp = rtb_Add2_pgh;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.Jerk_Extrem_o = rtb_Add8;

          /* Sum: '<S259>/Subtract2' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.t_end_mp = rtb_Add2_pgh;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Jerk_Extrem_o = rtb_t24;

          /* Sum: '<S259>/Subtract2' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.t_end_mp = rtb_K_OsV_Os_bx;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = app_B.Traj_Valid;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f = app_B.Traj_Valid;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_DFIn_is_CCFM_TCSStsFlt_bl_d = rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_DFIn_is_CCFM_TCSStsFlt_bl_d =
            rtb_DFIn_is_CCFM_ACCReqRespErrFlt_bl_f;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          /* Switch: '<S391>/Switch1' */
          app_B.Traj_Valid = rtb_DFIn_is_CCFM_TCSStsFlt_bl_d;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S442>/Switch1'
           */
          app_B.Traj_Valid = rtb_DFIn_is_CCFM_TCSStsFlt_bl_d;
        } else {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S442>/Switch1'
           */
          app_B.Traj_Valid = rtb_LogicalOperator4_ec;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_DFIn_is_APAStsDsbl_bl = app_B.Traj_Valid;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_DFIn_is_APAStsDsbl_bl = app_B.Traj_Valid;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Traj_Valid_New_jh = rtb_DFIn_is_APAStsDsbl_bl;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Traj_Valid_New_jh = rtb_DFIn_is_APAStsDsbl_bl;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.Traj_Valid = rtb_Traj_Valid_New_jh;
        } else if (rtb_RelationalOperator_io) {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Traj_Valid = rtb_Traj_Valid_New_jh;
        } else {
          /* Switch: '<S391>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Traj_Valid = rtb_Traj_Valid_New_e;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl = app_B.Collision_b;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl = app_B.Collision_b;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_LogicalOperator9_o = rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_LogicalOperator9_o = rtb_DFIn_is_CCFM_EPBStsUnknowFlt_bl;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          /* Switch: '<S391>/Switch' */
          app_B.Collision_b = rtb_LogicalOperator9_o;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S442>/Switch1'
           */
          app_B.Collision_b = rtb_LogicalOperator9_o;
        } else {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S442>/Switch1'
           */
          app_B.Collision_b = rtb_LogicalOperator3_ht;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_LogicalOperator2_hk = app_B.Collision_b;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_LogicalOperator2_hk = app_B.Collision_b;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Collision_New_k = rtb_LogicalOperator2_hk;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Collision_New_k = rtb_LogicalOperator2_hk;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.Collision_b = rtb_Collision_New_k;
        } else if (rtb_RelationalOperator_io) {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Collision_b = rtb_Collision_New_k;
        } else {
          /* Switch: '<S391>/Switch' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.Collision_b = rtb_Collision_New_dt;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant4'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Product1_ei = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant4'
           */
          rtb_Product1_ei = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        rtb_K_OsV_Os_l = rtb_Product1_ei;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          rtb_K_OsV_Os_l = rtb_Product1_ei;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        t_Ax_Extrem2_g = rtb_K_OsV_Os_l;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          t_Ax_Extrem2_g = rtb_K_OsV_Os_l;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Product2_jb = t_Ax_Extrem2_g;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_Product2_jb = t_Ax_Extrem2_g;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_KTt_m0 = rtb_Product2_jb;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_KTt_m0 = rtb_Product2_jb;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.t_Ax_Extrem1_l = rtb_KTt_m0;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.t_Ax_Extrem1_l = rtb_KTt_m0;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_Add2_fb = app_B.t_Ax_Extrem1_l;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_Add2_fb = app_B.t_Ax_Extrem1_l;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        rtb_Add1_fd = rtb_Add2_fb;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          rtb_Add1_fd = rtb_Add2_fb;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.t_Ax_Extrem1_l = rtb_Add1_fd;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.t_Ax_Extrem1_l = rtb_Add1_fd;
        } else {
          app_B.t_Ax_Extrem1_l = rtb_Product2_mv;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        t_Ax_Extrem2_e = app_B.t_Ax_Extrem1_l;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          t_Ax_Extrem2_e = app_B.t_Ax_Extrem1_l;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Vx_Extrem1_New_mr = t_Ax_Extrem2_e;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Vx_Extrem1_New_mr = t_Ax_Extrem2_e;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.t_Ax_Extrem1_l = rtb_Vx_Extrem1_New_mr;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.t_Ax_Extrem1_l = rtb_Vx_Extrem1_New_mr;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.t_Ax_Extrem1_l = rtb_c3_f3;
        }
      }

      /* Switch generated from: '<S262>/Switch' incorporates:
       *  Constant: '<S246>/Constant5'
       *  Switch generated from: '<S262>/Switch1'
       */
      if (rtb_LogicalOperator1_pr) {
        rtb_Product2_hzb = 0.0F;
      } else {
        if (rtb_LogicalOperator3_d) {
          /* Switch generated from: '<S262>/Switch1' incorporates:
           *  Constant: '<S246>/Constant5'
           */
          rtb_Product2_hzb = 0.0F;
        }
      }

      /* Switch generated from: '<S280>/Switch' incorporates:
       *  Switch generated from: '<S280>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_l) {
        Ax_Extrem1_n = rtb_Product2_hzb;
      } else {
        if (rtb_LogicalOperator4_jt) {
          /* Switch generated from: '<S280>/Switch1' */
          Ax_Extrem1_n = rtb_Product2_hzb;
        }
      }

      /* Switch generated from: '<S334>/Switch' incorporates:
       *  Switch generated from: '<S334>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RRDoorDsbl_bl_p) {
        rtb_Min_p = Ax_Extrem1_n;
      } else {
        if (rtb_LogicalOperator5_m) {
          /* Switch generated from: '<S334>/Switch1' */
          rtb_Min_p = Ax_Extrem1_n;
        }
      }

      /* Switch generated from: '<S352>/Switch' incorporates:
       *  Switch generated from: '<S352>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_RLDoorDsbl_bl_f) {
        rtb_Gain1_az = rtb_Min_p;
      } else {
        if (rtb_LogicalOperator10_mo) {
          /* Switch generated from: '<S352>/Switch1' */
          rtb_Gain1_az = rtb_Min_p;
        }
      }

      /* Switch generated from: '<S370>/Switch' incorporates:
       *  Switch generated from: '<S370>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        rtb_Product1_hd = rtb_Gain1_az;
      } else {
        if (rtb_LogicalOperator2_e5) {
          /* Switch generated from: '<S370>/Switch1' */
          rtb_Product1_hd = rtb_Gain1_az;
        }
      }

      /* Switch generated from: '<S388>/Switch' incorporates:
       *  Switch generated from: '<S388>/Switch1'
       */
      if (rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m) {
        app_B.t_Ax_Extrem2_cz = rtb_Product1_hd;
      } else {
        if (rtb_DFIn_is_CCFM_BntStsDsbl_bl_p) {
          /* Switch generated from: '<S388>/Switch1' */
          app_B.t_Ax_Extrem2_cz = rtb_Product1_hd;
        }
      }

      /* Switch generated from: '<S406>/Switch' incorporates:
       *  Switch generated from: '<S406>/Switch1'
       */
      if (rtb_RelationalOperator7_oa) {
        rtb_Product1_n3 = app_B.t_Ax_Extrem2_cz;
      } else {
        if (rtb_LogicalOperator2_hs) {
          /* Switch generated from: '<S406>/Switch1' */
          rtb_Product1_n3 = app_B.t_Ax_Extrem2_cz;
        }
      }

      /* Switch generated from: '<S424>/Switch' incorporates:
       *  Switch generated from: '<S424>/Switch1'
       */
      if (rtb_DFIn_is_CCFM_VSEStsFlt_bl_d) {
        Ax_Extrem1_ny = rtb_Product1_n3;
      } else {
        if (rtb_LogicalOperator2_fg) {
          /* Switch generated from: '<S424>/Switch1' */
          Ax_Extrem1_ny = rtb_Product1_n3;
        }
      }

      /* Switch generated from: '<S237>/Switch' incorporates:
       *  RelationalOperator: '<S237>/Equal'
       */
      if (rtb_LogicalOperator3_n0p) {
        /* Switch generated from: '<S442>/Switch' incorporates:
         *  Switch generated from: '<S442>/Switch1'
         */
        if (rtb_DFIn_is_EPBCCCanclDsbl_bl) {
          app_B.t_Ax_Extrem2_cz = Ax_Extrem1_ny;
        } else if (rtb_LogicalOperator1_d2) {
          /* Switch generated from: '<S442>/Switch1' */
          app_B.t_Ax_Extrem2_cz = Ax_Extrem1_ny;
        } else {
          app_B.t_Ax_Extrem2_cz = rtb_Divide4_aa;
        }
      }

      /* Switch generated from: '<S460>/Switch' incorporates:
       *  Switch generated from: '<S460>/Switch1'
       */
      if (rtb_DFIn_is_NRCDStsDsbl_bl) {
        rtb_Min_lp = app_B.t_Ax_Extrem2_cz;
      } else {
        if (rtb_LogicalOperator3_ox) {
          /* Switch generated from: '<S460>/Switch1' */
          rtb_Min_lp = app_B.t_Ax_Extrem2_cz;
        }
      }

      /* Switch generated from: '<S298>/Switch' incorporates:
       *  Switch generated from: '<S298>/Switch1'
       */
      if (rtb_OR_p) {
        rtb_Vx_Extrem2_New_ej = rtb_Min_lp;
      } else {
        if (rtb_LogicalOperator9_a) {
          /* Switch generated from: '<S298>/Switch1' */
          rtb_Vx_Extrem2_New_ej = rtb_Min_lp;
        }
      }

      /* Switch generated from: '<S237>/Switch1' incorporates:
       *  RelationalOperator: '<S237>/Equal1'
       */
      if (rtb_DFIn_is_CCFM_CCSwDataIntgtyFlt_b_o) {
        /* Switch generated from: '<S316>/Switch' incorporates:
         *  Switch generated from: '<S316>/Switch1'
         */
        if (rtb_OR_cr) {
          /* Switch generated from: '<S237>/Switch1' */
          app_B.t_Ax_Extrem2_cz = rtb_Vx_Extrem2_New_ej;
        } else if (rtb_RelationalOperator_io) {
          /* Switch generated from: '<S316>/Switch1' incorporates:
           *  Switch generated from: '<S237>/Switch1'
           */
          app_B.t_Ax_Extrem2_cz = rtb_Vx_Extrem2_New_ej;
        } else {
          /* Switch generated from: '<S237>/Switch1' incorporates:
           *  Switch generated from: '<S316>/Switch1'
           */
          app_B.t_Ax_Extrem2_cz = rtb_t_Vx_Extrem2_New_pk;
        }
      }

      /* Sum: '<S237>/Add5' incorporates:
       *  Inport: '<Root>/Obj_01_v'
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_B.Longt_Dist_C1 = rtb_uDLookupTable5_h + arg_Obj_01_v;

      /* SignalConversion generated from: '<S237>/Traj_Coff_Batch_Out' */
      app_B.Longt_Dist_C0 = app_DW.UnitDelay_DSTATE_i5;

      /* SignalConversion generated from: '<S237>/Traj_Coff_Batch_Out' */
      app_B.Traj_Rel_C0 = rtb_ACC_t_FTCDsrdDistLv1_sg;

      /* SignalConversion generated from: '<S237>/Traj_Coff_Batch_Out' incorporates:
       *  UnitDelay generated from: '<S140>/Unit Delay4'
       */
      app_B.Traj_Rel_C1 = rtb_uDLookupTable5_h;

      /* Product: '<S237>/Divide4' incorporates:
       *  Constant: '<S237>/Constant4'
       *  Product: '<S237>/Divide5'
       */
      app_B.Longt_Dist_C2 = rtb_t_min / 2.0F;

      /* Product: '<S237>/Divide5' */
      app_B.Traj_Rel_C2 = app_B.Longt_Dist_C2;

      /* End of Outputs for SubSystem: '<S140>/Longt_Dist_RePlan' */

      /* Outputs for Function Call SubSystem: '<S140>/Longt_Dist_Keep' */
      app_Longt_Dist_Keep(app_B.t_end_mp, app_B.Traj_Rel_C0, app_B.Traj_Rel_C1,
                          app_B.Traj_Rel_C2, app_B.Traj_Rel_C3,
                          app_B.Traj_Rel_C4, app_B.Traj_Rel_C5,
                          app_B.Longt_Dist_C0, app_B.Longt_Dist_C1,
                          app_B.Longt_Dist_C2, app_B.Longt_Dist_C3,
                          app_B.Longt_Dist_C4, app_B.Longt_Dist_C5, rtb_OR_f,
                          &rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_uDLookupTable5_h,
                          &Opt, &c3, &app_DW.UnitDelay4_7_DSTATE, &c4, &c5,
                          &t_Ax_Extrem1, &t_Ax_Extrem2, &t_Jerk_Extrem,
                          &Ax_Extrem1, &Ax_Extrem2, &Jerk_Extrem, &ax_Max_Traj,
                          &app_ConstB.Longt_Dist_Keep, &app_DW.Longt_Dist_Keep);

      /* End of Outputs for SubSystem: '<S140>/Longt_Dist_Keep' */
    } else {
      /* Outputs for Function Call SubSystem: '<S140>/Longt_Dist_Keep' */
      app_Longt_Dist_Keep(app_B.t_end_mp, app_B.Traj_Rel_C0, app_B.Traj_Rel_C1,
                          app_B.Traj_Rel_C2, app_B.Traj_Rel_C3,
                          app_B.Traj_Rel_C4, app_B.Traj_Rel_C5,
                          app_B.Longt_Dist_C0, app_B.Longt_Dist_C1,
                          app_B.Longt_Dist_C2, app_B.Longt_Dist_C3,
                          app_B.Longt_Dist_C4, app_B.Longt_Dist_C5, rtb_OR_f,
                          &rtb_ACC_t_FTCDsrdDistLv1_sg, &rtb_uDLookupTable5_h,
                          &Opt, &c3, &app_DW.UnitDelay4_7_DSTATE, &c4, &c5,
                          &t_Ax_Extrem1, &t_Ax_Extrem2, &t_Jerk_Extrem,
                          &Ax_Extrem1, &Ax_Extrem2, &Jerk_Extrem, &ax_Max_Traj,
                          &app_ConstB.Longt_Dist_Keep, &app_DW.Longt_Dist_Keep);

      /* End of Outputs for SubSystem: '<S140>/Longt_Dist_Keep' */
    }

    /* End of Chart: '<S140>/TRP_Scheduling' */

    /* Switch: '<S139>/Switch' incorporates:
     *  Constant: '<S139>/Constant2'
     *  Constant: '<S139>/Constant4'
     *  Delay: '<S139>/Delay'
     *  Delay: '<S139>/Delay1'
     *  RelationalOperator: '<S139>/Relational Operator2'
     *  RelationalOperator: '<S139>/Relational Operator3'
     *  Switch: '<S139>/Switch1'
     */
    if ((int32_T)app_DW.Delay_DSTATE_ne == 1) {
      /* Switch: '<S495>/Switch2' incorporates:
       *  Switch: '<S495>/Switch3'
       */
      if (rtb_DFIn_is_AEBPStsDsbl_bl) {
        /* Lookup_n-D: '<S495>/n-D Lookup Table3' incorporates:
         *  DataTypeConversion: '<S1060>/Data Type Conversion7'
         *  Lookup_n-D: '<S495>/n-D Lookup Table4'
         *  Sum: '<S495>/Minus'
         *  UnaryMinus: '<S495>/Unary Minus1'
         *  UnitDelay: '<S1060>/spdD3'
         */
        Switch = look1_iflf_binlxpw(-((real32_T)app_DW.spdD3_DSTATE - Switch),
          app_ConstP.pooled51, app_ConstP.pooled50, 30U);

        /* Switch: '<S139>/Switch' incorporates:
         *  Constant: '<S158>/k_j_ActvAccJerkMin_sg'
         *  Constant: '<S92>/Constant18'
         *  DataTypeConversion: '<S1060>/Data Type Conversion7'
         *  Lookup_n-D: '<S158>/1-D Lookup Table'
         *  Lookup_n-D: '<S495>/n-D Lookup Table3'
         *  Lookup_n-D: '<S495>/n-D Lookup Table5'
         *  MinMax: '<S158>/MinMax'
         *  MinMax: '<S495>/Max2'
         *  MinMax: '<S495>/Min2'
         *  MinMax: '<S495>/Min3'
         *  Switch: '<S158>/Switch'
         *  UnitDelay: '<S1060>/spdD3'
         */
        app_B.Switch_a[2] = fmaxf(fmaxf(fmaxf(fmaxf(-30.0F,
          app_ConstB.MultiportSwitch_l), rtb_a_traj_FEMid), 3.0F), Switch);
        app_B.Switch_a[3] = fminf(rtb_MinMax_a0, fminf(Switch,
          look1_iflf_binlxpw((real32_T)app_DW.spdD3_DSTATE, app_ConstP.pooled52,
                             app_ConstP.nDLookupTable5_tableData, 15U)));
      } else {
        /* Switch: '<S139>/Switch' incorporates:
         *  Constant: '<S158>/k_j_ActvAccJerkMin_sg'
         *  Constant: '<S92>/Constant18'
         *  Lookup_n-D: '<S158>/1-D Lookup Table'
         *  MinMax: '<S158>/MinMax'
         *  Switch: '<S158>/Switch'
         */
        app_B.Switch_a[2] = fmaxf(fmaxf(fmaxf(-30.0F,
          app_ConstB.MultiportSwitch_l), rtb_a_traj_FEMid), 3.0F);
        app_B.Switch_a[3] = rtb_MinMax_a0;
      }

      /* End of Switch: '<S495>/Switch2' */

      /* Switch: '<S139>/Switch' incorporates:
       *  Delay: '<S176>/Resettable Delay'
       *  Sum: '<S141>/Subtract'
       */
      app_B.Switch_a[0] = rtb_a_Min_Modify;
      app_B.Switch_a[1] = rtb_a_Max_Modify;
      app_B.Switch_a[4] = s_traj_real_Spd;
      app_B.Switch_a[5] = v_traj_real_Spd;
      app_B.Switch_a[6] = rtb_ACC_t_FTCDsrdDistLv2_sg;
      app_B.Switch_a[7] = Longt_Spd_C0;
      app_B.Switch_a[8] = Longt_Spd_C1;
      app_B.Switch_a[9] = rtb_Product_eqe;
      app_B.Switch_a[10] = nDLookupTable1;
      app_B.Switch_a[11] = rtb_Switch_ik;
      app_B.Switch_a[12] = rtb_Switch_ai;
      app_B.Switch_a[13] = t_end;
      app_B.Switch_a[14] = a_traj_real_Spd_PrdtOneStp;
      app_B.Switch_a[15] = s_traj_real_Spd - app_DW.ResettableDelay_DSTATE_d;
      app_B.Switch_a[16] = Merge3;
    } else if ((int32_T)app_DW.Delay1_DSTATE_b == 2) {
      /* Switch: '<S139>/Switch' incorporates:
       *  Delay: '<S176>/Resettable Delay'
       *  Sum: '<S140>/Subtract'
       *  Switch: '<S139>/Switch1'
       */
      app_B.Switch_a[0] = rtb_Add_g0;
      app_B.Switch_a[1] = rtb_Product_iz;
      app_B.Switch_a[2] = j_traj_real_Spd;
      app_B.Switch_a[3] = LimitationViolate;
      app_B.Switch_a[4] = c5;
      app_B.Switch_a[5] = t_Ax_Extrem1;
      app_B.Switch_a[6] = t_Ax_Extrem2;
      app_B.Switch_a[7] = app_B.Longt_Dist_C0;
      app_B.Switch_a[8] = app_B.Longt_Dist_C1;
      app_B.Switch_a[9] = app_B.Longt_Dist_C2;
      app_B.Switch_a[10] = app_B.Longt_Dist_C3;
      app_B.Switch_a[11] = app_B.Longt_Dist_C4;
      app_B.Switch_a[12] = app_B.Longt_Dist_C5;
      app_B.Switch_a[13] = app_B.t_end_mp;
      app_B.Switch_a[14] = Jerk_Extrem;
      app_B.Switch_a[15] = c5 - app_DW.ResettableDelay_DSTATE_d;
      app_B.Switch_a[16] = app_DW.UnitDelay4_7_DSTATE;
    } else {
      /* Switch: '<S139>/Switch' incorporates:
       *  Switch: '<S139>/Switch1'
       */
      memset(&app_B.Switch_a[0], 0, (uint32_T)(17U * sizeof(real32_T)));
    }

    /* End of Switch: '<S139>/Switch' */

    /* SignalConversion generated from: '<S92>/Longt_C1' */
    app_B.Longt_C1 = app_B.Switch_a[8];

    /* SignalConversion generated from: '<S92>/Longt_C2' */
    app_B.Longt_C2 = app_B.Switch_a[9];

    /* SignalConversion generated from: '<S92>/Longt_C3' */
    app_B.Longt_C3 = app_B.Switch_a[10];

    /* SignalConversion generated from: '<S92>/Longt_C4' */
    app_B.Longt_C4 = app_B.Switch_a[11];

    /* SignalConversion generated from: '<S92>/Longt_C5' */
    app_B.Longt_C5 = app_B.Switch_a[12];

    /* SignalConversion: '<S137>/Signal Copy1' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  SignalConversion: '<S911>/Signal Copy2'
     */
    m_dst_red = rtb_uDLookupTable;

    /* Outputs for Atomic SubSystem: '<S187>/LowPass_Filter' */
    /* Inport: '<Root>/Obj_01_a' */
    app_LowPass_Filter(arg_Obj_01_a, &rtb_ARB_F_PCTWhlDrvnToq_sg,
                       &app_DW.LowPass_Filter, 5.0F, 20.0F);

    /* End of Outputs for SubSystem: '<S187>/LowPass_Filter' */

    /* Outputs for Atomic SubSystem: '<S187>/LowPass_Filter1' */
    /* DataTypeConversion: '<S1023>/Data Type Conversion30' */
    app_LowPass_Filter(rtb_Gain5_i, &rtb_ARB_F_PCTWhlDrvnToq_sg,
                       &app_DW.LowPass_Filter1, 5.0F, 20.0F);

    /* End of Outputs for SubSystem: '<S187>/LowPass_Filter1' */

    /* MATLAB Function: '<S139>/MATLAB Function2' */
    Switch = app_DW.UnitDelay4_7_DSTATE;
    if (app_DW.UnitDelay4_7_DSTATE >= app_B.t_end_mp) {
      Switch = app_B.t_end_mp;
    }

    for (i_0 = 0; i_0 < 61; i_0++) {
      tFEBig[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Switch);
    }

    for (i_0 = 0; i_0 < 41; i_0++) {
      tFEMid[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Switch);
    }

    for (i_0 = 0; i_0 < 21; i_0++) {
      tFESml[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Switch);
    }

    rtb_Add_g0 = 2.0F * app_B.Longt_Dist_C2;
    rtb_ACC_t_FTCDsrdDistLv1_sg = 6.0F * app_B.Longt_Dist_C3;
    rtb_uDLookupTable5_h = 12.0F * app_B.Longt_Dist_C4;
    rtb_Product_iz = 20.0F * app_B.Longt_Dist_C5;
    for (i_0 = 0; i_0 < 61; i_0++) {
      rtb_Add12 = tFEBig[i_0];
      x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 + rtb_Add_g0)
                + (real32_T)(rtb_Add12 * rtb_Add12) * rtb_uDLookupTable5_h) +
        rtb_Product_iz * (real32_T)rt_powd_snf(rtb_Add12, 3.0);
    }

    Switch = x[0];
    for (i_0 = 0; i_0 < 60; i_0++) {
      Switch += x[(int32_T)(i_0 + 1)];
    }

    for (i_0 = 0; i_0 < 41; i_0++) {
      rtb_Add12 = tFEMid[i_0];
      b_x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 +
                   rtb_Add_g0) + (real32_T)(rtb_Add12 * rtb_Add12) *
                  rtb_uDLookupTable5_h) + rtb_Product_iz * (real32_T)rt_powd_snf
        (rtb_Add12, 3.0);
    }

    rtb_a_traj_FEMid = b_x[0];
    for (i_0 = 0; i_0 < 40; i_0++) {
      rtb_a_traj_FEMid += b_x[(int32_T)(i_0 + 1)];
    }

    for (i_0 = 0; i_0 < 21; i_0++) {
      rtb_Add12 = tFESml[i_0];
      c_x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 +
                   rtb_Add_g0) + (real32_T)(rtb_Add12 * rtb_Add12) *
                  rtb_uDLookupTable5_h) + rtb_Product_iz * (real32_T)rt_powd_snf
        (rtb_Add12, 3.0);
    }

    rtb_MinMax_a0 = c_x[0];
    for (i_0 = 0; i_0 < 20; i_0++) {
      rtb_MinMax_a0 += c_x[(int32_T)(i_0 + 1)];
    }

    /* MATLAB Function: '<S139>/MATLAB Function1' */
    if (Merge3 >= t_end) {
      Merge3 = t_end;
    }

    for (i_0 = 0; i_0 < 61; i_0++) {
      tFEBig[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Merge3);
    }

    for (i_0 = 0; i_0 < 41; i_0++) {
      tFEMid[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Merge3);
    }

    for (i_0 = 0; i_0 < 21; i_0++) {
      tFESml[i_0] = (real_T)((((real32_T)i_0 + 1.0F) - 1.0F) * 0.05F + Merge3);
    }

    rtb_Add_g0 = 2.0F * rtb_Product_eqe;
    rtb_ACC_t_FTCDsrdDistLv1_sg = 6.0F * nDLookupTable1;
    rtb_uDLookupTable5_h = 12.0F * rtb_Switch_ik;
    rtb_Product_iz = 20.0F * rtb_Switch_ai;
    for (i_0 = 0; i_0 < 61; i_0++) {
      rtb_Add12 = tFEBig[i_0];
      x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 + rtb_Add_g0)
                + (real32_T)(rtb_Add12 * rtb_Add12) * rtb_uDLookupTable5_h) +
        rtb_Product_iz * (real32_T)rt_powd_snf(rtb_Add12, 3.0);
    }

    rtb_Product_eqe = x[0];
    for (i_0 = 0; i_0 < 60; i_0++) {
      rtb_Product_eqe += x[(int32_T)(i_0 + 1)];
    }

    for (i_0 = 0; i_0 < 41; i_0++) {
      rtb_Add12 = tFEMid[i_0];
      b_x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 +
                   rtb_Add_g0) + (real32_T)(rtb_Add12 * rtb_Add12) *
                  rtb_uDLookupTable5_h) + rtb_Product_iz * (real32_T)rt_powd_snf
        (rtb_Add12, 3.0);
    }

    nDLookupTable1 = b_x[0];
    for (i_0 = 0; i_0 < 40; i_0++) {
      nDLookupTable1 += b_x[(int32_T)(i_0 + 1)];
    }

    for (i_0 = 0; i_0 < 21; i_0++) {
      rtb_Add12 = tFESml[i_0];
      c_x[i_0] = ((rtb_ACC_t_FTCDsrdDistLv1_sg * (real32_T)rtb_Add12 +
                   rtb_Add_g0) + (real32_T)(rtb_Add12 * rtb_Add12) *
                  rtb_uDLookupTable5_h) + rtb_Product_iz * (real32_T)rt_powd_snf
        (rtb_Add12, 3.0);
    }

    rtb_Add_g0 = c_x[0];
    for (i_0 = 0; i_0 < 20; i_0++) {
      rtb_Add_g0 += c_x[(int32_T)(i_0 + 1)];
    }

    /* Outputs for Atomic SubSystem: '<S139>/Trggr_Hyst' */
    /* Sum: '<S139>/Subtract1' incorporates:
     *  Constant: '<S139>/Constant27'
     *  Constant: '<S139>/Constant28'
     */
    app_Trggr_Hyst(Switch - rtb_Product_eqe, 0.2F, -0.2F,
                   &rtb_DFIn_is_AEBPStsDsbl_bl, &app_DW.Trggr_Hyst);

    /* End of Outputs for SubSystem: '<S139>/Trggr_Hyst' */

    /* Outputs for Atomic SubSystem: '<S139>/Trggr_Hyst1' */
    /* Sum: '<S139>/Subtract2' incorporates:
     *  Constant: '<S139>/Constant32'
     *  Constant: '<S139>/Constant33'
     */
    app_Trggr_Hyst(rtb_a_traj_FEMid - nDLookupTable1, 0.1F, -0.1F,
                   &rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m, &app_DW.Trggr_Hyst1);

    /* End of Outputs for SubSystem: '<S139>/Trggr_Hyst1' */

    /* Outputs for Atomic SubSystem: '<S139>/Trggr_Hyst2' */
    /* Sum: '<S139>/Subtract3' incorporates:
     *  Constant: '<S139>/Constant1'
     *  Constant: '<S139>/Constant3'
     *  MATLAB Function: '<S139>/MATLAB Function1'
     *  MATLAB Function: '<S139>/MATLAB Function2'
     */
    app_Trggr_Hyst(rtb_MinMax_a0 / 21.0F - rtb_Add_g0 / 21.0F, 0.1F, -0.1F,
                   &rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d, &app_DW.Trggr_Hyst2);

    /* End of Outputs for SubSystem: '<S139>/Trggr_Hyst2' */

    /* Switch: '<S139>/Switch13' */
    if (longt_out_isCtrlEngage) {
      /* Switch: '<S139>/Switch9' incorporates:
       *  Logic: '<S139>/AND4'
       *  Logic: '<S139>/NOT3'
       *  Switch: '<S139>/Switch10'
       *  Switch: '<S175>/Switch3'
       */
      if (!rtb_DFIn_is_AEBStsDsbl_bl) {
        /* Switch: '<S139>/Switch13' incorporates:
         *  Constant: '<S139>/Constant22'
         */
        m_Followed_Traj = 1U;
      } else if (rtb_DFIn_is_AEBPStsDsbl_bl || rtb_DFIn_is_ACCDrvrDoorEnbl_bl_m ||
                 rtb_DFIn_is_CCFM_FrDoorDsbl_bl_d) {
        /* Switch: '<S139>/Switch10' incorporates:
         *  Constant: '<S139>/Constant25'
         *  Switch: '<S139>/Switch13'
         */
        m_Followed_Traj = 1U;
      } else {
        /* Switch: '<S139>/Switch13' incorporates:
         *  Constant: '<S139>/Constant24'
         *  Switch: '<S139>/Switch10'
         */
        m_Followed_Traj = 2U;
      }

      /* End of Switch: '<S139>/Switch9' */
    } else {
      /* Switch: '<S139>/Switch13' incorporates:
       *  Constant: '<S139>/Constant23'
       */
      m_Followed_Traj = 0U;
    }

    /* End of Switch: '<S139>/Switch13' */

    /* Constant: '<S226>/Constant4' */
    rtb_ARB_F_PCTWhlDrvnToq_sg = (real32_T)k_TRPLon_is_UsePrdctTime_bl;

    /* Switch: '<S226>/Switch1' incorporates:
     *  Constant: '<S226>/Constant2'
     *  Constant: '<S226>/Constant3'
     *  Constant: '<S226>/Constant4'
     *  Logic: '<S226>/NOT'
     *  Product: '<S226>/Product'
     *  Sum: '<S226>/Add3'
     */
    if (!k_TRPLon_is_UsePrdctTime_bl) {
      Switch = app_B.Switch_a[16];
    } else {
      Switch = 0.05F * k_TRPLon_Gx_PrdctTime_sg + app_B.Switch_a[16];
    }

    /* End of Switch: '<S226>/Switch1' */

    /* MATLAB Function: '<S139>/MATLAB Function3' */
    if (Switch >= app_B.Switch_a[13]) {
      Switch = app_B.Switch_a[13];
    }

    /* Switch: '<S139>/Switch3' incorporates:
     *  Constant: '<S139>/Constant10'
     *  Constant: '<S139>/Constant11'
     *  Delay: '<S139>/Delay3'
     *  MATLAB Function: '<S139>/MATLAB Function3'
     *  Product: '<S139>/Product1'
     *  RelationalOperator: '<S139>/Relational Operator6'
     */
    if ((int32_T)app_DW.Delay3_DSTATE_p == 1) {
      rtb_Product_eqe = (((6.0F * app_B.Switch_a[10] * Switch + 2.0F *
                           app_B.Switch_a[9]) + 12.0F * app_B.Switch_a[11] *
                          (Switch * Switch)) + 20.0F * app_B.Switch_a[12] *
                         rt_powf_snf(Switch, 3.0F)) * k_TRPLon_Gx_aStateGain_sg;
    } else {
      rtb_Product_eqe = ((6.0F * app_B.Switch_a[10] * Switch + 2.0F *
                          app_B.Switch_a[9]) + 12.0F * app_B.Switch_a[11] *
                         (Switch * Switch)) + 20.0F * app_B.Switch_a[12] *
        rt_powf_snf(Switch, 3.0F);
    }

    /* End of Switch: '<S139>/Switch3' */

    /* Outputs for Atomic SubSystem: '<S139>/LowPass_Filter' */
    app_LowPass_Filter(rtb_Product_eqe, &rtb_ARB_F_PCTWhlDrvnToq_sg,
                       &app_DW.LowPass_Filter_b, 5.0F, 20.0F);

    /* End of Outputs for SubSystem: '<S139>/LowPass_Filter' */

    /* Logic: '<S139>/OR' incorporates:
     *  Constant: '<S139>/Constant6'
     *  Constant: '<S139>/Constant7'
     *  Logic: '<S139>/AND'
     *  Logic: '<S139>/AND1'
     *  Logic: '<S501>/Logical Operator4'
     *  RelationalOperator: '<S139>/Relational Operator4'
     *  RelationalOperator: '<S139>/Relational Operator5'
     */
    app_B.OR_e = (((rtb_LogicalOperator9_kf || rtb_SeatBeltOn_o ||
                    rtb_Compare_hj) && ((int32_T)m_Followed_Traj == 1)) ||
                  (rtb_OR_f && ((int32_T)m_Followed_Traj == 2)));

    /* Switch: '<S139>/Switch2' incorporates:
     *  Constant: '<S139>/Constant'
     *  Constant: '<S139>/Constant8'
     *  Delay: '<S139>/Delay2'
     *  Product: '<S139>/Product'
     *  RelationalOperator: '<S139>/Relational Operator1'
     *  UnitDelay: '<S92>/Unit Delay2'
     */
    if ((int32_T)app_DW.Delay2_DSTATE_p == 1) {
      app_DW.UnitDelay2_DSTATE_p = k_TRPLon_Gx_aStateGain_sg * app_B.Switch_a[6];
    } else {
      app_DW.UnitDelay2_DSTATE_p = app_B.Switch_a[6];
    }

    /* End of Switch: '<S139>/Switch2' */

    /* Chart: '<S483>/Chart1' incorporates:
     *  Constant: '<S483>/Constant2'
     *  Constant: '<S483>/Constant4'
     */
    app_Chart1(false, 2.0F, 0.05F, &rtb_DFIn_is_AEBStsDsbl_bl,
               &app_DW.sf_Chart1_g);

    /* Switch: '<S498>/Switch' incorporates:
     *  Constant: '<S498>/k_cof_PLN_AccCtrlOvrshtTolrCof_sg'
     *  Constant: '<S498>/k_cof_PLN_DccCtrlOvrshtTolrCof_sg'
     *  Logic: '<S498>/Logical Operator1'
     *  Product: '<S498>/Product'
     *  Product: '<S498>/Product1'
     *  RelationalOperator: '<S498>/Relational Operator4'
     *  RelationalOperator: '<S498>/Relational Operator7'
     *  Sum: '<S498>/Add2'
     *  Sum: '<S498>/Add3'
     *  UnitDelay: '<S500>/Unit Delay'
     */
    app_DW.UnitDelay_DSTATE_fl = ((rtb_ACC_t_FTCDsrdDistLv2_sg <
      rtb_a_Min_Modify * 0.2F + rtb_a_Min_Modify) || (rtb_a_Max_Modify * 0.2F +
      rtb_a_Max_Modify < rtb_ACC_t_FTCDsrdDistLv2_sg));

    /* Sum: '<S137>/Subtract1' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  SignalConversion: '<S911>/Signal Copy2'
     */
    m_dst_desire = rtb_uDLookupTable - m_dst_target;

    /* Update for Delay: '<S150>/Resettable Delay' */
    app_DW.icLoad_bl = 0U;
    app_DW.ResettableDelay_DSTATE = rtb_ACC_v_ACCSetSpd_sg;

    /* Update for UnitDelay: '<S168>/Delay Input1'
     *
     * Block description for '<S168>/Delay Input1':
     *
     *  Store in Global RAM
     */
    app_DW.DelayInput1_DSTATE_on = longt_out_isCtrlEngage;

    /* Update for UnitDelay: '<S167>/Delay Input1' incorporates:
     *  Constant: '<S92>/Constant3'
     *
     * Block description for '<S167>/Delay Input1':
     *
     *  Store in Global RAM
     */
    app_DW.DelayInput1_DSTATE = 1.0F;

    /* Update for Delay: '<S144>/Resettable Delay1' */
    app_DW.icLoad_m = 0U;
    app_DW.ResettableDelay1_DSTATE = rtb_DFIn_is_EPBAppcnStsApp_bl;

    /* Update for Delay: '<S185>/Resettable Delay2' incorporates:
     *  BusAssignment: '<S5>/Bus Assignment'
     *  SignalConversion: '<S911>/Signal Copy4'
     */
    app_DW.icLoad_l4 = 0U;
    app_DW.ResettableDelay2_DSTATE_l = rtb_out_cond_n3;

    /* Update for Delay: '<S200>/Resettable Delay' */
    app_DW.icLoad_ba = 0U;
    app_DW.ResettableDelay_DSTATE_ll = rtb_MinMax1_p;

    /* Update for Delay: '<S202>/Resettable Delay' */
    app_DW.icLoad_en = 0U;
    app_DW.ResettableDelay_DSTATE_h = rtb_DFIn_is_EPBAppcnStsApp_bl;

    /* Update for Delay: '<S144>/Resettable Delay2' */
    app_DW.icLoad_g5 = 0U;
    app_DW.ResettableDelay2_DSTATE = rtb_Switch_jk;

    /* Update for Delay: '<S144>/Resettable Delay4' incorporates:
     *  UnitDelay: '<S151>/Unit Delay'
     */
    app_DW.icLoad_cbj = 0U;
    app_DW.ResettableDelay4_DSTATE = app_DW.UnitDelay_DSTATE_g;

    /* Update for Delay: '<S144>/Resettable Delay5' incorporates:
     *  UnitDelay: '<S152>/Unit Delay'
     */
    app_DW.icLoad_cj = 0U;
    app_DW.ResettableDelay5_DSTATE = app_DW.UnitDelay_DSTATE_l;

    /* Update for UnitDelay: '<S501>/Unit Delay3' incorporates:
     *  UnitDelay: '<S500>/Unit Delay'
     */
    app_DW.UnitDelay3_DSTATE_o = app_DW.UnitDelay_DSTATE_fl;

    /* Update for Delay: '<S497>/Resettable Delay' incorporates:
     *  DataTypeConversion: '<S497>/Data Type Conversion1'
     */
    app_DW.icLoad_g53 = 0U;
    app_DW.ResettableDelay_DSTATE_g = (uint8_T)DFIn_a_EstdVSELongtAccel_sg;

    /* Update for UnitDelay: '<S504>/Delay Input1'
     *
     * Block description for '<S504>/Delay Input1':
     *
     *  Store in Global RAM
     */
    app_DW.DelayInput1_DSTATE_mr = P_ACC_V_MaxCrsSpdThrs_u8;

    /* Update for UnitDelay: '<S501>/Unit Delay4' */
    app_DW.UnitDelay4_DSTATE = m_TRP_Replan_Level_Spd;

    /* Update for UnitDelay: '<S176>/Unit Delay' incorporates:
     *  Delay: '<S176>/Resettable Delay'
     */
    app_DW.UnitDelay_DSTATE_p = app_DW.ResettableDelay_DSTATE_d;

    /* Update for Switch: '<S176>/Switch' incorporates:
     *  UnitDelay: '<S92>/Unit Delay'
     *  UnitDelay: '<S92>/Unit Delay1'
     */
    app_DW.UnitDelay_DSTATE_i5 = app_B.Switch_a[4];
    app_DW.UnitDelay1_DSTATE_c = app_B.Switch_a[5];

    /* Update for Delay: '<S139>/Delay' */
    app_DW.Delay_DSTATE_ne = m_Followed_Traj;

    /* Update for UnitDelay: '<S483>/Unit Delay' incorporates:
     *  UnitDelay: '<S137>/Unit Delay3'
     */
    app_DW.UnitDelay_DSTATE_ie = app_DW.UnitDelay3_DSTATE;

    /* Update for UnitDelay: '<S137>/Unit Delay3' */
    app_DW.UnitDelay3_DSTATE = m_Followed_Traj;

    /* Update for UnitDelay generated from: '<S140>/Unit Delay4' */
    app_DW.UnitDelay4_1_DSTATE = rtb_t_min;

    /* Update for UnitDelay: '<S140>/Unit Delay5' */
    app_DW.UnitDelay5_DSTATE_e = app_DW.UnitDelay4_7_DSTATE;

    /* Update for UnitDelay: '<S137>/Unit Delay2' */
    app_DW.UnitDelay2_DSTATE_b = app_B.Switch_a[14];

    /* Update for Delay: '<S139>/Delay1' */
    app_DW.Delay1_DSTATE_b = m_Followed_Traj;

    /* Update for Delay: '<S139>/Delay2' */
    app_DW.Delay2_DSTATE_p = m_Followed_Traj;

    /* Update for Delay: '<S139>/Delay3' */
    app_DW.Delay3_DSTATE_p = m_Followed_Traj;
  }

  /* End of Outputs for SubSystem: '<S3>/Subsystem' */

  /* RelationalOperator: '<S115>/FixPt Relational Operator' incorporates:
   *  UnitDelay: '<S115>/Delay Input1'
   *
   * Block description for '<S115>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_DFIn_is_AEBStsDsbl_bl = ((int32_T)app_B.OR_e > (int32_T)
    app_DW.DelayInput1_DSTATE_d);

  /* Delay: '<S101>/Delay' */
  if (rtb_DFIn_is_AEBStsDsbl_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE != 1))
  {
    app_DW.Delay_DSTATE_j0 = 0.0F;
  }

  app_PrevZCX.Delay_Reset_ZCE = (ZCSigState)rtb_DFIn_is_AEBStsDsbl_bl;

  /* Switch: '<S101>/Switch' incorporates:
   *  Constant: '<S101>/Constant'
   *  Constant: '<S101>/Constant1'
   *  Constant: '<S90>/preview_time'
   *  Delay: '<S101>/Delay'
   *  Delay: '<S97>/Delay'
   *  MATLAB Function: '<S90>/MATLAB Function1'
   *  MATLAB Function: '<S90>/MATLAB Function2'
   *  SignalConversion generated from: '<S100>/ SFunction '
   *  Sum: '<S101>/Add'
   *  Sum: '<S90>/Add'
   *  Switch: '<S97>/Switch'
   */
  if (longt_out_isCtrlEngage) {
    app_DW.Delay_DSTATE_j0 += 0.02F;
    app_DW.Delay_DSTATE_e = (((2.0F * app_B.Longt_C2 * (app_DW.Delay_DSTATE_j0 +
      0.6F) + app_B.Longt_C1) + 3.0F * app_B.Longt_C3 * (app_DW.Delay_DSTATE_j0
      + 0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F)) + 4.0F * app_B.Longt_C4 *
      (app_DW.Delay_DSTATE_j0 + 0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F) *
      (app_DW.Delay_DSTATE_j0 + 0.6F)) + 5.0F * app_B.Longt_C5 *
      (app_DW.Delay_DSTATE_j0 + 0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F) *
      (app_DW.Delay_DSTATE_j0 + 0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F);
  } else {
    app_DW.Delay_DSTATE_j0 = 0.0F;
  }

  /* End of Switch: '<S101>/Switch' */

  /* Chart: '<S97>/Chart' */
  app_Chart(longt_out_isCtrlEngage, &app_B.ramp_cof_n, &app_DW.sf_Chart_l);

  /* Saturate: '<S97>/Saturation1' */
  if (app_B.ramp_cof_n > 1.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 1.0F;
  } else if (app_B.ramp_cof_n < 0.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = app_B.ramp_cof_n;
  }

  /* End of Saturate: '<S97>/Saturation1' */

  /* Sum: '<S97>/Sum' incorporates:
   *  Constant: '<S97>/Constant'
   *  DataTypeConversion: '<S1060>/Data Type Conversion7'
   *  Delay: '<S97>/Delay'
   *  Product: '<S97>/Product'
   *  Product: '<S97>/Product1'
   *  Sum: '<S97>/Add'
   *  Sum: '<S97>/Subtract'
   *  UnitDelay: '<S1060>/spdD3'
   */
  rtb_ACC_v_ACCSetSpd_sg = ((1.0F - DFIn_a_EstdVSELongtAccel_sg) * (real32_T)
    app_DW.spdD3_DSTATE + app_DW.Delay_DSTATE_e * DFIn_a_EstdVSELongtAccel_sg) -
    (real32_T)app_DW.spdD3_DSTATE;

  /* Switch: '<S105>/Switch2' incorporates:
   *  Constant: '<S97>/Constant1'
   *  RelationalOperator: '<S105>/LowerRelop1'
   *  RelationalOperator: '<S105>/UpperRelop'
   *  Switch: '<S105>/Switch'
   */
  if (rtb_ACC_v_ACCSetSpd_sg > 5.0F) {
    rtb_ACC_v_ACCSetSpd_sg = 5.0F;
  } else {
    if (rtb_ACC_v_ACCSetSpd_sg < app_ConstB.UnaryMinus_m) {
      /* Switch: '<S105>/Switch' */
      rtb_ACC_v_ACCSetSpd_sg = app_ConstB.UnaryMinus_m;
    }
  }

  /* End of Switch: '<S105>/Switch2' */

  /* Gain: '<S90>/Gain' incorporates:
   *  DataTypeConversion: '<S1060>/Data Type Conversion7'
   *  UnitDelay: '<S1060>/spdD3'
   */
  DFIn_a_EstdVSELongtAccel_sg = 3.6F * (real32_T)app_DW.spdD3_DSTATE;

  /* Product: '<S107>/Product2' incorporates:
   *  Gain: '<S1146>/Gain9'
   *  Lookup_n-D: '<S97>/KP_loTable'
   */
  rtb_a_Min_Modify = rtb_ACC_v_ACCSetSpd_sg * look1_iflf_binlxpw
    (DFIn_a_EstdVSELongtAccel_sg, app_ConstP.pooled113,
     app_ConstP.KP_loTable_tableData, 6U);

  /* Switch: '<S104>/Switch' */
  if (longt_out_isCtrlEngage) {
    /* Switch: '<S104>/Switch2' incorporates:
     *  Constant: '<S112>/Constant'
     *  Delay: '<S97>/Delay1'
     *  Product: '<S104>/Product1'
     *  RelationalOperator: '<S112>/Compare'
     *  Switch: '<S104>/Switch3'
     */
    if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
      /* Switch: '<S104>/Switch' incorporates:
       *  Constant: '<S104>/Constant3'
       */
      app_DW.Delay1_DSTATE_m = 0.0F;
    } else {
      if (rtb_ACC_v_ACCSetSpd_sg * app_DW.Delay1_DSTATE_m > 0.0F) {
        /* Switch: '<S104>/Switch3' incorporates:
         *  Gain: '<S1146>/Gain9'
         *  Lookup_n-D: '<S97>/KI_loTable'
         */
        DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlxpw
          (DFIn_a_EstdVSELongtAccel_sg, app_ConstP.pooled113,
           app_ConstP.pooled94, 6U);
      } else {
        /* Switch: '<S104>/Switch3' incorporates:
         *  Gain: '<S104>/Gain'
         *  Gain: '<S1146>/Gain9'
         *  Lookup_n-D: '<S97>/KI_loTable'
         */
        DFIn_a_EstdVSELongtAccel_sg = 3.0F * look1_iflf_binlxpw
          (DFIn_a_EstdVSELongtAccel_sg, app_ConstP.pooled113,
           app_ConstP.pooled94, 6U);
      }

      /* Sum: '<S104>/Add' incorporates:
       *  Constant: '<S104>/Constant'
       *  Delay: '<S97>/Delay1'
       *  Product: '<S104>/Product'
       */
      DFIn_a_EstdVSELongtAccel_sg = rtb_ACC_v_ACCSetSpd_sg *
        DFIn_a_EstdVSELongtAccel_sg * 0.02F + app_DW.Delay1_DSTATE_m;

      /* Switch: '<S104>/Switch1' incorporates:
       *  Constant: '<S108>/Constant'
       *  Constant: '<S109>/Constant'
       *  Constant: '<S110>/Constant'
       *  Constant: '<S111>/Constant'
       *  Constant: '<S97>/MaxAllowed_FBW_Item1'
       *  Delay: '<S97>/Delay2'
       *  Logic: '<S104>/Logical Operator'
       *  Logic: '<S104>/Logical Operator1'
       *  Logic: '<S104>/Logical Operator2'
       *  Logic: '<S104>/Logical Operator3'
       *  Logic: '<S104>/Logical Operator4'
       *  Logic: '<S104>/Logical Operator5'
       *  RelationalOperator: '<S104>/Relational Operator'
       *  RelationalOperator: '<S104>/Relational Operator1'
       *  RelationalOperator: '<S108>/Compare'
       *  RelationalOperator: '<S109>/Compare'
       *  RelationalOperator: '<S110>/Compare'
       *  RelationalOperator: '<S111>/Compare'
       */
      if (app_ConstB.LogicalOperator6 && (((rtb_ACC_v_ACCSetSpd_sg >= 0.0F) &&
            ((app_DW.Delay2_DSTATE_j < 0.25F) || (DFIn_a_EstdVSELongtAccel_sg <
              0.0F))) || ((rtb_ACC_v_ACCSetSpd_sg <= 0.0F) &&
                          ((app_DW.Delay2_DSTATE_j > app_ConstB.UnaryMinus1) ||
                           (DFIn_a_EstdVSELongtAccel_sg > 0.0F))))) {
        /* Switch: '<S104>/Switch' */
        app_DW.Delay1_DSTATE_m = DFIn_a_EstdVSELongtAccel_sg;
      }

      /* End of Switch: '<S104>/Switch1' */
    }

    /* End of Switch: '<S104>/Switch2' */
  } else {
    /* Switch: '<S104>/Switch' incorporates:
     *  Constant: '<S104>/Constant1'
     */
    app_DW.Delay1_DSTATE_m = 0.0F;
  }

  /* End of Switch: '<S104>/Switch' */

  /* Switch: '<S113>/Switch2' incorporates:
   *  Constant: '<S104>/Constant2'
   *  RelationalOperator: '<S113>/LowerRelop1'
   *  RelationalOperator: '<S113>/UpperRelop'
   *  Switch: '<S113>/Switch'
   */
  if (app_DW.Delay1_DSTATE_m > 0.2F) {
    /* Switch: '<S104>/Switch' */
    app_DW.Delay1_DSTATE_m = 0.2F;
  } else {
    if (app_DW.Delay1_DSTATE_m < app_ConstB.UnaryMinus) {
      /* Switch: '<S104>/Switch' incorporates:
       *  Switch: '<S113>/Switch'
       */
      app_DW.Delay1_DSTATE_m = app_ConstB.UnaryMinus;
    }
  }

  /* End of Switch: '<S113>/Switch2' */

  /* Switch: '<S114>/Switch2' incorporates:
   *  Constant: '<S107>/Constant1'
   *  RelationalOperator: '<S114>/LowerRelop1'
   *  RelationalOperator: '<S114>/UpperRelop'
   *  Switch: '<S114>/Switch'
   */
  if (rtb_a_Min_Modify > 0.2F) {
    rtb_a_Min_Modify = 0.2F;
  } else {
    if (rtb_a_Min_Modify < app_ConstB.UnaryMinus_g) {
      /* Switch: '<S114>/Switch' */
      rtb_a_Min_Modify = app_ConstB.UnaryMinus_g;
    }
  }

  /* End of Switch: '<S114>/Switch2' */

  /* Sum: '<S97>/Add1' incorporates:
   *  Delay: '<S97>/Delay1'
   */
  app_DW.Delay2_DSTATE_j = rtb_a_Min_Modify + app_DW.Delay1_DSTATE_m;

  /* Switch: '<S106>/Switch2' incorporates:
   *  Constant: '<S97>/MaxAllowed_FBW_Item'
   *  RelationalOperator: '<S106>/LowerRelop1'
   *  RelationalOperator: '<S106>/UpperRelop'
   *  Switch: '<S106>/Switch'
   */
  if (app_DW.Delay2_DSTATE_j > 0.5F) {
    /* Sum: '<S97>/Add1' */
    app_DW.Delay2_DSTATE_j = 0.5F;
  } else {
    if (app_DW.Delay2_DSTATE_j < app_ConstB.UnaryMinus1_i) {
      /* Sum: '<S97>/Add1' incorporates:
       *  Switch: '<S106>/Switch'
       */
      app_DW.Delay2_DSTATE_j = app_ConstB.UnaryMinus1_i;
    }
  }

  /* End of Switch: '<S106>/Switch2' */

  /* Sum: '<S90>/Add1' incorporates:
   *  Constant: '<S90>/preview_time'
   *  Delay: '<S101>/Delay'
   *  Delay: '<S97>/Delay2'
   *  MATLAB Function: '<S90>/MATLAB Function2'
   *  SignalConversion generated from: '<S100>/ SFunction '
   *  Sum: '<S90>/Add'
   */
  longt_out_desAccelCtrlCmd = (((6.0F * app_B.Longt_C3 * (app_DW.Delay_DSTATE_j0
    + 0.6F) + 2.0F * app_B.Longt_C2) + 48.0F * app_B.Longt_C4 *
    (app_DW.Delay_DSTATE_j0 + 0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F)) + 20.0F *
    app_B.Longt_C5 * (app_DW.Delay_DSTATE_j0 + 0.6F) * (app_DW.Delay_DSTATE_j0 +
    0.6F) * (app_DW.Delay_DSTATE_j0 + 0.6F)) + app_DW.Delay2_DSTATE_j;

  /* Chart: '<S133>/Transmisson_Gear_Ratio' */
  switch ((int32_T)rtb_DataTypeConversion37) {
   case 1:
    rtb_ACC_v_ACCSetSpd_sg = 12.306F;
    break;

   case 2:
    rtb_ACC_v_ACCSetSpd_sg = 7.298F;
    break;

   case 3:
    rtb_ACC_v_ACCSetSpd_sg = 5.242F;
    break;

   case 4:
    rtb_ACC_v_ACCSetSpd_sg = 4.244F;
    break;

   case 5:
    rtb_ACC_v_ACCSetSpd_sg = 3.237F;
    break;

   case 6:
    rtb_ACC_v_ACCSetSpd_sg = 2.658F;
    break;

   case 7:
    rtb_ACC_v_ACCSetSpd_sg = 2.583F;
    break;

   case 8:
    rtb_ACC_v_ACCSetSpd_sg = 2.583F;
    break;

   default:
    rtb_ACC_v_ACCSetSpd_sg = 12.306F;
    break;
  }

  /* End of Chart: '<S133>/Transmisson_Gear_Ratio' */

  /* RelationalOperator: '<S130>/FixPt Relational Operator' incorporates:
   *  DataTypeConversion: '<S121>/Data Type Conversion'
   *  UnitDelay: '<S130>/Delay Input1'
   *
   * Block description for '<S130>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_DFIn_is_EPBAppcnStsApp_bl = ((uint8_T)rtb_DataTypeConversion37 !=
    app_DW.DelayInput1_DSTATE_m);

  /* Chart: '<S131>/GainForStartStop' incorporates:
   *  Constant: '<S131>/RateLimiter'
   */
  if ((uint32_T)app_DW.is_active_c50_app == 0U) {
    app_DW.is_active_c50_app = 1U;
    app_DW.is_c50_app = app_IN_Initial;
    app_B.GainForStartStop_k = 1.0F;
  } else if ((int32_T)app_DW.is_c50_app == 1) {
    if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
      app_DW.is_c50_app = app_IN_Stop;
      app_DW.tp_Stop = 1U;
      app_B.GainForStartStop_k = 0.0F;
    }
  } else {
    /* case IN_Stop: */
    if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
      app_DW.is_c50_app = app_IN_Stop;
      app_DW.tp_Stop = 1U;
      app_B.GainForStartStop_k = 0.0F;
    } else if (app_B.GainForStartStop_k < 0.999F) {
      app_B.GainForStartStop_k += 0.01F;
    } else {
      app_B.GainForStartStop_k = 1.0F;
    }
  }

  /* End of Chart: '<S131>/GainForStartStop' */

  /* Saturate: '<S131>/Saturation' */
  if (app_B.GainForStartStop_k > 1.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 1.0F;
  } else if (app_B.GainForStartStop_k < 0.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = app_B.GainForStartStop_k;
  }

  /* End of Saturate: '<S131>/Saturation' */

  /* Outputs for Triggered SubSystem: '<S121>/Triggered Subsystem' incorporates:
   *  TriggerPort: '<S134>/Trigger'
   */
  if (rtb_DFIn_is_EPBAppcnStsApp_bl && ((int32_T)
       app_PrevZCX.TriggeredSubsystem_Trig_ZCE != 1)) {
    /* Inport: '<S134>/In1' incorporates:
     *  UnitDelay: '<S121>/Unit Delay'
     */
    app_B.In1 = app_DW.UnitDelay_DSTATE_m;
  }

  app_PrevZCX.TriggeredSubsystem_Trig_ZCE = (ZCSigState)
    rtb_DFIn_is_EPBAppcnStsApp_bl;

  /* End of Outputs for SubSystem: '<S121>/Triggered Subsystem' */

  /* Sum: '<S131>/Add1' incorporates:
   *  Constant: '<S131>/Constant3'
   *  DataTypeConversion: '<S121>/Data Type Conversion4'
   *  Product: '<S121>/Divide'
   *  Product: '<S131>/Product'
   *  Product: '<S131>/Product1'
   *  Sum: '<S131>/Add'
   *  UnitDelay: '<S121>/Unit Delay'
   */
  app_DW.UnitDelay_DSTATE_m = (real32_T)((real_T)rtb_ACC_v_ACCSetSpd_sg /
    app_ConstB.Wheel_Rolling_Radius_m) * DFIn_a_EstdVSELongtAccel_sg + (1.0F -
    DFIn_a_EstdVSELongtAccel_sg) * app_B.In1;

  /* Outputs for Atomic SubSystem: '<S102>/Vehicle_LongtResist_Estimate' */
  /* DataTypeConversion: '<S1060>/Data Type Conversion7' incorporates:
   *  UnitDelay: '<S1060>/spdD3'
   */
  rtb_ARB_F_PCTWhlDrvnToq_sg = app_Vehicle_LongtResist_Estimate((real32_T)
    app_DW.spdD3_DSTATE, 0.0F);

  /* End of Outputs for SubSystem: '<S102>/Vehicle_LongtResist_Estimate' */

  /* Gain: '<S121>/Gain' incorporates:
   *  UnitDelay: '<S121>/Unit Delay'
   */
  rtb_a_Min_Modify = 0.9F * app_DW.UnitDelay_DSTATE_m;

  /* Saturate: '<S121>/Saturation3' */
  if (rtb_a_Min_Modify > 200.0F) {
    rtb_a_Min_Modify = 200.0F;
  } else {
    if (rtb_a_Min_Modify < 1.0F) {
      rtb_a_Min_Modify = 1.0F;
    }
  }

  /* End of Saturate: '<S121>/Saturation3' */

  /* Outputs for Atomic SubSystem: '<S117>/Debounce_Module' */
  /* RelationalOperator: '<S117>/Relational Operator' incorporates:
   *  Constant: '<S117>/Mass_AS22_20T1'
   *  Constant: '<S117>/Mass_AS22_20T2'
   *  Constant: '<S117>/Mass_AS22_20T3'
   *  Constant: '<S117>/Mass_AS22_20T4'
   *  DataTypeConversion: '<S5>/Data Type Conversion35'
   *  Gain: '<S117>/Gain'
   *  Product: '<S117>/Divide'
   *  Product: '<S117>/Product'
   *  Sum: '<S117>/Add'
   */
  rtb_Out_dl = app_Debounce_Module(-((rtb_a_Min_Modify * (real32_T)
    app_B.ECM_EnToqMinExtdRng + rtb_ARB_F_PCTWhlDrvnToq_sg) / C_ADS_M_VehMass_sg)
    < longt_out_desAccelCtrlCmd, 0.1F, 0.01F, 0.01F, &app_DW.Debounce_Module);

  /* End of Outputs for SubSystem: '<S117>/Debounce_Module' */

  /* Logic: '<S117>/Logical Operator' */
  rtb_DFIn_is_EPBAppcnStsApp_bl = (longt_out_isCtrlEngage && rtb_Out_dl);

  /* Chart: '<S123>/Chart' */
  if ((uint32_T)app_DW.is_active_c49_app == 0U) {
    app_DW.is_active_c49_app = 1U;
    app_DW.is_c49_app = app_IN_OFF_f;
    app_B.ramp_cof_c = 0.0F;
  } else {
    switch (app_DW.is_c49_app) {
     case app_IN_OFF_f:
      if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
        app_DW.is_c49_app = app_IN_ON_Count_j;
        app_B.ramp_cof_c = 0.0F;
      }
      break;

     case app_IN_OFF_Count_o:
      if ((!rtb_DFIn_is_EPBAppcnStsApp_bl) && (app_B.ramp_cof_c <= 0.01F)) {
        app_DW.is_c49_app = app_IN_OFF_f;
        app_B.ramp_cof_c = 0.0F;
      } else if (rtb_DFIn_is_EPBAppcnStsApp_bl && (app_B.ramp_cof_c >= 0.99F)) {
        app_DW.is_c49_app = app_IN_ON_e;
        app_B.ramp_cof_c = 1.0F;
      } else if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
        app_B.ramp_cof_c += 0.02F;
      } else {
        app_B.ramp_cof_c -= 0.02F;
      }
      break;

     case app_IN_ON_e:
      if (!rtb_DFIn_is_EPBAppcnStsApp_bl) {
        app_DW.is_c49_app = app_IN_OFF_Count_o;
        app_B.ramp_cof_c = 1.0F;
      }
      break;

     default:
      /* case IN_ON_Count: */
      if (rtb_DFIn_is_EPBAppcnStsApp_bl && (app_B.ramp_cof_c >= 0.99F)) {
        app_DW.is_c49_app = app_IN_ON_e;
        app_B.ramp_cof_c = 1.0F;
      } else if ((!rtb_DFIn_is_EPBAppcnStsApp_bl) && (app_B.ramp_cof_c <= 0.01F))
      {
        app_DW.is_c49_app = app_IN_OFF_f;
        app_B.ramp_cof_c = 0.0F;
      } else if (rtb_DFIn_is_EPBAppcnStsApp_bl) {
        app_B.ramp_cof_c += 0.02F;
      } else {
        app_B.ramp_cof_c -= 0.02F;
      }
      break;
    }
  }

  /* End of Chart: '<S123>/Chart' */

  /* Outputs for Atomic SubSystem: '<S951>/DownEdge_counter' */
  /* Constant: '<S951>/character7'
   *
   * Block description for '<S951>/character7':
   *  /+Charactier+/
   */
  app_DownEdge_counter(app_ConstB.LogicalOperator7_g,
                       P_DFIn_t_CCFMAEBActvEver_sg, &app_B.OutPut_k,
                       &app_DW.DownEdge_counter);

  /* End of Outputs for SubSystem: '<S951>/DownEdge_counter' */

  /* Logic: '<S951>/Logical Operator10' incorporates:
   *  Constant: '<S951>/FW_P_ACC_is_CCFM_AEBVActvIN_bl_4'
   *  Logic: '<S951>/Logical Operator11'
   *
   * Block description for '<S951>/Logical Operator11':
   *
   */
  m_ACC_is_AEBActvEver_bl = (app_B.OutPut_k && (!P_ACC_is_CCFM_AEBVActvExitIN_bl));

  /* Chart: '<S946>/ACCFirstASctvJud' */
  if ((uint32_T)app_DW.is_active_c86_app == 0U) {
    app_DW.is_active_c86_app = 1U;
    app_DW.is_c86_app = app_IN_ACC_Ini;
  } else {
    switch (app_DW.is_c86_app) {
     case app_IN_ACC_Actv_Exist:
      break;

     default:
      /* case IN_ACC_Ini: */
      if ((m_FSM_sts_ACCSMRSts_en == eCruiseACCApproaching) ||
          (m_FSM_sts_ACCSMRSts_en == eCruiseCCC) || (m_FSM_sts_ACCSMRSts_en ==
           eStandStillActive) || (m_FSM_sts_ACCSMRSts_en == eStandStillWait)) {
        app_DW.is_c86_app = app_IN_ACC_Actv_Exist;
      }
      break;
    }
  }

  /* End of Chart: '<S946>/ACCFirstASctvJud' */

  /* Chart: '<S946>/ACCOvrdCntr' */
  if ((uint32_T)app_DW.is_active_c87_app == 0U) {
    app_DW.is_active_c87_app = 1U;
    app_DW.is_c87_app = app_IN_ACC_Not_Ovrd;
    app_B.DFIn_cntr_ACCOvrdCntr_u32 = 0U;
  } else if ((int32_T)app_DW.is_c87_app == 1) {
    if (m_ACC_is_ACCOvrrdReq_bl) {
      app_DW.is_c87_app = app_IN_ACC_Ovrd;
      qY = (uint32_T)(app_B.DFIn_cntr_ACCOvrdCntr_u32 + /*MW:OvSatOk*/ 1U);
      if ((uint32_T)(app_B.DFIn_cntr_ACCOvrdCntr_u32 + 1U) <
          app_B.DFIn_cntr_ACCOvrdCntr_u32) {
        qY = MAX_uint32_T;
      }

      app_B.DFIn_cntr_ACCOvrdCntr_u32 = qY;
    }
  } else {
    /* case IN_ACC_Ovrd: */
    if (!m_ACC_is_ACCOvrrdReq_bl) {
      app_DW.is_c87_app = app_IN_ACC_Not_Ovrd;
      app_B.DFIn_cntr_ACCOvrdCntr_u32 = 0U;
    } else {
      qY = (uint32_T)(app_B.DFIn_cntr_ACCOvrdCntr_u32 + /*MW:OvSatOk*/ 1U);
      if ((uint32_T)(app_B.DFIn_cntr_ACCOvrdCntr_u32 + 1U) <
          app_B.DFIn_cntr_ACCOvrdCntr_u32) {
        qY = MAX_uint32_T;
      }

      app_B.DFIn_cntr_ACCOvrdCntr_u32 = qY;
    }
  }

  /* End of Chart: '<S946>/ACCOvrdCntr' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCSeldDistLvl' */
  rtb_ACC_indx_HMISeldDistLvl_u8 = app_HMI_ACCSeldDistLvl
    (rtb_ACC_indx_DISTmDist_en);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCSeldDistLvl' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCDetObjDistLvl' */
  /* SignalConversion: '<S911>/Signal Copy2' incorporates:
   *  BusAssignment: '<S5>/Bus Assignment'
   *  Constant: '<S93>/Constant4'
   *  DataTypeConversion: '<S1060>/Data Type Conversion7'
   *  UnitDelay: '<S1060>/spdD3'
   */
  rtb_DA_OUT_indx_ACCDetObjDistLvl_u8 = app_HMI_ACCDetObjDistLvl
    (rtb_uDLookupTable, (real32_T)app_DW.spdD3_DSTATE, 10.0F,
     rtb_ACC_indx_HMISeldDistLvl_u8, &app_ConstB.HMI_ACCDetObjDistLvl,
     &app_DW.HMI_ACCDetObjDistLvl);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCDetObjDistLvl' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCObjDetJud' */
  /* Inport: '<Root>/Obj_01_v' incorporates:
   *  BusAssignment: '<S5>/Bus Assignment'
   *  SignalConversion: '<S911>/Signal Copy2'
   *  SignalConversion: '<S911>/Signal Copy4'
   */
  rtb_DataTypeConversion2_i = app_HMI_ACCObjDetJud(long_out_isLeadVehDtct,
    arg_Obj_01_v, rtb_uDLookupTable, rtb_out_cond_n3, m_ACC_is_VehSdslSts_bl,
    m_FSM_sts_ACCSMRSts_en, &app_ConstB.HMI_ACCObjDetJud,
    &app_DW.HMI_ACCObjDetJud);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCObjDetJud' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCSysCanclReq' */
  rtb_DA_OUT_indx_ACCSysCanclReq_u8 = app_HMI_ACCSysCanclReq(LogicalOperator,
    m_FSM_sts_ACCSMRSts_en, &app_DW.HMI_ACCSysCanclReq);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCSysCanclReq' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCSysFltStsHMI_WithSCS' */
  /* Constant: '<S907>/Constant16' incorporates:
   *  Constant: '<S907>/Constant17'
   *  DataTypeConversion: '<S96>/Data Type Conversion2'
   */
  rtb_ACC_indx_HMISysFltStsHMI_u8 = app_HMI_ACCSysFltStsHMI_WithSCS
    (app_B.Switch_g, false, false, DataTypeConversion19,
     app_ConstB.DFIn_is_CCFMRFltFSMWtSCS_bl);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCSysFltStsHMI_WithSCS' */

  /* Outputs for Atomic SubSystem: '<S997>/HMI_ACCSysStsJud' */
  /* UnitDelay: '<S93>/Unit Delay34' */
  app_DW.UnitDelay34_DSTATE = app_HMI_ACCSysStsJud(m_FSM_sts_ACCSMRSts_en);

  /* End of Outputs for SubSystem: '<S997>/HMI_ACCSysStsJud' */

  /* Product: '<S1040>/a2' incorporates:
   *  UnitDelay: '<S1040>/Unit Delay1'
   */
  app_DW.UnitDelay1_DSTATE_b = app_ConstB.a1 * rtb_Gain5_i;

  /* Logic: '<S1024>/Logical Operator3' incorporates:
   *  Constant: '<S1024>/Constant1'
   *  Constant: '<S1024>/Constant10'
   *  Constant: '<S1024>/Constant2'
   *  Constant: '<S1024>/Constant3'
   *  Constant: '<S1024>/Constant4'
   *  Logic: '<S1024>/Logical Operator'
   *  Logic: '<S1024>/Logical Operator1'
   *  Logic: '<S1024>/Logical Operator2'
   *  RelationalOperator: '<S1024>/Relational Operator1'
   *  RelationalOperator: '<S1024>/Relational Operator2'
   *  RelationalOperator: '<S1024>/Relational Operator3'
   *  RelationalOperator: '<S1024>/Relational Operator4'
   *  RelationalOperator: '<S1024>/Relational Operator5'
   */
  LogicalOperator = ((rtb_DataTypeConversion8 != TLP_Park_Range) &&
                     (rtb_DataTypeConversion8 != TLP_Reverse_Range) &&
                     (rtb_DataTypeConversion8 != TLP_Neutral_Range) &&
                     (rtb_DataTypeConversion8 != TLP_Between_Ranges) &&
                     (rtb_DataTypeConversion8 != TLP_Lever_Position_Unknown));

  /* Chart: '<S1024>/ACCPtMdJud_IP31' */
  if ((uint32_T)app_DW.is_active_c99_app == 0U) {
    app_DW.is_active_c99_app = 1U;
    if (LogicalOperator && (rtb_Switch4 == VLD_Valid) && (DataTypeConversion50 ==
         TRP_SftPttrn4Act)) {
      app_DW.is_c99_app = app_IN_ACCPtMd_ECO;
    } else if (LogicalOperator && (rtb_Switch4 == VLD_Valid) &&
               (DataTypeConversion50 == TRP_SftPttrn1Act)) {
      app_DW.is_c99_app = app_IN_ACCPtMd_Sport;
    } else {
      app_DW.is_c99_app = app_IN_ACCPtMd_Norm;
      app_enter_internal_ACCPtMd_Norm(&rtb_Switch4, &DataTypeConversion50,
        &LogicalOperator);
    }
  } else {
    switch (app_DW.is_c99_app) {
     case app_IN_ACCPtMd_ECO:
      if (LogicalOperator && (rtb_Switch4 == VLD_Valid) && (DataTypeConversion50
           == TRP_SftPttrn1Act)) {
        app_DW.is_c99_app = app_IN_ACCPtMd_Sport;
      } else {
        if ((!LogicalOperator) || (rtb_Switch4 != VLD_Valid) ||
            (DataTypeConversion50 != TRP_SftPttrn4Act)) {
          app_DW.is_c99_app = app_IN_ACCPtMd_Norm;
          app_enter_internal_ACCPtMd_Norm(&rtb_Switch4, &DataTypeConversion50,
            &LogicalOperator);
        }
      }
      break;

     case app_IN_ACCPtMd_Norm:
      if (LogicalOperator && (rtb_Switch4 == VLD_Valid) && (DataTypeConversion50
           == TRP_SftPttrn4Act)) {
        app_DW.is_ACCPtMd_Norm = 0;
        app_DW.is_c99_app = app_IN_ACCPtMd_ECO;
      } else if (LogicalOperator && (rtb_Switch4 == VLD_Valid) &&
                 (DataTypeConversion50 == TRP_SftPttrn1Act)) {
        app_DW.is_ACCPtMd_Norm = 0;
        app_DW.is_c99_app = app_IN_ACCPtMd_Sport;
      } else if ((int32_T)app_DW.is_ACCPtMd_Norm == 1) {
        LogicalOperator = !LogicalOperator;
        if ((LogicalOperator || (rtb_Switch4 != VLD_Valid) ||
             (DataTypeConversion50 != TRP_SftPttrn2Act)) && (LogicalOperator ||
             (rtb_Switch4 != VLD_Valid) || (DataTypeConversion50 !=
              TRP_SftPttrn3Act))) {
          app_DW.is_ACCPtMd_Norm = app_IN_ACCPtMd_Norm_Supt;
        }
      } else {
        /* case IN_ACCPtMd_Norm_Supt: */
        if ((LogicalOperator && (rtb_Switch4 == VLD_Valid) &&
             (DataTypeConversion50 == TRP_SftPttrn2Act)) || (LogicalOperator &&
             (rtb_Switch4 == VLD_Valid) && (DataTypeConversion50 ==
              TRP_SftPttrn3Act))) {
          app_DW.is_ACCPtMd_Norm = app_IN_ACCPtMd_Norm_NotSupt;
        }
      }
      break;

     default:
      /* case IN_ACCPtMd_Sport: */
      if (LogicalOperator && (rtb_Switch4 == VLD_Valid) && (DataTypeConversion50
           == TRP_SftPttrn4Act)) {
        app_DW.is_c99_app = app_IN_ACCPtMd_ECO;
      } else {
        if ((!LogicalOperator) || (rtb_Switch4 != VLD_Valid) ||
            (DataTypeConversion50 != TRP_SftPttrn1Act)) {
          app_DW.is_c99_app = app_IN_ACCPtMd_Norm;
          app_enter_internal_ACCPtMd_Norm(&rtb_Switch4, &DataTypeConversion50,
            &LogicalOperator);
        }
      }
      break;
    }
  }

  /* End of Chart: '<S1024>/ACCPtMdJud_IP31' */

  /* Outputs for Atomic SubSystem: '<S1030>/Chattering_Filter'
   *
   * Block description for '<S1030>/Chattering_Filter':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion33' */
  rtb_Switch_mg = app_Chattering_Filter(app_B.BCM_LDircnIO != 0.0,
    &app_DW.Chattering_Filter_f);

  /* End of Outputs for SubSystem: '<S1030>/Chattering_Filter' */

  /* Outputs for Atomic SubSystem: '<S1030>/Upedge_Detection'
   *
   * Block description for '<S1030>/Upedge_Detection':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Upedge_Detection(rtb_Switch_mg, &LogicalOperator,
                       &app_DW.Upedge_Detection_a);

  /* End of Outputs for SubSystem: '<S1030>/Upedge_Detection' */

  /* Outputs for Atomic SubSystem: '<S1030>/Hyseresis_Keep' */
  /* Logic: '<S1030>/Logical Operator1' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion33'
   */
  app_Hyseresis_Keep(!(app_B.BCM_LDircnIO != 0.0), &app_B.OutPut_j,
                     &app_ConstB.Hyseresis_Keep, &app_DW.Hyseresis_Keep);

  /* End of Outputs for SubSystem: '<S1030>/Hyseresis_Keep' */

  /* Outputs for Atomic SubSystem: '<S1030>/Chattering_Filter1'
   *
   * Block description for '<S1030>/Chattering_Filter1':
   *  Detect the input signals.
   *  If u(k)==u(k-1) &&u(k-1)==u(k-2), assign the input u to the ouput y,
   *  else ignore the input and keep the output y in previous step.
   */
  /* DataTypeConversion: '<S5>/Data Type Conversion32' */
  rtb_Switch_bh = app_Chattering_Filter(app_B.BCM_RDircnIO != 0.0,
    &app_DW.Chattering_Filter1_f);

  /* End of Outputs for SubSystem: '<S1030>/Chattering_Filter1' */

  /* Outputs for Atomic SubSystem: '<S1030>/Upedge_Detection1'
   *
   * Block description for '<S1030>/Upedge_Detection1':
   *  Upedge Detection
   *
   *  if u(k)~=u(k-1) && u(k)==1;
   *
   *  set       y = 1;
   *
   *       else y=0;
   */
  app_Upedge_Detection(rtb_Switch_bh, &rtb_DFIn_is_AEBStsDsbl_bl,
                       &app_DW.Upedge_Detection1);

  /* End of Outputs for SubSystem: '<S1030>/Upedge_Detection1' */

  /* Logic: '<S1030>/Logical Operator3' incorporates:
   *  Logic: '<S1030>/Logical Operator2'
   */
  rtb_DFIn_is_AEBPStsDsbl_bl = (LogicalOperator && rtb_DFIn_is_AEBStsDsbl_bl);

  /* Chart: '<S1030>/Chart' incorporates:
   *  Logic: '<S1030>/Logical Operator3'
   */
  if ((uint32_T)app_DW.is_active_c102_app == 0U) {
    app_DW.is_active_c102_app = 1U;
    app_DW.is_c102_app = app_IN_OAF_Sw_Off;
  } else if ((int32_T)app_DW.is_c102_app == 1) {
    if (LogicalOperator && (!rtb_DFIn_is_AEBPStsDsbl_bl)) {
      app_DW.is_c102_app = app_IN_OAF_Sw_On;
    }
  } else {
    /* case IN_OAF_Sw_On: */
    if (app_B.OutPut_j || rtb_DFIn_is_AEBPStsDsbl_bl) {
      app_DW.is_c102_app = app_IN_OAF_Sw_Off;
    }
  }

  /* End of Chart: '<S1030>/Chart' */

  /* Outputs for Atomic SubSystem: '<S1030>/Hyseresis_Keep1' */
  /* Logic: '<S1030>/Logical Operator' incorporates:
   *  DataTypeConversion: '<S5>/Data Type Conversion32'
   */
  app_Hyseresis_Keep(!(app_B.BCM_RDircnIO != 0.0), &app_B.OutPut,
                     &app_ConstB.Hyseresis_Keep1, &app_DW.Hyseresis_Keep1);

  /* End of Outputs for SubSystem: '<S1030>/Hyseresis_Keep1' */

  /* Chart: '<S1030>/Chart1' */
  if ((uint32_T)app_DW.is_active_c103_app == 0U) {
    app_DW.is_active_c103_app = 1U;
    app_DW.is_c103_app = app_IN_OAF_Sw_Off;
  } else if ((int32_T)app_DW.is_c103_app == 1) {
    if (rtb_DFIn_is_AEBStsDsbl_bl && (!rtb_DFIn_is_AEBPStsDsbl_bl)) {
      app_DW.is_c103_app = app_IN_OAF_Sw_On;
    }
  } else {
    /* case IN_OAF_Sw_On: */
    if (app_B.OutPut || rtb_DFIn_is_AEBPStsDsbl_bl) {
      app_DW.is_c103_app = app_IN_OAF_Sw_Off;
    }
  }

  /* End of Chart: '<S1030>/Chart1' */

  /* Chart: '<S1063>/Chart' */
  app_Chart_k(&app_B.count_b);

  /* Chart: '<S1120>/Chart3' incorporates:
   *  Constant: '<S1120>/Constant'
   *  Constant: '<S1120>/Constant1'
   *  Constant: '<S1120>/Constant2'
   *  Constant: '<S1126>/Constant'
   *  Inport: '<Root>/lateralPlan_lProb'
   *  RelationalOperator: '<S1126>/Compare'
   */
  app_Chart4(arg_lateralPlan_lProb >= 0.5F, 0.02F, 1.0F, 0.01F, &LogicalOperator,
             &app_DW.sf_Chart3_i);

  /* Chart: '<S1120>/Chart2' incorporates:
   *  Constant: '<S1120>/Constant3'
   *  Constant: '<S1120>/Constant4'
   *  Constant: '<S1120>/Constant5'
   *  Constant: '<S1127>/Constant'
   *  Inport: '<Root>/lateralPlan_rProb'
   *  RelationalOperator: '<S1127>/Compare'
   */
  app_Chart4(arg_lateralPlan_rProb >= 0.5F, 0.02F, 1.0F, 0.01F,
             &rtb_DFIn_is_AEBStsDsbl_bl, &app_DW.sf_Chart2_f);

  /* Chart: '<S1120>/Chart1' incorporates:
   *  Constant: '<S1120>/Constant6'
   *  Constant: '<S1120>/Constant7'
   *  Constant: '<S1120>/Constant8'
   *  Constant: '<S1128>/Constant'
   *  Inport: '<Root>/lateralPlan_dProb'
   *  RelationalOperator: '<S1128>/Compare'
   */
  app_Chart4(arg_lateralPlan_dProb >= 0.5F, 0.02F, 1.0F, 0.01F,
             &rtb_DFIn_is_AEBPStsDsbl_bl, &app_DW.sf_Chart1_c);

  /* Chart: '<S1121>/Chart7' incorporates:
   *  Constant: '<S1121>/Constant17'
   *  Constant: '<S1121>/Constant18'
   *  Constant: '<S1121>/Constant19'
   *  Constant: '<S1134>/Constant'
   *  DataTypeConversion: '<S75>/Data Type Conversion21'
   *  RelationalOperator: '<S1134>/Compare'
   */
  app_Chart4((real32_T)app_B.SCS_BrkPdlDrvrAppdPrs < 10.0F, 0.02F, 1.0F, 0.1F,
             &rtb_LogicalOperator9_kf, &app_DW.sf_Chart7);

  /* Chart: '<S1121>/Chart4' incorporates:
   *  Constant: '<S1121>/Constant6'
   *  Constant: '<S1121>/Constant7'
   *  Constant: '<S1121>/Constant8'
   *  DataTypeConversion: '<S75>/Data Type Conversion8'
   */
  app_Chart4(app_B.ECM_EnRunA != 0.0, 0.02F, 1.0F, 0.01F, &rtb_SeatBeltOn_o,
             &app_DW.sf_Chart4_g);

  /* Chart: '<S1121>/Chart5' incorporates:
   *  Constant: '<S1121>/Constant10'
   *  Constant: '<S1121>/Constant11'
   *  Constant: '<S1121>/Constant9'
   *  DataTypeConversion: '<S75>/Data Type Conversion44'
   */
  app_Chart4(app_B.IPK_CCSwStsOnSWA != 0.0, 0.02F, 1.0F, 0.01F, &rtb_Compare_hj,
             &app_DW.sf_Chart5);

  /* Chart: '<S1121>/Chart13' incorporates:
   *  Abs: '<S1121>/Abs'
   *  Constant: '<S1121>/Constant32'
   *  Constant: '<S1121>/Constant33'
   *  Constant: '<S1121>/Constant34'
   *  Constant: '<S1136>/Constant'
   *  RelationalOperator: '<S1136>/Compare'
   */
  app_Chart4(fabsf(m_VehCP_T_DrvrStrgDlvrdToq_sg) < 2.5F, 0.02F, 1.0F, 0.5F,
             &rtb_OR_f, &app_DW.sf_Chart13);

  /* Logic: '<S1064>/Logical Operator' incorporates:
   *  Logic: '<S1120>/Logical Operator1'
   *  Logic: '<S1120>/Logical Operator2'
   *  Logic: '<S1121>/Logical Operator'
   */
  rtb_DFIn_is_AEBStsDsbl_bl = (((LogicalOperator && rtb_DFIn_is_AEBStsDsbl_bl) ||
    rtb_DFIn_is_AEBPStsDsbl_bl) && (rtb_LogicalOperator9_kf && rtb_SeatBeltOn_o &&
    rtb_Compare_hj && rtb_OR_f));

  /* RelationalOperator: '<S1135>/Compare' incorporates:
   *  Constant: '<S1135>/Constant'
   */
  LogicalOperator = ((int32_T)m_VehCP_n_ChLKACtrlSts_u8 != 4);

  /* RelationalOperator: '<S1117>/FixPt Relational Operator' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion45'
   *  UnitDelay: '<S1117>/Delay Input1'
   *
   * Block description for '<S1117>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_DFIn_is_AEBPStsDsbl_bl = ((app_B.IPK_CCSwStsRsmSWA != 0.0) > (int32_T)
    app_DW.DelayInput1_DSTATE_n);

  /* Chart: '<S1119>/Chart1' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion44'
   *  DataTypeConversion: '<S75>/Data Type Conversion46'
   *  Delay: '<S1119>/Delay'
   *  RelationalOperator: '<S1118>/FixPt Relational Operator'
   *  UnitDelay: '<S1118>/Delay Input1'
   *
   * Block description for '<S1118>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if ((uint32_T)app_DW.is_active_c130_app == 0U) {
    app_DW.is_active_c130_app = 1U;
    app_DW.is_c130_app = app_IN_OFF_f;
    rtb_LogicalOperator9_kf = false;
    app_DW.is_OFF = app_IN_Zero_e;
    app_DW.local_count = 0U;
  } else if ((int32_T)app_DW.is_c130_app == 1) {
    rtb_LogicalOperator9_kf = false;
    if (((app_B.IPK_CCSwStsSetSWA != 0.0) > (int32_T)
         app_DW.DelayInput1_DSTATE_ma) && (app_B.IPK_CCSwStsOnSWA != 0.0)) {
      app_DW.is_OFF = 0;
      app_DW.is_c130_app = app_IN_ON_a;
      rtb_LogicalOperator9_kf = true;
    } else if ((int32_T)app_DW.is_OFF == 1) {
      if ((int32_T)app_DW.tm_count > 100) {
        app_DW.is_OFF = app_IN_Zero_e;
        app_DW.local_count = 0U;
      } else if (((int32_T)app_DW.local_count == 2) && (app_B.IPK_CCSwStsOnSWA
                  != 0.0)) {
        app_DW.is_OFF = 0;
        app_DW.is_c130_app = app_IN_ON_a;
        rtb_LogicalOperator9_kf = true;
      } else if (rtb_DFIn_is_AEBPStsDsbl_bl) {
        qY = (uint32_T)((uint32_T)app_DW.local_count + 1U);
        if ((uint32_T)((uint32_T)app_DW.local_count + 1U) > 65535U) {
          qY = 65535U;
        }

        app_DW.local_count = (uint16_T)qY;
        app_DW.tm_count = 0U;
      } else {
        qY = (uint32_T)((uint32_T)app_DW.tm_count + 1U);
        if ((uint32_T)((uint32_T)app_DW.tm_count + 1U) > 65535U) {
          qY = 65535U;
        }

        app_DW.tm_count = (uint16_T)qY;
      }
    } else {
      /* case IN_Zero: */
      if (rtb_DFIn_is_AEBPStsDsbl_bl) {
        app_DW.is_OFF = app_IN_UP_b;
        app_DW.local_count = 1U;
        app_DW.tm_count = 0U;
      }
    }
  } else {
    /* case IN_ON: */
    rtb_LogicalOperator9_kf = true;
    if (app_DW.Delay_DSTATE_iq || (!(app_B.IPK_CCSwStsOnSWA != 0.0))) {
      app_DW.is_c130_app = app_IN_OFF_f;
      rtb_LogicalOperator9_kf = false;
      app_DW.is_OFF = app_IN_Zero_e;
      app_DW.local_count = 0U;
    }
  }

  /* End of Chart: '<S1119>/Chart1' */

  /* Chart: '<S1064>/Chart' */
  if ((uint32_T)app_DW.is_active_c129_app == 0U) {
    app_DW.is_active_c129_app = 1U;
    app_DW.is_c129_app = app_IN_OFF_f;
    Arb_is_LatCtrlActv_bl = false;
  } else {
    switch (app_DW.is_c129_app) {
     case app_IN_OFF_f:
      if (rtb_LogicalOperator9_kf && rtb_DFIn_is_AEBStsDsbl_bl) {
        app_DW.is_c129_app = app_IN_Standby;
        Arb_is_LatCtrlActv_bl = false;
      } else {
        Arb_is_LatCtrlActv_bl = false;
      }
      break;

     case app_IN_ON_a:
      if (!rtb_DFIn_is_AEBStsDsbl_bl) {
        app_DW.is_c129_app = app_IN_OFF_f;
        Arb_is_LatCtrlActv_bl = false;
      } else if (!LogicalOperator) {
        app_DW.is_c129_app = app_IN_Standby;
        Arb_is_LatCtrlActv_bl = false;
      } else {
        Arb_is_LatCtrlActv_bl = true;
      }
      break;

     default:
      /* case IN_Standby: */
      if (!rtb_DFIn_is_AEBStsDsbl_bl) {
        app_DW.is_c129_app = app_IN_OFF_f;
        Arb_is_LatCtrlActv_bl = false;
      } else if (LogicalOperator) {
        app_DW.is_c129_app = app_IN_ON_a;
        Arb_is_LatCtrlActv_bl = true;
      } else {
        Arb_is_LatCtrlActv_bl = false;
      }
      break;
    }
  }

  /* End of Chart: '<S1064>/Chart' */

  /* Gain: '<S1260>/Gain1' incorporates:
   *  Gain: '<S1065>/Gain'
   *  Gain: '<S1137>/Gain7'
   *  Gain: '<S1138>/Gain'
   *  Gain: '<S1140>/Gain'
   */
  rtb_a_Max_Modify = 0.277777791F * DataTypeConversion28;

  /* Lookup_n-D: '<S1282>/1-D Lookup Table' incorporates:
   *  Gain: '<S1282>/Gain'
   */
  rtb_uDLookupTable = look1_iflf_binlxpw(3.6F * rtb_a_Max_Modify,
    app_ConstP.pooled95, app_ConstP.uDLookupTable_tableData_c, 7U);

  /* Saturate: '<S1138>/Saturation' */
  if (rtb_a_Max_Modify < 1.0F) {
    /* Saturate: '<S1292>/Saturation' */
    rtb_ACC_v_ACCSetSpd_sg = 1.0F;
  } else {
    /* Saturate: '<S1292>/Saturation' */
    rtb_ACC_v_ACCSetSpd_sg = rtb_a_Max_Modify;
  }

  /* Outputs for IfAction SubSystem: '<S1138>/Path_Tracking1' incorporates:
   *  ActionPort: '<S1212>/Action Port'
   */
  /* If: '<S1138>/If' incorporates:
   *  Chart: '<S1214>/Chart'
   *  Concatenate: '<S1217>/Matrix Concatenate'
   *  Concatenate: '<S1217>/Matrix Concatenate1'
   *  Constant: '<S1212>/Constant'
   *  Constant: '<S1213>/Constant2'
   *  Constant: '<S1214>/Constant'
   *  Constant: '<S1216>/Constant1'
   *  Constant: '<S1216>/Constant2'
   *  Constant: '<S1217>/Constant1'
   *  Constant: '<S1217>/Constant2'
   *  Constant: '<S1217>/Constant3'
   *  Constant: '<S1217>/Constant4'
   *  Constant: '<S1217>/Constant5'
   *  Delay: '<S1212>/Delay'
   *  Delay: '<S1212>/Delay1'
   *  Delay: '<S1214>/Delay'
   *  Delay: '<S1219>/Delay'
   *  Delay: '<S1235>/Delay'
   *  Delay: '<S1237>/Delay'
   *  Delay: '<S1238>/Delay'
   *  Gain: '<S1138>/Gain1'
   *  Gain: '<S1212>/Gain'
   *  Gain: '<S1212>/Gain5'
   *  Gain: '<S1215>/Gain'
   *  Gain: '<S1216>/Gain1'
   *  Gain: '<S1216>/Gain2'
   *  Gain: '<S1216>/Gain3'
   *  Gain: '<S1216>/Gain4'
   *  Gain: '<S1216>/Gain5'
   *  Gain: '<S1216>/Gain6'
   *  Gain: '<S1216>/Gain8'
   *  Gain: '<S1217>/Gain1'
   *  Gain: '<S1217>/Gain7'
   *  Gain: '<S1231>/Gain'
   *  Gain: '<S1231>/Gain1'
   *  Gain: '<S1232>/Gain'
   *  Gain: '<S1232>/Gain1'
   *  Inport: '<Root>/lateralPlan_pathCof_C0'
   *  Inport: '<Root>/lateralPlan_pathCof_C1'
   *  Inport: '<Root>/lateralPlan_pathCof_C2'
   *  Inport: '<Root>/lateralPlan_pathCof_C3'
   *  Lookup_n-D: '<S1212>/1-D Lookup Table1'
   *  Lookup_n-D: '<S1216>/1-D Lookup Table1'
   *  Lookup_n-D: '<S1216>/1-D Lookup Table2'
   *  Lookup_n-D: '<S1217>/1-D Lookup Table'
   *  Lookup_n-D: '<S1217>/1-D Lookup Table1'
   *  Lookup_n-D: '<S1217>/1-D Lookup Table2'
   *  Math: '<S1236>/Math Function'
   *  Math: '<S1236>/Math Function1'
   *  Product: '<S1212>/Divide'
   *  Product: '<S1212>/Product'
   *  Product: '<S1212>/Product1'
   *  Product: '<S1214>/Product'
   *  Product: '<S1214>/Product1'
   *  Product: '<S1216>/Divide'
   *  Product: '<S1216>/Product'
   *  Product: '<S1216>/Product1'
   *  Product: '<S1216>/Product3'
   *  Product: '<S1217>/Product1'
   *  Product: '<S1217>/Product2'
   *  Product: '<S1218>/Product'
   *  Product: '<S1219>/Product'
   *  Product: '<S1219>/Product1'
   *  Product: '<S1230>/Product'
   *  Product: '<S1230>/Product1'
   *  Product: '<S1230>/Product2'
   *  Product: '<S1231>/Product'
   *  Product: '<S1231>/Product1'
   *  Product: '<S1232>/Product'
   *  Product: '<S1232>/Product1'
   *  Product: '<S1235>/Product'
   *  Product: '<S1235>/Product1'
   *  Product: '<S1236>/Divide'
   *  Product: '<S1236>/Product'
   *  Product: '<S1236>/Product1'
   *  Product: '<S1237>/Product'
   *  Product: '<S1237>/Product1'
   *  Product: '<S1238>/Product'
   *  Product: '<S1238>/Product1'
   *  RelationalOperator: '<S1228>/LowerRelop1'
   *  RelationalOperator: '<S1228>/UpperRelop'
   *  RelationalOperator: '<S1233>/LowerRelop1'
   *  RelationalOperator: '<S1233>/UpperRelop'
   *  RelationalOperator: '<S1234>/LowerRelop1'
   *  RelationalOperator: '<S1234>/UpperRelop'
   *  Reshape: '<S1217>/Reshape'
   *  Reshape: '<S1217>/Reshape4'
   *  Reshape: '<S1217>/Reshape5'
   *  Saturate: '<S1138>/Saturation'
   *  Saturate: '<S1212>/Saturation'
   *  Saturate: '<S1212>/Saturation1'
   *  Saturate: '<S1212>/Saturation2'
   *  Saturate: '<S1214>/Saturation1'
   *  SignalConversion generated from: '<S1212>/desired_Yawrate_degps_AftLimit'
   *  SignalConversion generated from: '<S1217>/Product2'
   *  Sum: '<S1214>/Add'
   *  Sum: '<S1214>/Subtract'
   *  Sum: '<S1214>/Sum'
   *  Sum: '<S1215>/Add5'
   *  Sum: '<S1216>/Add4'
   *  Sum: '<S1216>/Subtract'
   *  Sum: '<S1216>/Subtract1'
   *  Sum: '<S1219>/Sum'
   *  Sum: '<S1230>/Add'
   *  Sum: '<S1231>/Add'
   *  Sum: '<S1232>/Add'
   *  Sum: '<S1235>/Sum'
   *  Sum: '<S1236>/Add'
   *  Sum: '<S1237>/Sum'
   *  Sum: '<S1238>/Sum'
   *  Sum: '<S1239>/Add1'
   *  Switch: '<S1213>/Switch'
   *  Switch: '<S1214>/Switch'
   *  Switch: '<S1228>/Switch'
   *  Switch: '<S1228>/Switch2'
   *  Switch: '<S1233>/Switch'
   *  Switch: '<S1233>/Switch2'
   *  Switch: '<S1234>/Switch'
   *  Switch: '<S1234>/Switch2'
   *  Trigonometry: '<S1212>/Sin'
   *  Trigonometry: '<S1217>/Cos'
   *  UnaryMinus: '<S1216>/Unary Minus'
   *  UnaryMinus: '<S1216>/Unary Minus1'
   * */
  rtb_a_Min_Modify = 3.6F * rtb_ACC_v_ACCSetSpd_sg * 0.277777791F;
  rtb_MinMax1_p = 3.6F * rtb_a_Min_Modify;
  rtb_MatrixConcatenate1[0] = look1_iflf_binlxpw(rtb_MinMax1_p,
    app_ConstP.pooled95, app_ConstP.uDLookupTable_tableData_e, 7U);
  rtb_MatrixConcatenate1[2] = 0.0F;
  rtb_MatrixConcatenate1[1] = 0.0F;
  rtb_MatrixConcatenate1[3] = look1_iflf_binlxpw(rtb_MinMax1_p,
    app_ConstP.pooled95, app_ConstP.uDLookupTable1_tableData_m, 7U);
  rtb_a_traj_FEMid = look1_iflf_binlxpw(rtb_MinMax1_p, app_ConstP.pooled95,
    app_ConstP.uDLookupTable2_tableData_n, 7U);
  rtb_Gain5_i = 0.5F * rtb_a_Min_Modify;
  rtb_t_min = arg_lateralPlan_pathCof_C2 * rtb_Gain5_i;
  Switch = arg_lateralPlan_pathCof_C3 * rtb_Gain5_i * rtb_Gain5_i;
  rtb_MinMax1_p = (rtb_t_min * 2.0F + arg_lateralPlan_pathCof_C1) + Switch *
    3.0F;
  rtb_MatrixConcatenate[0] = 1.0F;
  rtb_MatrixConcatenate[2] = rtb_a_Min_Modify * cosf(rtb_MinMax1_p) * 0.02F;
  rtb_MatrixConcatenate[1] = 0.0F;
  rtb_MatrixConcatenate[3] = 1.0F;

  /* Outputs for Iterator SubSystem: '<S1236>/For Iterator Subsystem' incorporates:
   *  ForIterator: '<S1239>/For Iterator'
   */
  for (s1239_iter = 1; s1239_iter < 21; s1239_iter++) {
    /* Product: '<S1239>/Product2' incorporates:
     *  DataStoreRead: '<S1239>/Data Store Read'
     *  Math: '<S1239>/Math Function2'
     *  Product: '<S1239>/Product'
     *  Product: '<S1239>/Product1'
     */
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
    for (i_0 = 0; i_0 < 2; i_0++) {
      /* Math: '<S1239>/Math Function' incorporates:
       *  Math: '<S1239>/Math Function1'
       */
      tmp = (int32_T)(i_0 << 1);
      Add1_tmp[tmp] = rtb_MatrixConcatenate[i_0];

      /* Product: '<S1239>/Product' incorporates:
       *  Product: '<S1239>/Product3'
       */
      Add1_tmp_0[i_0] = 0.0F;
      Add1_tmp_0[i_0] += app_DW.P[i_0];
      Add1_tmp_0[i_0] += app_DW.P[(int32_T)(i_0 + 2)] * 0.0F;

      /* Math: '<S1239>/Math Function' incorporates:
       *  DataStoreRead: '<S1239>/Data Store Read'
       *  Math: '<S1239>/Math Function1'
       *  Product: '<S1239>/Product'
       */
      Add1_tmp[(int32_T)(tmp + 1)] = rtb_MatrixConcatenate[(int32_T)(i_0 + 2)];

      /* Product: '<S1239>/Product' incorporates:
       *  Product: '<S1239>/Product3'
       */
      Add1_tmp_0[(int32_T)(i_0 + 2)] = 0.0F;
      Add1_tmp_0[(int32_T)(i_0 + 2)] += app_DW.P[i_0] * rtb_MatrixConcatenate[2];
      Add1_tmp_0[(int32_T)(i_0 + 2)] += app_DW.P[(int32_T)(i_0 + 2)];
      rtb_MinMax_a0 = app_DW.P[(int32_T)(i_0 + 2)] * 0.02F + app_DW.P[i_0] *
        0.0F;
      DFIn_a_EstdVSELongtAccel_sg += app_ConstB.MathFunction2[i_0] *
        rtb_MinMax_a0;
      rtb_Switch1_g[i_0] = rtb_MinMax_a0;
    }

    /* Sum: '<S1239>/Add' incorporates:
     *  Product: '<S1239>/Product2'
     */
    rtb_MinMax_a0 = rtb_a_traj_FEMid + DFIn_a_EstdVSELongtAccel_sg;
    for (i_0 = 0; i_0 < 2; i_0++) {
      /* Product: '<S1239>/Product3' */
      tmp = (int32_T)(i_0 << 1);

      /* Math: '<S1239>/Math Function' incorporates:
       *  Math: '<S1239>/Math Function1'
       */
      DFIn_a_EstdVSELongtAccel_sg = Add1_tmp[(int32_T)(i_0 + 2)];

      /* Sum: '<S1239>/Add1' incorporates:
       *  Math: '<S1239>/Math Function'
       *  Product: '<S1239>/Product'
       */
      rtb_MatrixConcatenate1_0[i_0] = (DFIn_a_EstdVSELongtAccel_sg * Add1_tmp_0
        [1] + Add1_tmp[i_0] * Add1_tmp_0[0]) + rtb_MatrixConcatenate1[i_0];
      rtb_MatrixConcatenate1_0[(int32_T)(i_0 + 2)] =
        (DFIn_a_EstdVSELongtAccel_sg * Add1_tmp_0[3] + Add1_tmp[i_0] *
         Add1_tmp_0[2]) + rtb_MatrixConcatenate1[(int32_T)(i_0 + 2)];

      /* Product: '<S1239>/Divide' incorporates:
       *  Math: '<S1239>/Math Function1'
       *  Product: '<S1239>/Product1'
       */
      Add1_tmp_1[i_0] = (DFIn_a_EstdVSELongtAccel_sg * rtb_Switch1_g[1] +
                         Add1_tmp[i_0] * rtb_Switch1_g[0]) / rtb_MinMax_a0;
      tmp_0[i_0] = Add1_tmp_0[(int32_T)(tmp + 1)] * app_ConstB.MathFunction3[1]
        + Add1_tmp_0[tmp] * app_ConstB.MathFunction3[0];
    }

    /* Sum: '<S1239>/Add1' incorporates:
     *  Math: '<S1239>/Math Function3'
     *  Product: '<S1239>/Product3'
     */
    app_B.Add1[0] = rtb_MatrixConcatenate1_0[0] - Add1_tmp_1[0] * tmp_0[0];

    /* DataStoreWrite: '<S1239>/Data Store Write' incorporates:
     *  Sum: '<S1239>/Add1'
     */
    app_DW.P[0] = app_B.Add1[0];

    /* Sum: '<S1239>/Add1' incorporates:
     *  Product: '<S1239>/Product3'
     */
    app_B.Add1[1] = rtb_MatrixConcatenate1_0[1] - Add1_tmp_1[1] * tmp_0[0];

    /* DataStoreWrite: '<S1239>/Data Store Write' incorporates:
     *  Sum: '<S1239>/Add1'
     */
    app_DW.P[1] = app_B.Add1[1];

    /* Sum: '<S1239>/Add1' incorporates:
     *  Product: '<S1239>/Product3'
     */
    app_B.Add1[2] = rtb_MatrixConcatenate1_0[2] - Add1_tmp_1[0] * tmp_0[1];

    /* DataStoreWrite: '<S1239>/Data Store Write' incorporates:
     *  Sum: '<S1239>/Add1'
     */
    app_DW.P[2] = app_B.Add1[2];

    /* Sum: '<S1239>/Add1' incorporates:
     *  Product: '<S1239>/Product3'
     */
    app_B.Add1[3] = rtb_MatrixConcatenate1_0[3] - Add1_tmp_1[1] * tmp_0[1];

    /* DataStoreWrite: '<S1239>/Data Store Write' incorporates:
     *  Sum: '<S1239>/Add1'
     */
    app_DW.P[3] = app_B.Add1[3];
  }

  /* End of Outputs for SubSystem: '<S1236>/For Iterator Subsystem' */
  DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  for (i_0 = 0; i_0 < 2; i_0++) {
    rtb_MatrixConcatenate1[i_0] = 0.0F;
    rtb_MatrixConcatenate1[i_0] += app_B.Add1[i_0];
    rtb_Product_eqe = app_B.Add1[(int32_T)(i_0 + 2)];
    rtb_MatrixConcatenate1[i_0] += rtb_Product_eqe * 0.0F;
    rtb_MatrixConcatenate1[(int32_T)(i_0 + 2)] = 0.0F;
    rtb_MatrixConcatenate1[(int32_T)(i_0 + 2)] += app_B.Add1[i_0] *
      rtb_MatrixConcatenate[2];
    rtb_MatrixConcatenate1[(int32_T)(i_0 + 2)] += rtb_Product_eqe;
    DFIn_a_EstdVSELongtAccel_sg += app_ConstB.MathFunction[i_0] *
      (rtb_Product_eqe * 0.02F + app_B.Add1[i_0] * 0.0F);
  }

  rtb_a_traj_FEMid += DFIn_a_EstdVSELongtAccel_sg;
  rtb_Switch1_g[0] = -((app_ConstB.MathFunction1[0] * rtb_MatrixConcatenate1[0]
                        + app_ConstB.MathFunction1[1] * rtb_MatrixConcatenate1[1])
                       / rtb_a_traj_FEMid);
  DFIn_a_EstdVSELongtAccel_sg = (app_ConstB.MathFunction1[0] *
    rtb_MatrixConcatenate1[2] + app_ConstB.MathFunction1[1] *
    rtb_MatrixConcatenate1[3]) / rtb_a_traj_FEMid;
  rtb_MinMax_a0 = look1_iflf_binlxpw(3.6F * rtb_a_Min_Modify,
    app_ConstP.pooled98, app_ConstP.uDLookupTable1_tableData_d, 5U);
  rtb_a_traj_FEMid = 0.0174532924F * m_VehCP_yr_VehDynYawRate_sg;
  if ((int32_T)app_DW.icLoad_bz != 0) {
    app_DW.Delay_DSTATE_o = rtb_a_traj_FEMid;
  }

  app_DW.Delay_DSTATE_o = app_DW.Delay_DSTATE_o * app_ConstB.alpha_ph +
    app_ConstB.ualpha_e * rtb_a_traj_FEMid;
  rtb_a_traj_FEMid = app_DW.Delay_DSTATE_o / rtb_a_Min_Modify;
  rtb_t_min = rtb_a_traj_FEMid * rtb_Gain5_i * rtb_Gain5_i * 0.5F -
    (((arg_lateralPlan_pathCof_C1 * rtb_Gain5_i + arg_lateralPlan_pathCof_C0) +
      rtb_t_min * rtb_Gain5_i) + Switch * rtb_Gain5_i);
  if (rtb_t_min > rtb_MinMax_a0) {
    rtb_t_min = rtb_MinMax_a0;
  } else {
    if (rtb_t_min < -rtb_MinMax_a0) {
      /* Switch: '<S1233>/Switch' incorporates:
       *  UnaryMinus: '<S1216>/Unary Minus'
       */
      rtb_t_min = -rtb_MinMax_a0;
    }
  }

  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_m != 1)) {
    app_DW.icLoad_jw = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_m = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_jw != 0) {
    app_DW.Delay_DSTATE_f3 = rtb_t_min;
  }

  app_DW.Delay_DSTATE_f3 = app_DW.Delay_DSTATE_f3 * app_ConstB.alpha_c +
    app_ConstB.ualpha_d * rtb_t_min;
  Switch = look1_iflf_binlxpw(3.6F * rtb_a_Min_Modify, app_ConstP.pooled98,
    app_ConstP.uDLookupTable2_tableData_c, 5U);
  rtb_MinMax1_p = (0.5F * rtb_a_traj_FEMid * rtb_Gain5_i * 2.0F + 0.0F *
                   rtb_Gain5_i * rtb_Gain5_i * 3.0F) - rtb_MinMax1_p;
  if (rtb_MinMax1_p > Switch) {
    rtb_MinMax1_p = Switch;
  } else {
    if (rtb_MinMax1_p < -Switch) {
      /* Switch: '<S1234>/Switch' incorporates:
       *  UnaryMinus: '<S1216>/Unary Minus1'
       */
      rtb_MinMax1_p = -Switch;
    }
  }

  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_h != 1)) {
    app_DW.icLoad_o = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_h = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_o != 0) {
    app_DW.Delay_DSTATE_if = rtb_MinMax1_p;
  }

  app_DW.Delay_DSTATE_if = app_DW.Delay_DSTATE_if * app_ConstB.alpha_lo +
    app_ConstB.ualpha_a * rtb_MinMax1_p;
  rtb_MinMax1_p = atanf(rtb_MinMax1_p) * rtb_a_Min_Modify;
  if ((int32_T)app_DW.icLoad_ng != 0) {
    app_DW.Delay_DSTATE_em = rtb_MinMax1_p;
  }

  app_DW.Delay_DSTATE_em = app_DW.Delay_DSTATE_em * app_ConstB.alpha_a +
    app_ConstB.ualpha_eo * rtb_MinMax1_p;
  if (Arb_is_LatCtrlActv_bl) {
    /* Switch: '<S1213>/Switch2' incorporates:
     *  Constant: '<S1212>/desired_stable_offset'
     *  Saturate: '<S1212>/Saturation3'
     *  Sum: '<S1212>/Subtract'
     */
    if (app_ConstB.Compare_m) {
      /* Switch: '<S1213>/Switch' incorporates:
       *  Constant: '<S1213>/Constant3'
       */
      app_DW.Delay_DSTATE_h = 0.0F;
    } else {
      if (0.0F - rtb_t_min > 0.4F) {
        /* Saturate: '<S1212>/Saturation3' */
        rtb_MinMax1_p = 0.4F;
      } else if (0.0F - rtb_t_min < -0.4F) {
        /* Saturate: '<S1212>/Saturation3' */
        rtb_MinMax1_p = -0.4F;
      } else {
        /* Saturate: '<S1212>/Saturation3' incorporates:
         *  Constant: '<S1212>/desired_stable_offset'
         *  Sum: '<S1212>/Subtract'
         */
        rtb_MinMax1_p = 0.0F - rtb_t_min;
      }

      /* Switch: '<S1213>/Switch3' incorporates:
       *  Constant: '<S1212>/desired_stable_offset'
       *  Constant: '<S1213>/Constant4'
       *  Constant: '<S1213>/Constant5'
       *  Constant: '<S1227>/Constant'
       *  Delay: '<S1212>/Delay'
       *  Product: '<S1213>/Product1'
       *  RelationalOperator: '<S1227>/Compare'
       *  Saturate: '<S1212>/Saturation3'
       *  Sum: '<S1212>/Subtract'
       */
      if (rtb_MinMax1_p * app_DW.Delay_DSTATE_h > 0.0F) {
        i_0 = 1;
      } else {
        i_0 = 3;
      }

      /* End of Switch: '<S1213>/Switch3' */

      /* Sum: '<S1213>/Add' incorporates:
       *  Constant: '<S1213>/Constant'
       *  Delay: '<S1212>/Delay'
       *  Gain: '<S1212>/Gain3'
       *  Lookup_n-D: '<S1212>/1-D Lookup Table'
       *  Product: '<S1213>/Product'
       *  Product: '<S1213>/Product2'
       */
      rtb_t_min = (real32_T)((real_T)(look1_iflf_binlxpw(3.6F * rtb_a_Min_Modify,
        app_ConstP.pooled95, app_ConstP.uDLookupTable_tableData_k, 7U) *
        (real32_T)i_0 * rtb_MinMax1_p) * 0.02) + app_DW.Delay_DSTATE_h;

      /* Switch: '<S1213>/Switch1' incorporates:
       *  Constant: '<S1221>/Constant'
       *  Constant: '<S1222>/Constant'
       *  Constant: '<S1223>/Constant'
       *  Constant: '<S1224>/Constant'
       *  Constant: '<S1225>/Constant'
       *  Constant: '<S1226>/Constant'
       *  Logic: '<S1213>/Logical Operator'
       *  Logic: '<S1213>/Logical Operator1'
       *  Logic: '<S1213>/Logical Operator2'
       *  Logic: '<S1213>/Logical Operator3'
       *  Logic: '<S1213>/Logical Operator4'
       *  Logic: '<S1213>/Logical Operator5'
       *  RelationalOperator: '<S1221>/Compare'
       *  RelationalOperator: '<S1222>/Compare'
       *  RelationalOperator: '<S1223>/Compare'
       *  RelationalOperator: '<S1224>/Compare'
       *  RelationalOperator: '<S1225>/Compare'
       *  RelationalOperator: '<S1226>/Compare'
       */
      if (app_ConstB.LogicalOperator6_m && (((rtb_MinMax1_p >= 0.0F) &&
            ((app_DW.Delay1_DSTATE_he < 5.0F) || (rtb_t_min < 0.0F))) ||
           ((rtb_MinMax1_p <= 0.0F) && ((app_DW.Delay1_DSTATE_he > -5.0F) ||
             (rtb_t_min > 0.0F))))) {
        /* Switch: '<S1213>/Switch' */
        app_DW.Delay_DSTATE_h = rtb_t_min;
      }

      /* End of Switch: '<S1213>/Switch1' */
    }

    /* End of Switch: '<S1213>/Switch2' */
  } else {
    /* Switch: '<S1213>/Switch' incorporates:
     *  Constant: '<S1213>/Constant1'
     */
    app_DW.Delay_DSTATE_h = 0.0F;
  }

  if (app_DW.Delay_DSTATE_h > 0.5F) {
    /* Switch: '<S1213>/Switch' */
    app_DW.Delay_DSTATE_h = 0.5F;
  } else {
    if (app_DW.Delay_DSTATE_h < app_ConstB.UnaryMinus_jo) {
      /* Switch: '<S1213>/Switch' incorporates:
       *  Switch: '<S1228>/Switch'
       */
      app_DW.Delay_DSTATE_h = app_ConstB.UnaryMinus_jo;
    }
  }

  if (Arb_is_LatCtrlActv_bl) {
    app_DW.Delay_DSTATE_gu = app_DW.Delay_DSTATE_h;
  }

  app_Chart(Arb_is_LatCtrlActv_bl, &app_B.ramp_cof_bn, &app_DW.sf_Chart_hk);
  if (app_B.ramp_cof_bn > 1.0F) {
    rtb_MinMax1_p = 1.0F;
  } else if (app_B.ramp_cof_bn < 0.0F) {
    rtb_MinMax1_p = 0.0F;
  } else {
    rtb_MinMax1_p = app_B.ramp_cof_bn;
  }

  rtb_MinMax1_p = (((1.0F - rtb_MinMax1_p) * app_DW.Delay_DSTATE_em +
                    app_DW.Delay_DSTATE_gu * rtb_MinMax1_p) -
                   app_DW.Delay_DSTATE_em) * look1_iflf_binlxpw(3.6F *
    rtb_a_Min_Modify, app_ConstP.pooled95, app_ConstP.uDLookupTable1_tableData_e,
    7U);
  if (rtb_MinMax1_p > 1.0F) {
    rtb_MinMax1_p = 1.0F;
  } else {
    if (rtb_MinMax1_p < -1.0F) {
      rtb_MinMax1_p = -1.0F;
    }
  }

  app_DW.Delay1_DSTATE_he = ((6.0F * arg_lateralPlan_pathCof_C3 * rtb_Gain5_i +
    2.0F * arg_lateralPlan_pathCof_C2) * rtb_a_Min_Modify + ((rtb_Switch1_g[0] *
    app_DW.Delay_DSTATE_f3 + -DFIn_a_EstdVSELongtAccel_sg *
    app_DW.Delay_DSTATE_if) + rtb_MinMax1_p / rtb_a_Min_Modify)) * 57.2957802F;
  rtb_Gain5_i = app_DW.Delay1_DSTATE_he;
  app_DW.icLoad_bz = 0U;
  app_DW.icLoad_jw = 0U;
  app_DW.icLoad_o = 0U;
  app_DW.icLoad_ng = 0U;

  /* End of If: '<S1138>/If' */
  /* End of Outputs for SubSystem: '<S1138>/Path_Tracking1' */

  /* Switch: '<S1138>/Switch' incorporates:
   *  Gain: '<S1138>/Gain3'
   *  Inport: '<Root>/lateralPlan_ctrlType'
   *  Inport: '<Root>/lateralPlan_rawCurvature'
   *  Product: '<S1138>/Product'
   *  Saturate: '<S1138>/Saturation'
   */
  if (arg_lateralPlan_ctrlType) {
    rtb_Gain5_i = arg_lateralPlan_rawCurvature * rtb_ACC_v_ACCSetSpd_sg *
      57.2957802F;
  }

  /* End of Switch: '<S1138>/Switch' */

  /* Switch: '<S1281>/Switch' incorporates:
   *  Delay: '<S1281>/Delay'
   */
  if (Arb_is_LatCtrlActv_bl) {
    app_DW.Delay_DSTATE_l = rtb_Gain5_i;
  }

  /* End of Switch: '<S1281>/Switch' */

  /* Chart: '<S1281>/Chart' */
  app_Chart(Arb_is_LatCtrlActv_bl, &app_B.ramp_cof_g, &app_DW.sf_Chart_cc);

  /* Saturate: '<S1281>/Saturation1' */
  if (app_B.ramp_cof_g > 1.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 1.0F;
  } else if (app_B.ramp_cof_g < 0.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = app_B.ramp_cof_g;
  }

  /* End of Saturate: '<S1281>/Saturation1' */

  /* Switch: '<S1281>/Switch1' incorporates:
   *  Constant: '<S1281>/Constant1'
   */
  if (Arb_is_LatCtrlActv_bl) {
    rtb_a_Min_Modify = 0.0F;
  } else {
    rtb_a_Min_Modify = m_VehCP_yr_VehDynYawRate_sg;
  }

  /* End of Switch: '<S1281>/Switch1' */

  /* Product: '<S1282>/Divide' incorporates:
   *  Constant: '<S1281>/Constant'
   *  Delay: '<S1281>/Delay'
   *  Gain: '<S1282>/degps2radps'
   *  Product: '<S1281>/Product'
   *  Product: '<S1281>/Product1'
   *  Sum: '<S1281>/Add'
   *  Sum: '<S1281>/Subtract'
   *  Sum: '<S1281>/Sum'
   */
  DFIn_a_EstdVSELongtAccel_sg = (((1.0F - DFIn_a_EstdVSELongtAccel_sg) *
    m_VehCP_yr_VehDynYawRate_sg + app_DW.Delay_DSTATE_l *
    DFIn_a_EstdVSELongtAccel_sg) - rtb_a_Min_Modify) * 0.0174532924F /
    rtb_a_Max_Modify;

  /* Switch: '<S1286>/Switch2' incorporates:
   *  RelationalOperator: '<S1286>/LowerRelop1'
   *  RelationalOperator: '<S1286>/UpperRelop'
   *  Switch: '<S1286>/Switch'
   *  UnaryMinus: '<S1282>/Unary Minus1'
   */
  if (DFIn_a_EstdVSELongtAccel_sg > rtb_uDLookupTable) {
    DFIn_a_EstdVSELongtAccel_sg = rtb_uDLookupTable;
  } else {
    if (DFIn_a_EstdVSELongtAccel_sg < -rtb_uDLookupTable) {
      /* Switch: '<S1286>/Switch' incorporates:
       *  UnaryMinus: '<S1282>/Unary Minus1'
       */
      DFIn_a_EstdVSELongtAccel_sg = -rtb_uDLookupTable;
    }
  }

  /* End of Switch: '<S1286>/Switch2' */

  /* Product: '<S1283>/Product' incorporates:
   *  Product: '<S1282>/Product'
   */
  rtb_uDLookupTable = DFIn_a_EstdVSELongtAccel_sg * rtb_a_Max_Modify *
    rtb_a_Max_Modify;

  /* Delay: '<S1287>/Delay' */
  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_n != 1)) {
    app_DW.icLoad_g = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_n = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_g != 0) {
    app_DW.Delay_DSTATE_g = rtb_uDLookupTable;
  }

  /* Switch: '<S1287>/Switch' */
  if (Arb_is_LatCtrlActv_bl) {
    /* Sum: '<S1287>/Add1' incorporates:
     *  Delay: '<S1287>/Delay'
     */
    DFIn_a_EstdVSELongtAccel_sg = app_ConstB.Product_l + app_DW.Delay_DSTATE_g;

    /* Switch: '<S1288>/Switch2' incorporates:
     *  RelationalOperator: '<S1288>/LowerRelop1'
     */
    if (rtb_uDLookupTable > DFIn_a_EstdVSELongtAccel_sg) {
      rtb_uDLookupTable = DFIn_a_EstdVSELongtAccel_sg;
    } else {
      /* Sum: '<S1287>/Add2' incorporates:
       *  Delay: '<S1287>/Delay'
       */
      DFIn_a_EstdVSELongtAccel_sg = app_DW.Delay_DSTATE_g +
        app_ConstB.Product1_b;

      /* Switch: '<S1288>/Switch' incorporates:
       *  RelationalOperator: '<S1288>/UpperRelop'
       */
      if (rtb_uDLookupTable < DFIn_a_EstdVSELongtAccel_sg) {
        rtb_uDLookupTable = DFIn_a_EstdVSELongtAccel_sg;
      }

      /* End of Switch: '<S1288>/Switch' */
    }

    /* End of Switch: '<S1288>/Switch2' */
  }

  /* End of Switch: '<S1287>/Switch' */

  /* Saturate: '<S1283>/Saturation' */
  if (rtb_a_Max_Modify < 0.5F) {
    /* Saturate: '<S1284>/Saturation' */
    DFIn_a_EstdVSELongtAccel_sg = 0.5F;
  } else {
    /* Saturate: '<S1284>/Saturation' */
    DFIn_a_EstdVSELongtAccel_sg = rtb_a_Max_Modify;
  }

  /* Product: '<S1284>/Product' incorporates:
   *  Product: '<S1283>/Divide'
   *  Saturate: '<S1283>/Saturation'
   */
  rtb_a_Min_Modify = rtb_uDLookupTable / DFIn_a_EstdVSELongtAccel_sg *
    rtb_a_Max_Modify;

  /* Switch: '<S1289>/Switch2' incorporates:
   *  Constant: '<S1284>/Constant'
   *  RelationalOperator: '<S1289>/LowerRelop1'
   *  RelationalOperator: '<S1289>/UpperRelop'
   *  Switch: '<S1289>/Switch'
   */
  if (rtb_a_Min_Modify > 2.5F) {
    rtb_a_Min_Modify = 2.5F;
  } else {
    if (rtb_a_Min_Modify < app_ConstB.UnaryMinus_bz) {
      /* Switch: '<S1289>/Switch' */
      rtb_a_Min_Modify = app_ConstB.UnaryMinus_bz;
    }
  }

  /* End of Switch: '<S1289>/Switch2' */

  /* Gain: '<S1280>/radps2degps' incorporates:
   *  Product: '<S1284>/Divide'
   */
  DFIn_a_EstdVSELongtAccel_sg = rtb_a_Min_Modify / DFIn_a_EstdVSELongtAccel_sg *
    57.2957802F;

  /* Delay: '<S1285>/Delay' */
  if ((((int32_T)app_PrevZCX.Delay_Reset_ZCE_b == 1) != Arb_is_LatCtrlActv_bl) &&
      ((int32_T)app_PrevZCX.Delay_Reset_ZCE_b != 3)) {
    app_DW.icLoad_cb = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_b = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_cb != 0) {
    /* Sum: '<S1285>/Sum' */
    app_DW.Delay_DSTATE_n = DFIn_a_EstdVSELongtAccel_sg;
  }

  /* Sum: '<S1285>/Sum' incorporates:
   *  Delay: '<S1285>/Delay'
   *  Product: '<S1285>/Product'
   *  Product: '<S1285>/Product1'
   */
  app_DW.Delay_DSTATE_n = app_DW.Delay_DSTATE_n * app_ConstB.alpha_k +
    app_ConstB.ualpha_c * DFIn_a_EstdVSELongtAccel_sg;

  /* Switch: '<S1291>/Switch' incorporates:
   *  Delay: '<S1291>/Delay'
   */
  if (Arb_is_LatCtrlActv_bl) {
    app_DW.Delay_DSTATE_c = app_DW.Delay_DSTATE_n;
  }

  /* End of Switch: '<S1291>/Switch' */

  /* Chart: '<S1291>/Chart' */
  app_Chart(Arb_is_LatCtrlActv_bl, &app_B.ramp_cof, &app_DW.sf_Chart_d2);

  /* Saturate: '<S1291>/Saturation1' */
  if (app_B.ramp_cof > 1.0F) {
    rtb_a_Min_Modify = 1.0F;
  } else if (app_B.ramp_cof < 0.0F) {
    rtb_a_Min_Modify = 0.0F;
  } else {
    rtb_a_Min_Modify = app_B.ramp_cof;
  }

  /* End of Saturate: '<S1291>/Saturation1' */

  /* Delay: '<S1295>/Delay' */
  if ((int32_T)app_DW.icLoad_f != 0) {
    /* Sum: '<S1295>/Sum' incorporates:
     *  DataTypeConversion: '<S75>/Data Type Conversion10'
     */
    app_DW.Delay_DSTATE_i = (real32_T)app_B.SCS_VehDynYawRate;
  }

  /* Sum: '<S1295>/Sum' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion10'
   *  Delay: '<S1295>/Delay'
   *  Product: '<S1295>/Product'
   *  Product: '<S1295>/Product1'
   */
  app_DW.Delay_DSTATE_i = app_DW.Delay_DSTATE_i * app_ConstB.alpha_n +
    app_ConstB.ualpha_j * (real32_T)app_B.SCS_VehDynYawRate;

  /* Sum: '<S1291>/Sum' incorporates:
   *  Constant: '<S1291>/Constant'
   *  Delay: '<S1291>/Delay'
   *  Product: '<S1291>/Product'
   *  Product: '<S1291>/Product1'
   *  Sum: '<S1291>/Add'
   *  Sum: '<S1291>/Subtract'
   */
  DFIn_a_EstdVSELongtAccel_sg = ((1.0F - rtb_a_Min_Modify) *
    app_DW.Delay_DSTATE_i + app_DW.Delay_DSTATE_c * rtb_a_Min_Modify) -
    app_DW.Delay_DSTATE_i;

  /* Switch: '<S1299>/Switch2' incorporates:
   *  Constant: '<S1291>/Constant1'
   *  RelationalOperator: '<S1299>/LowerRelop1'
   *  RelationalOperator: '<S1299>/UpperRelop'
   *  Switch: '<S1299>/Switch'
   */
  if (DFIn_a_EstdVSELongtAccel_sg > 2.0F) {
    DFIn_a_EstdVSELongtAccel_sg = 2.0F;
  } else {
    if (DFIn_a_EstdVSELongtAccel_sg < app_ConstB.UnaryMinus_jt) {
      /* Switch: '<S1299>/Switch' */
      DFIn_a_EstdVSELongtAccel_sg = app_ConstB.UnaryMinus_jt;
    }
  }

  /* End of Switch: '<S1299>/Switch2' */

  /* Product: '<S1301>/Product2' incorporates:
   *  Lookup_n-D: '<S1291>/KP_loTable'
   *  Saturate: '<S75>/Saturation'
   */
  rtb_a_Min_Modify = DFIn_a_EstdVSELongtAccel_sg * look1_iflf_binlxpw
    (DataTypeConversion28, app_ConstP.pooled113,
     app_ConstP.KP_loTable_tableData_l, 6U);

  /* Switch: '<S1298>/Switch' */
  if (Arb_is_LatCtrlActv_bl) {
    /* Switch: '<S1298>/Switch2' incorporates:
     *  Constant: '<S1307>/Constant'
     *  Delay: '<S1291>/Delay1'
     *  Product: '<S1298>/Product1'
     *  RelationalOperator: '<S1307>/Compare'
     *  Switch: '<S1298>/Switch3'
     */
    if (app_ConstB.Compare) {
      /* Switch: '<S1298>/Switch' incorporates:
       *  Constant: '<S1298>/Constant3'
       */
      app_DW.Delay1_DSTATE_h = 0.0F;
    } else {
      if (DFIn_a_EstdVSELongtAccel_sg * app_DW.Delay1_DSTATE_h > 0.0F) {
        /* Switch: '<S1298>/Switch3' incorporates:
         *  Lookup_n-D: '<S1291>/KI_loTable'
         *  Saturate: '<S75>/Saturation'
         */
        rtb_MinMax1_p = look1_iflf_binlxpw(DataTypeConversion28,
          app_ConstP.pooled113, app_ConstP.pooled94, 6U);
      } else {
        /* Switch: '<S1298>/Switch3' incorporates:
         *  Gain: '<S1298>/Gain'
         *  Lookup_n-D: '<S1291>/KI_loTable'
         *  Saturate: '<S75>/Saturation'
         */
        rtb_MinMax1_p = 3.0F * look1_iflf_binlxpw(DataTypeConversion28,
          app_ConstP.pooled113, app_ConstP.pooled94, 6U);
      }

      /* Sum: '<S1298>/Add' incorporates:
       *  Constant: '<S1298>/Constant'
       *  Delay: '<S1291>/Delay1'
       *  Product: '<S1298>/Product'
       */
      rtb_MinMax1_p = (real32_T)((real_T)(DFIn_a_EstdVSELongtAccel_sg *
        rtb_MinMax1_p) * 0.02) + app_DW.Delay1_DSTATE_h;

      /* Switch: '<S1298>/Switch1' incorporates:
       *  Constant: '<S1291>/MaxAllowed_FBW_Item1'
       *  Constant: '<S1303>/Constant'
       *  Constant: '<S1304>/Constant'
       *  Constant: '<S1305>/Constant'
       *  Constant: '<S1306>/Constant'
       *  Delay: '<S1291>/Delay2'
       *  Logic: '<S1298>/Logical Operator'
       *  Logic: '<S1298>/Logical Operator1'
       *  Logic: '<S1298>/Logical Operator2'
       *  Logic: '<S1298>/Logical Operator3'
       *  Logic: '<S1298>/Logical Operator4'
       *  Logic: '<S1298>/Logical Operator5'
       *  RelationalOperator: '<S1298>/Relational Operator'
       *  RelationalOperator: '<S1298>/Relational Operator1'
       *  RelationalOperator: '<S1303>/Compare'
       *  RelationalOperator: '<S1304>/Compare'
       *  RelationalOperator: '<S1305>/Compare'
       *  RelationalOperator: '<S1306>/Compare'
       */
      if (app_ConstB.LogicalOperator6_f && (((DFIn_a_EstdVSELongtAccel_sg >=
             0.0F) && ((app_DW.Delay2_DSTATE_e < 0.25F) || (rtb_MinMax1_p < 0.0F)))
           || ((DFIn_a_EstdVSELongtAccel_sg <= 0.0F) && ((app_DW.Delay2_DSTATE_e
              > app_ConstB.UnaryMinus1_g) || (rtb_MinMax1_p > 0.0F))))) {
        /* Switch: '<S1298>/Switch' */
        app_DW.Delay1_DSTATE_h = rtb_MinMax1_p;
      }

      /* End of Switch: '<S1298>/Switch1' */
    }

    /* End of Switch: '<S1298>/Switch2' */
  } else {
    /* Switch: '<S1298>/Switch' incorporates:
     *  Constant: '<S1298>/Constant1'
     */
    app_DW.Delay1_DSTATE_h = 0.0F;
  }

  /* End of Switch: '<S1298>/Switch' */

  /* Switch: '<S1308>/Switch2' incorporates:
   *  Constant: '<S1298>/Constant2'
   *  RelationalOperator: '<S1308>/LowerRelop1'
   *  RelationalOperator: '<S1308>/UpperRelop'
   *  Switch: '<S1308>/Switch'
   */
  if (app_DW.Delay1_DSTATE_h > 0.2F) {
    /* Switch: '<S1298>/Switch' */
    app_DW.Delay1_DSTATE_h = 0.2F;
  } else {
    if (app_DW.Delay1_DSTATE_h < app_ConstB.UnaryMinus_bl) {
      /* Switch: '<S1298>/Switch' incorporates:
       *  Switch: '<S1308>/Switch'
       */
      app_DW.Delay1_DSTATE_h = app_ConstB.UnaryMinus_bl;
    }
  }

  /* End of Switch: '<S1308>/Switch2' */

  /* Switch: '<S1309>/Switch2' incorporates:
   *  Constant: '<S1301>/Constant1'
   *  RelationalOperator: '<S1309>/LowerRelop1'
   *  RelationalOperator: '<S1309>/UpperRelop'
   *  Switch: '<S1309>/Switch'
   */
  if (rtb_a_Min_Modify > 0.2F) {
    rtb_a_Min_Modify = 0.2F;
  } else {
    if (rtb_a_Min_Modify < app_ConstB.UnaryMinus_j) {
      /* Switch: '<S1309>/Switch' */
      rtb_a_Min_Modify = app_ConstB.UnaryMinus_j;
    }
  }

  /* End of Switch: '<S1309>/Switch2' */

  /* Sum: '<S1291>/Add1' incorporates:
   *  Delay: '<S1291>/Delay1'
   */
  app_DW.Delay2_DSTATE_e = rtb_a_Min_Modify + app_DW.Delay1_DSTATE_h;

  /* Switch: '<S1300>/Switch2' incorporates:
   *  Constant: '<S1291>/MaxAllowed_FBW_Item'
   *  RelationalOperator: '<S1300>/LowerRelop1'
   *  RelationalOperator: '<S1300>/UpperRelop'
   *  Switch: '<S1300>/Switch'
   */
  if (app_DW.Delay2_DSTATE_e > 0.25F) {
    /* Sum: '<S1291>/Add1' */
    app_DW.Delay2_DSTATE_e = 0.25F;
  } else {
    if (app_DW.Delay2_DSTATE_e < app_ConstB.UnaryMinus1_d) {
      /* Sum: '<S1291>/Add1' incorporates:
       *  Switch: '<S1300>/Switch'
       */
      app_DW.Delay2_DSTATE_e = app_ConstB.UnaryMinus1_d;
    }
  }

  /* End of Switch: '<S1300>/Switch2' */

  /* Product: '<S1293>/Product' incorporates:
   *  Constant: '<S1292>/Constant'
   *  Constant: '<S1292>/Constant1'
   *  Constant: '<S1292>/Constant2'
   *  Constant: '<S1293>/Constant'
   *  Delay: '<S1291>/Delay2'
   *  Gain: '<S1292>/Gain'
   *  Gain: '<S1292>/deg2rad'
   *  Gain: '<S1292>/rad2deg'
   *  Product: '<S1292>/Divide'
   *  Product: '<S1292>/Divide1'
   *  Product: '<S1292>/Product'
   *  Product: '<S1292>/Product1'
   *  Sum: '<S1292>/Add'
   *  Sum: '<S1296>/Add'
   *  Trigonometry: '<S1292>/Atan'
   */
  rtb_ACC_v_ACCSetSpd_sg = ((atanf(0.0174532924F * app_DW.Delay_DSTATE_n /
    rtb_ACC_v_ACCSetSpd_sg * 2.65F) * 57.2957802F + 0.0174532924F *
    app_DW.Delay_DSTATE_n * rtb_ACC_v_ACCSetSpd_sg * 2.0F / 9.81F) +
    app_DW.Delay2_DSTATE_e) * 15.2F;

  /* Delay: '<S1315>/Delay' */
  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_j != 1)) {
    app_DW.icLoad_a = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_j = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_a != 0) {
    app_DW.Delay_DSTATE_j1 = rtb_ACC_v_ACCSetSpd_sg;
  }

  /* Switch: '<S1315>/Switch' incorporates:
   *  Delay: '<S1249>/Delay'
   *  Switch: '<S1249>/Switch'
   *  Switch: '<S1294>/Switch'
   */
  if (Arb_is_LatCtrlActv_bl) {
    /* Lookup_n-D: '<S1311>/StrWhlAng_RateLmt' incorporates:
     *  Saturate: '<S75>/Saturation'
     */
    DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlcapw(DataTypeConversion28,
      app_ConstP.pooled52, app_ConstP.StrWhlAng_RateLmt_tableData, 15U);

    /* Sum: '<S1315>/Add1' incorporates:
     *  Constant: '<S1311>/Constant'
     *  Delay: '<S1315>/Delay'
     *  Product: '<S1315>/Product'
     */
    rtb_Add12 = (real_T)DFIn_a_EstdVSELongtAccel_sg * 0.02 + (real_T)
      app_DW.Delay_DSTATE_j1;

    /* Switch: '<S1316>/Switch2' incorporates:
     *  RelationalOperator: '<S1316>/LowerRelop1'
     */
    if ((real_T)rtb_ACC_v_ACCSetSpd_sg > rtb_Add12) {
      rtb_ACC_v_ACCSetSpd_sg = (real32_T)rtb_Add12;
    } else {
      /* Sum: '<S1315>/Add2' incorporates:
       *  Constant: '<S1311>/Constant'
       *  Delay: '<S1315>/Delay'
       *  Product: '<S1315>/Product1'
       *  UnaryMinus: '<S1311>/Unary Minus'
       */
      rtb_Add12 = 0.02 * (real_T)-DFIn_a_EstdVSELongtAccel_sg + (real_T)
        app_DW.Delay_DSTATE_j1;

      /* Switch: '<S1316>/Switch' incorporates:
       *  RelationalOperator: '<S1316>/UpperRelop'
       */
      if ((real_T)rtb_ACC_v_ACCSetSpd_sg < rtb_Add12) {
        rtb_ACC_v_ACCSetSpd_sg = (real32_T)rtb_Add12;
      }

      /* End of Switch: '<S1316>/Switch' */
    }

    /* End of Switch: '<S1316>/Switch2' */

    /* Lookup_n-D: '<S1312>/LUT_MaxLatAcc' incorporates:
     *  Saturate: '<S75>/Saturation'
     */
    DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlcapw(DataTypeConversion28,
      app_ConstP.LUT_MaxLatAcc_bp01Data, app_ConstP.LUT_MaxLatAcc_tableData, 17U);

    /* Saturate: '<S1312>/Saturation2' */
    if (DataTypeConversion28 < 5.0F) {
      rtb_a_Min_Modify = 5.0F;
    } else {
      rtb_a_Min_Modify = DataTypeConversion28;
    }

    /* End of Saturate: '<S1312>/Saturation2' */

    /* Gain: '<S1312>/Gain' */
    rtb_a_Min_Modify *= 0.277777791F;

    /* Abs: '<S1312>/Abs' incorporates:
     *  Constant: '<S1141>/Constant'
     *  Constant: '<S1141>/Constant1'
     *  Constant: '<S1141>/Constant2'
     *  Constant: '<S1312>/C_GravAcc'
     *  Gain: '<S1312>/rad2deg'
     *  Product: '<S1312>/Divide1'
     *  Product: '<S1312>/Product'
     *  Product: '<S1312>/Product1'
     *  Product: '<S1312>/Product2'
     *  Product: '<S1312>/Product3'
     *  Sum: '<S1312>/Add'
     *  Trigonometry: '<S1312>/Trigonometric Function'
     */
    YRC_angD_ReqStrgWhlAng_sg = fabsf((atanf(2.65F / (rtb_a_Min_Modify *
      rtb_a_Min_Modify) * 9.8F * DFIn_a_EstdVSELongtAccel_sg) * 57.2957802F +
      DFIn_a_EstdVSELongtAccel_sg * 2.0F) * 15.2F);

    /* Switch: '<S1314>/Switch2' incorporates:
     *  RelationalOperator: '<S1314>/LowerRelop1'
     */
    if (!(rtb_ACC_v_ACCSetSpd_sg > YRC_angD_ReqStrgWhlAng_sg)) {
      /* Switch: '<S1314>/Switch' incorporates:
       *  Gain: '<S1313>/Gain3'
       *  RelationalOperator: '<S1314>/UpperRelop'
       */
      if (rtb_ACC_v_ACCSetSpd_sg < -YRC_angD_ReqStrgWhlAng_sg) {
        /* Abs: '<S1312>/Abs' incorporates:
         *  Switch: '<S1294>/Switch'
         */
        YRC_angD_ReqStrgWhlAng_sg = -YRC_angD_ReqStrgWhlAng_sg;
      } else {
        /* Abs: '<S1312>/Abs' incorporates:
         *  Switch: '<S1294>/Switch'
         */
        YRC_angD_ReqStrgWhlAng_sg = rtb_ACC_v_ACCSetSpd_sg;
      }

      /* End of Switch: '<S1314>/Switch' */
    }

    /* End of Switch: '<S1314>/Switch2' */
    app_DW.Delay_DSTATE_ji = YRC_angD_ReqStrgWhlAng_sg;
  } else {
    /* Abs: '<S1312>/Abs' incorporates:
     *  Switch: '<S1294>/Switch'
     */
    YRC_angD_ReqStrgWhlAng_sg = m_VehCP_angD_StrgWhlAng_sg;
  }

  /* End of Switch: '<S1315>/Switch' */

  /* Lookup_n-D: '<S1250>/1-D Lookup Table1' incorporates:
   *  Saturate: '<S75>/Saturation'
   */
  DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlxpw(DataTypeConversion28,
    app_ConstP.pooled104, app_ConstP.uDLookupTable1_tableData_o, 14U);

  /* Chart: '<S1249>/Chart' */
  app_Chart(Arb_is_LatCtrlActv_bl, &app_B.ramp_cof_b, &app_DW.sf_Chart_ji);

  /* Saturate: '<S1249>/Saturation1' */
  if (app_B.ramp_cof_b > 1.0F) {
    rtb_a_Min_Modify = 1.0F;
  } else if (app_B.ramp_cof_b < 0.0F) {
    rtb_a_Min_Modify = 0.0F;
  } else {
    rtb_a_Min_Modify = app_B.ramp_cof_b;
  }

  /* End of Saturate: '<S1249>/Saturation1' */

  /* Sum: '<S1249>/Sum' incorporates:
   *  Constant: '<S1249>/Constant'
   *  Delay: '<S1249>/Delay'
   *  Product: '<S1249>/Product'
   *  Product: '<S1249>/Product1'
   *  Sum: '<S1249>/Add'
   *  Sum: '<S1249>/Subtract'
   */
  rtb_MinMax1_p = ((1.0F - rtb_a_Min_Modify) * m_VehCP_angD_StrgWhlAng_sg +
                   app_DW.Delay_DSTATE_ji * rtb_a_Min_Modify) -
    m_VehCP_angD_StrgWhlAng_sg;

  /* Delay: '<S1253>/Delay' */
  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_b0 != 1)) {
    app_DW.icLoad_b = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_b0 = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_b != 0) {
    app_DW.Delay_DSTATE_eg = rtb_MinMax1_p;
  }

  /* Switch: '<S1253>/Switch' */
  if (Arb_is_LatCtrlActv_bl) {
    /* Sum: '<S1253>/Add1' incorporates:
     *  Delay: '<S1253>/Delay'
     */
    rtb_a_Min_Modify = app_ConstB.Product + app_DW.Delay_DSTATE_eg;

    /* Switch: '<S1254>/Switch2' incorporates:
     *  RelationalOperator: '<S1254>/LowerRelop1'
     */
    if (rtb_MinMax1_p > rtb_a_Min_Modify) {
      rtb_MinMax1_p = rtb_a_Min_Modify;
    } else {
      /* Sum: '<S1253>/Add2' incorporates:
       *  Delay: '<S1253>/Delay'
       */
      rtb_a_Min_Modify = app_DW.Delay_DSTATE_eg + app_ConstB.Product1;

      /* Switch: '<S1254>/Switch' incorporates:
       *  RelationalOperator: '<S1254>/UpperRelop'
       */
      if (rtb_MinMax1_p < rtb_a_Min_Modify) {
        rtb_MinMax1_p = rtb_a_Min_Modify;
      }

      /* End of Switch: '<S1254>/Switch' */
    }

    /* End of Switch: '<S1254>/Switch2' */
  }

  /* End of Switch: '<S1253>/Switch' */

  /* Sum: '<S1250>/Subtract' incorporates:
   *  Gain: '<S1250>/Gain'
   *  Lookup_n-D: '<S1250>/1-D Lookup Table'
   *  Product: '<S1250>/Product'
   *  Saturate: '<S75>/Saturation'
   */
  rtb_t_min = rtb_MinMax1_p * look1_iflf_binlxpw(DataTypeConversion28,
    app_ConstP.pooled104, app_ConstP.uDLookupTable_tableData_o1, 14U) - 0.0F *
    m_VehCP_W_StrgWhlAngGrd_sg;

  /* Switch: '<S1255>/Switch2' incorporates:
   *  RelationalOperator: '<S1255>/LowerRelop1'
   *  RelationalOperator: '<S1255>/UpperRelop'
   *  Switch: '<S1255>/Switch'
   *  UnaryMinus: '<S1250>/Unary Minus'
   */
  if (rtb_t_min > DFIn_a_EstdVSELongtAccel_sg) {
    rtb_t_min = DFIn_a_EstdVSELongtAccel_sg;
  } else {
    if (rtb_t_min < -DFIn_a_EstdVSELongtAccel_sg) {
      /* Switch: '<S1255>/Switch' incorporates:
       *  UnaryMinus: '<S1250>/Unary Minus'
       */
      rtb_t_min = -DFIn_a_EstdVSELongtAccel_sg;
    }
  }

  /* End of Switch: '<S1255>/Switch2' */

  /* Switch: '<S1257>/Switch' incorporates:
   *  Abs: '<S1257>/Abs2'
   *  Abs: '<S1257>/Abs6'
   *  Abs: '<S1257>/Abs8'
   *  Constant: '<S1276>/Constant'
   *  Gain: '<S1257>/Normal2comft'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table1'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table10'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table11'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table15'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table17'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table18'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table2'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table3'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table4'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table5'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table7'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table8'
   *  Lookup_n-D: '<S1257>/1-D Lookup Table9'
   *  Lookup_n-D: '<S1257>/2-D Lookup Table'
   *  Product: '<S1257>/Product'
   *  Product: '<S1257>/Product1'
   *  Product: '<S1257>/Product2'
   *  Product: '<S1257>/Product3'
   *  RelationalOperator: '<S1276>/Compare'
   *  Saturate: '<S75>/Saturation'
   */
  if ((int32_T)m_VehCP_n_StrgCustSetngDspCmd_u8 != 1) {
    /* Lookup_n-D: '<S1257>/1-D Lookup Table1' incorporates:
     *  Abs: '<S1257>/Abs4'
     *  Lookup_n-D: '<S1257>/1-D Lookup Table6'
     */
    rtb_a_Min_Modify = look1_iflf_binlcpw(fabsf(rtb_t_min), app_ConstP.pooled82,
      app_ConstP.pooled101, 5U);

    /* Abs: '<S1257>/Abs2' incorporates:
     *  Abs: '<S1257>/Abs'
     *  Abs: '<S1257>/Abs3'
     */
    DFIn_a_EstdVSELongtAccel_sg = fabsf(YRC_angD_ReqStrgWhlAng_sg);
    rtb_MatrixConcatenate1[0] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.uDLookupTable3_tableData_e, 14U) *
      look1_iflf_binlcpw(DFIn_a_EstdVSELongtAccel_sg, app_ConstP.pooled103,
                         app_ConstP.pooled102, 9U) * rtb_a_Min_Modify;
    rtb_MatrixConcatenate1[1] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.uDLookupTable4_tableData_k, 14U) *
      look1_iflf_binlcpw(DFIn_a_EstdVSELongtAccel_sg,
                         app_ConstP.uDLookupTable9_bp01Data,
                         app_ConstP.uDLookupTable9_tableData, 9U) *
      rtb_a_Min_Modify;
    rtb_MatrixConcatenate1[2] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.pooled105, 14U);
    rtb_MatrixConcatenate1[3] = look1_iflf_binlxpw(DFIn_a_EstdVSELongtAccel_sg,
      app_ConstP.pooled107, app_ConstP.pooled106, 10U);
  } else {
    /* Abs: '<S1257>/Abs6' incorporates:
     *  Abs: '<S1257>/Abs7'
     *  Abs: '<S1257>/Abs9'
     */
    rtb_a_Min_Modify = fabsf(YRC_angD_ReqStrgWhlAng_sg);

    /* Abs: '<S1257>/Abs8' incorporates:
     *  Abs: '<S1257>/Abs5'
     */
    DFIn_a_EstdVSELongtAccel_sg = fabsf(rtb_t_min);
    rtb_MatrixConcatenate1[0] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.uDLookupTable7_tableData_d, 14U) *
      look1_iflf_binlcpw(rtb_a_Min_Modify, app_ConstP.pooled103,
                         app_ConstP.pooled102, 9U) * look1_iflf_binlcpw
      (DFIn_a_EstdVSELongtAccel_sg, app_ConstP.pooled82, app_ConstP.pooled101,
       5U);
    rtb_MatrixConcatenate1[1] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.uDLookupTable10_tableData, 14U) *
      look2_iflf_binlxpw(rtb_a_Min_Modify, DFIn_a_EstdVSELongtAccel_sg,
                         app_ConstP.uDLookupTable_bp01Data_d,
                         app_ConstP.uDLookupTable_bp02Data,
                         app_ConstP.uDLookupTable_tableData_hu,
                         app_ConstP.uDLookupTable_maxIndex, 7U);
    rtb_MatrixConcatenate1[2] = look1_iflf_binlxpw(DataTypeConversion28,
      app_ConstP.pooled104, app_ConstP.pooled105, 14U);
    rtb_MatrixConcatenate1[3] = 0.75F * look1_iflf_binlxpw(rtb_a_Min_Modify,
      app_ConstP.pooled107, app_ConstP.pooled106, 10U);
  }

  /* End of Switch: '<S1257>/Switch' */

  /* Product: '<S1260>/Product2' incorporates:
   *  Gain: '<S1260>/Gain1'
   *  Product: '<S1260>/Product1'
   */
  rtb_Add_g0 = rtb_a_Max_Modify * rtb_a_Max_Modify * YRC_angD_ReqStrgWhlAng_sg *
    rtb_MatrixConcatenate1[3];

  /* Saturate: '<S1260>/Saturation' */
  if (rtb_Add_g0 > 2.5F) {
    rtb_Add_g0 = 2.5F;
  } else {
    if (rtb_Add_g0 < -2.5F) {
      rtb_Add_g0 = -2.5F;
    }
  }

  /* End of Saturate: '<S1260>/Saturation' */

  /* Lookup_n-D: '<S1262>/1-D Lookup Table' incorporates:
   *  Saturate: '<S75>/Saturation'
   */
  rtb_a_Min_Modify = look1_iflf_binlxpw(DataTypeConversion28,
    app_ConstP.pooled98, app_ConstP.uDLookupTable_tableData_hv, 5U);

  /* Product: '<S1262>/Product' */
  Switch = rtb_t_min * rtb_MatrixConcatenate1[0];

  /* Abs: '<S1262>/Abs' incorporates:
   *  Abs: '<S1256>/Abs'
   *  Switch: '<S1261>/Switch'
   */
  DataTypeConversion28 = fabsf(m_VehCP_T_DrvrStrgDlvrdToq_sg);

  /* Lookup_n-D: '<S1262>/1-D Lookup Table3' incorporates:
   *  Abs: '<S1262>/Abs'
   */
  DFIn_a_EstdVSELongtAccel_sg = look1_iflf_binlxpw(DataTypeConversion28,
    app_ConstP.uDLookupTable3_bp01Data, app_ConstP.uDLookupTable3_tableData_l,
    5U);

  /* Product: '<S1259>/Divide' incorporates:
   *  Constant: '<S1259>/Constant'
   *  Sum: '<S1259>/Subtract'
   *  UnitDelay: '<S1259>/Unit Delay'
   */
  rtb_a_traj_FEMid = (rtb_t_min - app_DW.UnitDelay_DSTATE_i) / 0.02F;

  /* Saturate: '<S1259>/Saturation' */
  if (rtb_a_traj_FEMid > 10.0F) {
    rtb_a_traj_FEMid = 10.0F;
  } else {
    if (rtb_a_traj_FEMid < -10.0F) {
      rtb_a_traj_FEMid = -10.0F;
    }
  }

  /* End of Saturate: '<S1259>/Saturation' */

  /* Delay: '<S1265>/Delay' */
  if ((int32_T)app_DW.icLoad_nn != 0) {
    /* Sum: '<S1265>/Sum' */
    app_DW.Delay_DSTATE_f = rtb_a_traj_FEMid;
  }

  /* Sum: '<S1265>/Sum' incorporates:
   *  Delay: '<S1265>/Delay'
   *  Product: '<S1265>/Product'
   *  Product: '<S1265>/Product1'
   */
  app_DW.Delay_DSTATE_f = app_DW.Delay_DSTATE_f * app_ConstB.alpha_f +
    app_ConstB.ualpha_l * rtb_a_traj_FEMid;

  /* Product: '<S1259>/Product' */
  rtb_a_traj_FEMid = app_DW.Delay_DSTATE_f * rtb_MatrixConcatenate1[2];

  /* Switch: '<S1261>/Switch' */
  if (Arb_is_LatCtrlActv_bl) {
    /* Switch: '<S1261>/Switch3' incorporates:
     *  Constant: '<S1261>/Constant4'
     *  Constant: '<S1261>/Constant5'
     *  Constant: '<S1272>/Constant'
     *  Delay: '<S1256>/Delay'
     *  Product: '<S1261>/Product1'
     *  RelationalOperator: '<S1272>/Compare'
     */
    if (rtb_t_min * app_DW.Delay_DSTATE_iu >= 0.0F) {
      i_0 = 1;
    } else {
      i_0 = 3;
    }

    /* End of Switch: '<S1261>/Switch3' */

    /* Sum: '<S1261>/Add' incorporates:
     *  Constant: '<S1261>/Constant'
     *  Delay: '<S1256>/Delay'
     *  Product: '<S1261>/Product'
     *  Product: '<S1261>/Product2'
     */
    rtb_MinMax_a0 = (real32_T)((real_T)(rtb_MatrixConcatenate1[1] * (real32_T)
      i_0 * rtb_t_min) * 0.02) + app_DW.Delay_DSTATE_iu;

    /* Switch: '<S1261>/Switch1' incorporates:
     *  Constant: '<S1258>/Constant'
     *  Constant: '<S1266>/Constant'
     *  Constant: '<S1267>/Constant'
     *  Constant: '<S1268>/Constant'
     *  Constant: '<S1269>/Constant'
     *  Constant: '<S1270>/Constant'
     *  Constant: '<S1271>/Constant'
     *  Delay: '<S1256>/Delay1'
     *  Logic: '<S1261>/Logical Operator'
     *  Logic: '<S1261>/Logical Operator1'
     *  Logic: '<S1261>/Logical Operator2'
     *  Logic: '<S1261>/Logical Operator3'
     *  Logic: '<S1261>/Logical Operator4'
     *  Logic: '<S1261>/Logical Operator5'
     *  Logic: '<S1261>/Logical Operator6'
     *  RelationalOperator: '<S1258>/Compare'
     *  RelationalOperator: '<S1266>/Compare'
     *  RelationalOperator: '<S1267>/Compare'
     *  RelationalOperator: '<S1268>/Compare'
     *  RelationalOperator: '<S1269>/Compare'
     *  RelationalOperator: '<S1270>/Compare'
     *  RelationalOperator: '<S1271>/Compare'
     */
    if ((!(DataTypeConversion28 >= 1.0F)) && (((rtb_t_min >= 0.0F) &&
          ((app_DW.Delay1_DSTATE_n < 3.0F) || (rtb_MinMax_a0 < 0.0F))) ||
         ((rtb_t_min <= 0.0F) && ((app_DW.Delay1_DSTATE_n > -3.0F) ||
           (rtb_MinMax_a0 > 0.0F))))) {
      /* Switch: '<S1261>/Switch' */
      app_DW.Delay_DSTATE_iu = rtb_MinMax_a0;
    }

    /* End of Switch: '<S1261>/Switch1' */
  } else {
    /* Switch: '<S1261>/Switch' incorporates:
     *  Constant: '<S1261>/Constant1'
     */
    app_DW.Delay_DSTATE_iu = 0.0F;
  }

  /* Switch: '<S1273>/Switch2' incorporates:
   *  Constant: '<S1261>/Constant2'
   *  RelationalOperator: '<S1273>/LowerRelop1'
   *  RelationalOperator: '<S1273>/UpperRelop'
   *  Switch: '<S1273>/Switch'
   */
  if (app_DW.Delay_DSTATE_iu > 3.0F) {
    /* Switch: '<S1261>/Switch' */
    app_DW.Delay_DSTATE_iu = 3.0F;
  } else {
    if (app_DW.Delay_DSTATE_iu < app_ConstB.UnaryMinus_e) {
      /* Switch: '<S1261>/Switch' incorporates:
       *  Switch: '<S1273>/Switch'
       */
      app_DW.Delay_DSTATE_iu = app_ConstB.UnaryMinus_e;
    }
  }

  /* End of Switch: '<S1273>/Switch2' */

  /* Switch: '<S1274>/Switch2' incorporates:
   *  RelationalOperator: '<S1274>/LowerRelop1'
   *  RelationalOperator: '<S1274>/UpperRelop'
   *  Switch: '<S1274>/Switch'
   *  UnaryMinus: '<S1262>/Unary Minus'
   */
  if (Switch > rtb_a_Min_Modify) {
    Switch = rtb_a_Min_Modify;
  } else {
    if (Switch < -rtb_a_Min_Modify) {
      /* Switch: '<S1274>/Switch' incorporates:
       *  UnaryMinus: '<S1262>/Unary Minus'
       */
      Switch = -rtb_a_Min_Modify;
    }
  }

  /* End of Switch: '<S1274>/Switch2' */

  /* Switch: '<S1264>/Switch2' incorporates:
   *  Constant: '<S1259>/Constant1'
   *  RelationalOperator: '<S1264>/LowerRelop1'
   *  RelationalOperator: '<S1264>/UpperRelop'
   *  Switch: '<S1264>/Switch'
   */
  if (rtb_a_traj_FEMid > 1.0F) {
    rtb_a_traj_FEMid = 1.0F;
  } else {
    if (rtb_a_traj_FEMid < app_ConstB.UnaryMinus_b) {
      /* Switch: '<S1264>/Switch' */
      rtb_a_traj_FEMid = app_ConstB.UnaryMinus_b;
    }
  }

  /* End of Switch: '<S1264>/Switch2' */

  /* Sum: '<S1256>/Sum' incorporates:
   *  Constant: '<S1262>/Constant'
   *  Constant: '<S1275>/Constant'
   *  Delay: '<S1256>/Delay'
   *  Delay: '<S1256>/Delay1'
   *  Product: '<S1275>/Product'
   *  Product: '<S1275>/Product1'
   *  Sum: '<S1275>/Add'
   *  Sum: '<S1275>/Subtract'
   */
  app_DW.Delay1_DSTATE_n = ((((1.0F - DFIn_a_EstdVSELongtAccel_sg) * 0.0F +
    Switch * DFIn_a_EstdVSELongtAccel_sg) + rtb_Add_g0) + rtb_a_traj_FEMid) +
    app_DW.Delay_DSTATE_iu;

  /* Chart: '<S1240>/Chart1' incorporates:
   *  Abs: '<S1262>/Abs'
   *  Constant: '<S1240>/c_VLatC_MainLoopTime_Sec1'
   *  Constant: '<S1240>/c_VLatC_MainLoopTime_Sec2'
   *  Constant: '<S1240>/k_VLatC_T_OvrrdDelayToqThd_sg'
   *  Constant: '<S1240>/k_VLatC_t_OvrrdDelayRsTm_sg1'
   *  RelationalOperator: '<S1240>/Relational Operator'
   */
  app_Chart4(DataTypeConversion28 > 1.0F, 0.02F, 0.6F, 0.02F,
             &rtb_DFIn_is_AEBStsDsbl_bl, &app_DW.sf_Chart1_d);

  /* Chart: '<S1240>/Chart2' incorporates:
   *  Constant: '<S1240>/c_VLatC_MainLoopTime_Sec'
   *  Constant: '<S1240>/k_VLatC_t_OvrrdDelayRsTm_sg'
   */
  if ((uint32_T)app_DW.is_active_c160_app == 0U) {
    app_DW.is_active_c160_app = 1U;
    app_DW.is_c160_app = app_IN_OFF_f;
    rtb_DFIn_is_AEBPStsDsbl_bl = false;
    app_DW.local_time = 0.0F;
  } else if ((int32_T)app_DW.is_c160_app == 1) {
    rtb_DFIn_is_AEBPStsDsbl_bl = false;
    if (app_DW.local_time > 2.0F) {
      app_DW.is_c160_app = app_IN_ON_a;
      rtb_DFIn_is_AEBPStsDsbl_bl = true;
      app_DW.local_time = 0.0F;
    } else if (Arb_is_LatCtrlActv_bl) {
      app_DW.local_time += 0.02F;
    } else {
      app_DW.local_time = 0.0F;
    }
  } else {
    /* case IN_ON: */
    rtb_DFIn_is_AEBPStsDsbl_bl = true;
    if (app_DW.local_time > 0.02F) {
      app_DW.is_c160_app = app_IN_OFF_f;
      rtb_DFIn_is_AEBPStsDsbl_bl = false;
      app_DW.local_time = 0.0F;
    } else if (!Arb_is_LatCtrlActv_bl) {
      app_DW.local_time += 0.02F;
    } else {
      app_DW.local_time = 0.0F;
    }
  }

  /* End of Chart: '<S1240>/Chart2' */

  /* Logic: '<S1240>/Logical Operator1' */
  rtb_DFIn_is_AEBStsDsbl_bl = (rtb_DFIn_is_AEBStsDsbl_bl &&
    rtb_DFIn_is_AEBPStsDsbl_bl);

  /* Chart: '<S1240>/OvrdDely' incorporates:
   *  Constant: '<S1240>/k_VLatC_indx_OvrrdDlyInitCof_sg'
   */
  if ((uint32_T)app_DW.is_active_c161_app == 0U) {
    app_DW.is_active_c161_app = 1U;
    app_DW.is_c161_app = app_IN_Norm;
    app_B.VRD_indx_DrvrOvrrdDlyCof_sg = 1.0F;
  } else if ((int32_T)app_DW.is_c161_app == 1) {
    if (app_B.VRD_indx_DrvrOvrrdDlyCof_sg >= 1.0F) {
      app_DW.is_c161_app = app_IN_Norm;
      app_B.VRD_indx_DrvrOvrrdDlyCof_sg = 1.0F;
    } else if (!rtb_DFIn_is_AEBStsDsbl_bl) {
      app_B.VRD_indx_DrvrOvrrdDlyCof_sg += app_ConstB.Product4;
    } else {
      app_B.VRD_indx_DrvrOvrrdDlyCof_sg = 0.38F;
    }
  } else {
    /* case IN_Norm: */
    if (rtb_DFIn_is_AEBStsDsbl_bl) {
      app_DW.is_c161_app = app_IN_Delay;
      app_B.VRD_indx_DrvrOvrrdDlyCof_sg = 0.38F;
    }
  }

  /* End of Chart: '<S1240>/OvrdDely' */

  /* Switch: '<S1243>/Switch' incorporates:
   *  Abs: '<S1262>/Abs'
   *  Delay: '<S1243>/Delay'
   *  Lookup_n-D: '<S1240>/1-D Lookup Table1'
   *  Product: '<S1240>/Product2'
   *  Product: '<S1240>/Product3'
   */
  if (Arb_is_LatCtrlActv_bl) {
    /* Switch: '<S1263>/Switch2' incorporates:
     *  Constant: '<S1256>/Constant'
     *  Delay: '<S1256>/Delay1'
     *  RelationalOperator: '<S1263>/LowerRelop1'
     *  RelationalOperator: '<S1263>/UpperRelop'
     *  Switch: '<S1263>/Switch'
     */
    if (app_DW.Delay1_DSTATE_n > 2.988F) {
      DFIn_a_EstdVSELongtAccel_sg = 2.988F;
    } else if (app_DW.Delay1_DSTATE_n < app_ConstB.UnaryMinus_hn) {
      /* Switch: '<S1263>/Switch' */
      DFIn_a_EstdVSELongtAccel_sg = app_ConstB.UnaryMinus_hn;
    } else {
      DFIn_a_EstdVSELongtAccel_sg = app_DW.Delay1_DSTATE_n;
    }

    /* End of Switch: '<S1263>/Switch2' */

    /* Switch: '<S1248>/Switch2' incorporates:
     *  Constant: '<S1240>/Constant5'
     *  Constant: '<S1240>/k_VLatC_indx_OvrrdDlyInitCof_sg'
     *  RelationalOperator: '<S1248>/LowerRelop1'
     *  RelationalOperator: '<S1248>/UpperRelop'
     *  Switch: '<S1248>/Switch'
     */
    if (app_B.VRD_indx_DrvrOvrrdDlyCof_sg > 1.0F) {
      rtb_Product_eqe = 1.0F;
    } else if (app_B.VRD_indx_DrvrOvrrdDlyCof_sg < 0.38F) {
      /* Switch: '<S1248>/Switch' incorporates:
       *  Constant: '<S1240>/k_VLatC_indx_OvrrdDlyInitCof_sg'
       */
      rtb_Product_eqe = 0.38F;
    } else {
      rtb_Product_eqe = app_B.VRD_indx_DrvrOvrrdDlyCof_sg;
    }

    /* End of Switch: '<S1248>/Switch2' */
    app_DW.Delay_DSTATE_d = DFIn_a_EstdVSELongtAccel_sg * look1_iflf_binlxpw
      (DataTypeConversion28, app_ConstP.uDLookupTable1_bp01Data_e,
       app_ConstP.uDLookupTable1_tableData_l, 16U) * rtb_Product_eqe;
  }

  /* End of Switch: '<S1243>/Switch' */

  /* Chart: '<S1243>/Chart' */
  if ((uint32_T)app_DW.is_active_c163_app == 0U) {
    app_DW.is_active_c163_app = 1U;
    app_DW.is_c163_app = app_IN_OFF_f;
    app_B.ramp_cof_m = 0.0F;
  } else {
    switch (app_DW.is_c163_app) {
     case app_IN_OFF_f:
      if (Arb_is_LatCtrlActv_bl) {
        app_DW.is_c163_app = app_IN_ON_Count_j;
        app_B.ramp_cof_m = 0.0F;
      }
      break;

     case app_IN_OFF_Count_o:
      if ((!Arb_is_LatCtrlActv_bl) && (app_B.ramp_cof_m <= 0.01F)) {
        app_DW.is_c163_app = app_IN_OFF_f;
        app_B.ramp_cof_m = 0.0F;
      } else if (Arb_is_LatCtrlActv_bl && (app_B.ramp_cof_m >= 0.99F)) {
        app_DW.is_c163_app = app_IN_ON_e;
        app_B.ramp_cof_m = 1.0F;
      } else if (Arb_is_LatCtrlActv_bl) {
        app_B.ramp_cof_m += 0.05F;
      } else {
        app_B.ramp_cof_m -= 0.05F;
      }
      break;

     case app_IN_ON_e:
      if (!Arb_is_LatCtrlActv_bl) {
        app_DW.is_c163_app = app_IN_OFF_Count_o;
        app_B.ramp_cof_m = 1.0F;
      }
      break;

     default:
      /* case IN_ON_Count: */
      if (Arb_is_LatCtrlActv_bl && (app_B.ramp_cof_m >= 0.99F)) {
        app_DW.is_c163_app = app_IN_ON_e;
        app_B.ramp_cof_m = 1.0F;
      } else if ((!Arb_is_LatCtrlActv_bl) && (app_B.ramp_cof_m <= 0.01F)) {
        app_DW.is_c163_app = app_IN_OFF_f;
        app_B.ramp_cof_m = 0.0F;
      } else if (Arb_is_LatCtrlActv_bl) {
        app_B.ramp_cof_m += 0.05F;
      } else {
        app_B.ramp_cof_m -= 0.05F;
      }
      break;
    }
  }

  /* End of Chart: '<S1243>/Chart' */

  /* Saturate: '<S1243>/Saturation' */
  if (app_B.ramp_cof_m > 1.0F) {
    rtb_Add_g0 = 1.0F;
  } else if (app_B.ramp_cof_m < 0.0F) {
    rtb_Add_g0 = 0.0F;
  } else {
    rtb_Add_g0 = app_B.ramp_cof_m;
  }

  /* End of Saturate: '<S1243>/Saturation' */

  /* Sum: '<S1243>/Sum' incorporates:
   *  Constant: '<S1243>/Constant'
   *  Constant: '<S1243>/Constant1'
   *  Delay: '<S1243>/Delay'
   *  Product: '<S1243>/Product'
   *  Product: '<S1243>/Product1'
   *  Sum: '<S1243>/Add'
   *  Sum: '<S1243>/Subtract'
   */
  DataTypeConversion28 = (1.0F - rtb_Add_g0) * 0.0F + app_DW.Delay_DSTATE_d *
    rtb_Add_g0;

  /* Delay: '<S1278>/Delay' */
  if (Arb_is_LatCtrlActv_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_l != 1)) {
    app_DW.icLoad_jv = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_l = (ZCSigState)Arb_is_LatCtrlActv_bl;
  if ((int32_T)app_DW.icLoad_jv != 0) {
    app_DW.Delay_DSTATE_lz = DataTypeConversion28;
  }

  /* Switch: '<S1278>/Switch' */
  if (Arb_is_LatCtrlActv_bl) {
    /* Sum: '<S1278>/Add1' incorporates:
     *  Delay: '<S1278>/Delay'
     */
    DFIn_a_EstdVSELongtAccel_sg = app_ConstB.Product_h + app_DW.Delay_DSTATE_lz;

    /* Switch: '<S1279>/Switch2' incorporates:
     *  RelationalOperator: '<S1279>/LowerRelop1'
     */
    if (DataTypeConversion28 > DFIn_a_EstdVSELongtAccel_sg) {
      DataTypeConversion28 = DFIn_a_EstdVSELongtAccel_sg;
    } else {
      /* Sum: '<S1278>/Add2' incorporates:
       *  Delay: '<S1278>/Delay'
       */
      DFIn_a_EstdVSELongtAccel_sg = app_DW.Delay_DSTATE_lz +
        app_ConstB.Product1_f;

      /* Switch: '<S1279>/Switch' incorporates:
       *  RelationalOperator: '<S1279>/UpperRelop'
       */
      if (DataTypeConversion28 < DFIn_a_EstdVSELongtAccel_sg) {
        DataTypeConversion28 = DFIn_a_EstdVSELongtAccel_sg;
      }

      /* End of Switch: '<S1279>/Switch' */
    }

    /* End of Switch: '<S1279>/Switch2' */
  }

  /* End of Switch: '<S1278>/Switch' */

  /* Saturate: '<S1139>/Saturation' */
  if (DataTypeConversion28 > 3.0F) {
    rtb_Add_g0 = 3.0F;
  } else if (DataTypeConversion28 < -3.0F) {
    rtb_Add_g0 = -3.0F;
  } else {
    rtb_Add_g0 = DataTypeConversion28;
  }

  /* End of Saturate: '<S1139>/Saturation' */

  /* Chart: '<S1067>/Chart4' incorporates:
   *  Abs: '<S1067>/Abs'
   *  Constant: '<S1067>/Constant10'
   *  Constant: '<S1067>/Constant11'
   *  Constant: '<S1067>/Constant12'
   *  Constant: '<S1072>/Constant'
   *  RelationalOperator: '<S1072>/Compare'
   */
  app_Chart4(fabsf(rtb_Add_g0) > 2.95F, 0.02F, 1.0F, 1.0F,
             &rtb_DFIn_is_AEBStsDsbl_bl, &app_DW.sf_Chart4_f);

  /* Product: '<S1104>/Divide' incorporates:
   *  Bias: '<S1104>/Bias'
   *  Constant: '<S1104>/Constant'
   *  Product: '<S1099>/Divide'
   */
  rtb_Add_g0 = (rtb_Add_g0 + 10.24F) / 0.01F;
  DFIn_a_EstdVSELongtAccel_sg = floorf(rtb_Add_g0);
  if (rtIsNaNF(DFIn_a_EstdVSELongtAccel_sg)) {
    DFIn_a_EstdVSELongtAccel_sg = 0.0F;
  } else {
    DFIn_a_EstdVSELongtAccel_sg = fmodf(DFIn_a_EstdVSELongtAccel_sg, 65536.0F);
  }

  /* Chart: '<S1098>/Chart' incorporates:
   *  Constant: '<S1070>/Constant'
   *  Constant: '<S1070>/Constant1'
   *  DataTypeConversion: '<S1098>/Data Type Conversion'
   */
  app_Chart_g(4, app_ConstB.Add_m, (uint32_T)app_B.count_b, app_ConstP.pooled135,
              app_B.msg_n);

  /* Chart: '<S1102>/Chart' incorporates:
   *  Constant: '<S1070>/Constant9'
   *  DataTypeConversion: '<S1067>/Data Type Conversion'
   *  DataTypeConversion: '<S1102>/Data Type Conversion'
   */
  app_Chart_c(1, app_ConstB.Add_gz, (uint32_T)rtb_DFIn_is_AEBStsDsbl_bl,
              app_B.msg_n, app_B.msg);

  /* Chart: '<S1099>/Chart' */
  for (i = 0; (int32_T)i < 64; i = (int8_T)(int32_T)((int32_T)i + 1)) {
    app_B.msg_d[(int32_T)i] = app_B.msg[i];
  }

  i = 10;

  /* DataTypeConversion: '<S1099>/Data Type Conversion' */
  rtb_Product_eqe = floorf(rtb_Add_g0);
  if (rtIsNaNF(rtb_Product_eqe)) {
    /* Chart: '<S1099>/Chart' */
    i_0 = 0;
  } else {
    /* Chart: '<S1099>/Chart' */
    i_0 = (int32_T)(uint32_T)fmodf(rtb_Product_eqe, 4.2949673E+9F);
  }

  /* End of DataTypeConversion: '<S1099>/Data Type Conversion' */

  /* Chart: '<S1099>/Chart' */
  while ((int32_T)i >= 0) {
    s1239_iter = (int32_T)rt_powd_snf(2.0, (real_T)i);
    tmp = (int32_T)(uint32_T)((real_T)i_0 / (real_T)s1239_iter);
    i_0 -= (int32_T)(tmp * s1239_iter);
    if (i_0 < 0) {
      i_0 = 0;
    }

    if ((uint32_T)tmp > 255U) {
      tmp = 255;
    }

    app_B.msg_d[(int32_T)((int32_T)((int32_T)app_ConstB.Add_fa - (int32_T)i) - 1)]
      = (uint8_T)tmp;
    i = (int8_T)(int32_T)((int32_T)i - 1);
  }

  /* Chart: '<S1100>/Chart' incorporates:
   *  ArithShift: '<S1103>/Shift Arithmetic2'
   *  ArithShift: '<S1103>/Shift Arithmetic3'
   *  ArithShift: '<S1104>/Shift Arithmetic'
   *  ArithShift: '<S1104>/Shift Arithmetic1'
   *  ArithShift: '<S1104>/Shift Arithmetic10'
   *  ArithShift: '<S1104>/Shift Arithmetic11'
   *  ArithShift: '<S1104>/Shift Arithmetic12'
   *  ArithShift: '<S1104>/Shift Arithmetic13'
   *  ArithShift: '<S1104>/Shift Arithmetic14'
   *  ArithShift: '<S1104>/Shift Arithmetic15'
   *  ArithShift: '<S1104>/Shift Arithmetic16'
   *  ArithShift: '<S1104>/Shift Arithmetic17'
   *  ArithShift: '<S1104>/Shift Arithmetic18'
   *  ArithShift: '<S1104>/Shift Arithmetic19'
   *  ArithShift: '<S1104>/Shift Arithmetic2'
   *  ArithShift: '<S1104>/Shift Arithmetic20'
   *  ArithShift: '<S1104>/Shift Arithmetic21'
   *  ArithShift: '<S1104>/Shift Arithmetic3'
   *  ArithShift: '<S1104>/Shift Arithmetic4'
   *  ArithShift: '<S1104>/Shift Arithmetic5'
   *  ArithShift: '<S1104>/Shift Arithmetic6'
   *  ArithShift: '<S1104>/Shift Arithmetic7'
   *  ArithShift: '<S1104>/Shift Arithmetic8'
   *  ArithShift: '<S1104>/Shift Arithmetic9'
   *  Constant: '<S1070>/Constant5'
   *  Constant: '<S1097>/Constant'
   *  Product: '<S1104>/Divide'
   *  Product: '<S1105>/Product1'
   *  Product: '<S1105>/Product10'
   *  Product: '<S1105>/Product11'
   *  Product: '<S1105>/Product12'
   *  Product: '<S1105>/Product2'
   *  Product: '<S1105>/Product3'
   *  Product: '<S1105>/Product4'
   *  Product: '<S1105>/Product5'
   *  Product: '<S1105>/Product6'
   *  Product: '<S1105>/Product7'
   *  Product: '<S1105>/Product8'
   *  Product: '<S1105>/Product9'
   *  S-Function (sfix_bitop): '<S1097>/Xor'
   *  Sum: '<S1097>/Add'
   *  Sum: '<S1097>/Add1'
   *  Sum: '<S1105>/Add'
   *  Switch: '<S1139>/Switch1'
   */
  app_Chart_c(14, app_ConstB.Add_d, (uint32_T)((uint32_T)((uint32_T)((uint32_T)
    ((uint32_T)((uint32_T)((uint32_T)((uint32_T)((uint32_T)((uint32_T)
    app_B.count_b + (uint32_T)((uint32_T)((uint32_T)((uint32_T)((uint32_T)
    ((uint32_T)((uint32_T)((uint32_T)(int32_T)(uint32_T)((uint32_T)(int32_T)
    ((int32_T)Arb_is_LatCtrlActv_bl << 7) >> 7) << 12) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 5) >> 15) << 11)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 6) >> 15) << 10)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 7) >> 15) << 9)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 8) >> 15) << 8)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 9) >> 15) << 7)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 10) >> 15) << 6))) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 11) >> 15) << 5)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 12) >> 15) << 4)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 13) >> 15) << 3)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 14) >> 15) << 2)) + (uint32_T)((uint32_T)
    (int32_T)(uint32_T)((uint32_T)(uint16_T)(int32_T)((int32_T)(uint16_T)
    DFIn_a_EstdVSELongtAccel_sg << 15) >> 15) << 1)) + (uint32_T)
    app_ConstB.Product_p) ^ 16383U) + 1U), app_B.msg_d, app_B.msg_f);

  /* Chart: '<S1101>/Chart' incorporates:
   *  Constant: '<S1070>/Constant8'
   *  DataTypeConversion: '<S1101>/Data Type Conversion'
   *  Switch: '<S1139>/Switch1'
   */
  app_Chart_c(2, app_ConstB.Add_p, (uint32_T)Arb_is_LatCtrlActv_bl, app_B.msg_f,
              app_B.msg_c);

  /* Product: '<S1096>/Product' */
  rtb_out_cond_n3 = 0U;

  /* Product: '<S1096>/Product1' */
  P_ACC_V_MaxCrsSpdThrs_u8 = 0U;

  /* Product: '<S1096>/Product2' */
  DataTypeConversion2 = 0U;

  /* Product: '<S1096>/Product3' */
  Traj_Numb = 0U;

  /* Product: '<S1096>/Product4' */
  Merge2_a = 0U;

  /* Product: '<S1096>/Product5' */
  tmp_1 = 0U;

  /* Product: '<S1096>/Product6' */
  tmp_2 = 0U;

  /* Product: '<S1096>/Product7' */
  tmp_3 = 0U;
  for (i_0 = 0; i_0 < 8; i_0++) {
    /* Product: '<S1096>/Product' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    rtb_out_cond_n3 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_c[i_0] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)rtb_out_cond_n3);

    /* Product: '<S1096>/Product1' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    P_ACC_V_MaxCrsSpdThrs_u8 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_c[(int32_T)(i_0 + 8)] * (uint32_T)
       app_ConstP.pooled137[i_0]) + (uint32_T)P_ACC_V_MaxCrsSpdThrs_u8);

    /* Product: '<S1096>/Product2' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    DataTypeConversion2 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_c[(int32_T)(i_0 + 16)] * (uint32_T)
       app_ConstP.pooled137[i_0]) + (uint32_T)DataTypeConversion2);

    /* Product: '<S1096>/Product3' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    Traj_Numb = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_c[(int32_T)(i_0 + 24)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)Traj_Numb);

    /* Product: '<S1096>/Product4' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    Merge2_a = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_c[(int32_T)(i_0 + 32)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)Merge2_a);

    /* Product: '<S1096>/Product5' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    tmp_1 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_c[(int32_T)(i_0 + 40)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_1);

    /* Product: '<S1096>/Product6' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    tmp_2 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_c[(int32_T)(i_0 + 48)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_2);

    /* Product: '<S1096>/Product7' incorporates:
     *  Constant: '<S1096>/Constant3'
     */
    tmp_3 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_c[(int32_T)(i_0 + 56)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_3);
  }

  /* SignalConversion: '<S1070>/Signal Copy' incorporates:
   *  Product: '<S1096>/Product'
   *  Product: '<S1096>/Product1'
   *  Product: '<S1096>/Product2'
   *  Product: '<S1096>/Product3'
   *  Product: '<S1096>/Product4'
   *  Product: '<S1096>/Product5'
   *  Product: '<S1096>/Product6'
   *  Product: '<S1096>/Product7'
   */
  FVCM_EPS_Frame[0] = rtb_out_cond_n3;
  FVCM_EPS_Frame[1] = P_ACC_V_MaxCrsSpdThrs_u8;
  FVCM_EPS_Frame[2] = DataTypeConversion2;
  FVCM_EPS_Frame[3] = Traj_Numb;
  FVCM_EPS_Frame[4] = Merge2_a;
  FVCM_EPS_Frame[5] = tmp_1;
  FVCM_EPS_Frame[6] = tmp_2;
  FVCM_EPS_Frame[7] = tmp_3;

  /* Chart: '<S1068>/Chart' */
  app_Chart_k(&app_B.count_f);

  /* RelationalOperator: '<S1081>/Compare' incorporates:
   *  Constant: '<S1081>/Constant'
   *  Inport: '<Root>/lateralPlan_rProb'
   */
  rtb_DFIn_is_AEBStsDsbl_bl = (arg_lateralPlan_rProb >= 0.5F);

  /* RelationalOperator: '<S1082>/Compare' incorporates:
   *  Constant: '<S1082>/Constant'
   *  Inport: '<Root>/lateralPlan_dProb'
   */
  rtb_Compare_hj = (arg_lateralPlan_dProb >= 0.5F);

  /* Chart: '<S1069>/Chart1' incorporates:
   *  Logic: '<S1069>/Logical Operator1'
   */
  app_Chart1_p(Arb_is_LatCtrlActv_bl, rtb_Compare_hj ||
               rtb_DFIn_is_AEBStsDsbl_bl, &rtb_out_cond_n3);

  /* RelationalOperator: '<S1080>/Compare' incorporates:
   *  Constant: '<S1080>/Constant'
   *  Inport: '<Root>/lateralPlan_lProb'
   */
  rtb_DFIn_is_AEBStsDsbl_bl = (arg_lateralPlan_lProb >= 0.5F);

  /* Chart: '<S1069>/Chart2' incorporates:
   *  Logic: '<S1069>/Logical Operator'
   */
  app_Chart1_p(Arb_is_LatCtrlActv_bl, rtb_Compare_hj ||
               rtb_DFIn_is_AEBStsDsbl_bl, &P_ACC_V_MaxCrsSpdThrs_u8);

  /* Chart: '<S1084>/Chart' incorporates:
   *  Constant: '<S1069>/Constant13'
   *  Constant: '<S1069>/Constant14'
   */
  app_Chart_g(2, app_ConstB.Add_pr, app_ConstB.DataTypeConversion,
              app_ConstP.pooled135, app_B.msg_a);

  /* Chart: '<S1085>/Chart' incorporates:
   *  Constant: '<S1069>/Constant17'
   *  DataTypeConversion: '<S1085>/Data Type Conversion'
   */
  app_Chart_c(3, app_ConstB.Add_e, (uint32_T)P_ACC_V_MaxCrsSpdThrs_u8,
              app_B.msg_a, app_B.msg_m);

  /* Chart: '<S1086>/Chart' incorporates:
   *  Constant: '<S1069>/Constant19'
   *  DataTypeConversion: '<S1086>/Data Type Conversion'
   */
  app_Chart_c(3, app_ConstB.Add_n, (uint32_T)rtb_out_cond_n3, app_B.msg_m,
              app_B.msg_g);

  /* Switch: '<S1064>/Switch' incorporates:
   *  Constant: '<S1064>/Constant15'
   *  Constant: '<S1064>/Constant16'
   */
  if (Arb_is_LatCtrlActv_bl) {
    rtb_out_cond_n3 = 2U;
  } else {
    rtb_out_cond_n3 = 1U;
  }

  /* End of Switch: '<S1064>/Switch' */

  /* Chart: '<S1087>/Chart' incorporates:
   *  Constant: '<S1069>/Constant21'
   *  DataTypeConversion: '<S1087>/Data Type Conversion'
   */
  app_Chart_c(3, app_ConstB.Add_nv, (uint32_T)rtb_out_cond_n3, app_B.msg_g,
              app_B.msg_i);

  /* Product: '<S1083>/Product' */
  rtb_out_cond_n3 = 0U;

  /* Product: '<S1083>/Product1' */
  P_ACC_V_MaxCrsSpdThrs_u8 = 0U;

  /* Product: '<S1083>/Product2' */
  DataTypeConversion2 = 0U;

  /* Product: '<S1083>/Product3' */
  Traj_Numb = 0U;

  /* Product: '<S1083>/Product4' */
  Merge2_a = 0U;

  /* Product: '<S1083>/Product5' */
  tmp_1 = 0U;

  /* Product: '<S1083>/Product6' */
  tmp_2 = 0U;

  /* Product: '<S1083>/Product7' */
  tmp_3 = 0U;
  for (i_0 = 0; i_0 < 8; i_0++) {
    /* Product: '<S1083>/Product' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    rtb_out_cond_n3 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_i[i_0] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)rtb_out_cond_n3);

    /* Product: '<S1083>/Product1' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    P_ACC_V_MaxCrsSpdThrs_u8 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_i[(int32_T)(i_0 + 8)] * (uint32_T)
       app_ConstP.pooled137[i_0]) + (uint32_T)P_ACC_V_MaxCrsSpdThrs_u8);

    /* Product: '<S1083>/Product2' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    DataTypeConversion2 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)
      ((uint32_T)app_B.msg_i[(int32_T)(i_0 + 16)] * (uint32_T)
       app_ConstP.pooled137[i_0]) + (uint32_T)DataTypeConversion2);

    /* Product: '<S1083>/Product3' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    Traj_Numb = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_i[(int32_T)(i_0 + 24)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)Traj_Numb);

    /* Product: '<S1083>/Product4' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    Merge2_a = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_i[(int32_T)(i_0 + 32)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)Merge2_a);

    /* Product: '<S1083>/Product5' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    tmp_1 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_i[(int32_T)(i_0 + 40)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_1);

    /* Product: '<S1083>/Product6' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    tmp_2 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_i[(int32_T)(i_0 + 48)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_2);

    /* Product: '<S1083>/Product7' incorporates:
     *  Constant: '<S1083>/Constant3'
     */
    tmp_3 = (uint8_T)(uint32_T)((uint32_T)(uint8_T)(uint32_T)((uint32_T)
      app_B.msg_i[(int32_T)(i_0 + 56)] * (uint32_T)app_ConstP.pooled137[i_0]) +
      (uint32_T)tmp_3);
  }

  /* SignalConversion: '<S1069>/Signal Copy' incorporates:
   *  Product: '<S1083>/Product'
   *  Product: '<S1083>/Product1'
   *  Product: '<S1083>/Product2'
   *  Product: '<S1083>/Product3'
   *  Product: '<S1083>/Product4'
   *  Product: '<S1083>/Product5'
   *  Product: '<S1083>/Product6'
   *  Product: '<S1083>/Product7'
   */
  FVCM_HMI_Frame[0] = rtb_out_cond_n3;
  FVCM_HMI_Frame[1] = P_ACC_V_MaxCrsSpdThrs_u8;
  FVCM_HMI_Frame[2] = DataTypeConversion2;
  FVCM_HMI_Frame[3] = Traj_Numb;
  FVCM_HMI_Frame[4] = Merge2_a;
  FVCM_HMI_Frame[5] = tmp_1;
  FVCM_HMI_Frame[6] = tmp_2;
  FVCM_HMI_Frame[7] = tmp_3;

  /* Chart: '<S1121>/Chart6' incorporates:
   *  Constant: '<S1121>/Constant12'
   *  Constant: '<S1121>/Constant13'
   *  Constant: '<S1121>/Constant14'
   */
  app_Chart4(LogicalOperator, 0.02F, 1.0F, 0.01F, &rtb_DFIn_is_AEBStsDsbl_bl,
             &app_DW.sf_Chart6);

  /* Saturate: '<S1065>/Saturation' */
  if (rtb_a_Max_Modify < 1.0F) {
    rtb_a_Min_Modify = 1.0F;
  } else {
    rtb_a_Min_Modify = rtb_a_Max_Modify;
  }

  /* End of Saturate: '<S1065>/Saturation' */

  /* Product: '<S1065>/Divide' incorporates:
   *  Gain: '<S1065>/Gain1'
   */
  mpc_plan_desCurve = 0.0174532924F * rtb_Gain5_i / rtb_a_Min_Modify;

  /* Chart: '<S1144>/Chart7' incorporates:
   *  Abs: '<S1144>/Abs'
   *  Constant: '<S1144>/Constant1'
   *  Constant: '<S1144>/Constant11'
   *  Constant: '<S1144>/Constant12'
   *  Constant: '<S1193>/Constant'
   *  Inport: '<Root>/lateralPlan_pathCof_C1'
   *  RelationalOperator: '<S1193>/Compare'
   */
  app_Chart4(fabsf(arg_lateralPlan_pathCof_C1) > 0.04F, 1.0F, 0.1F, 0.02F,
             &LogicalOperator, &app_DW.sf_Chart7_k);

  /* Chart: '<S1144>/Chart1' incorporates:
   *  Abs: '<S1144>/Abs1'
   *  Constant: '<S1144>/Constant2'
   *  Constant: '<S1144>/Constant3'
   *  Constant: '<S1144>/Constant4'
   *  Constant: '<S1192>/Constant'
   *  Inport: '<Root>/lateralPlan_pathCof_C0'
   *  RelationalOperator: '<S1192>/Compare'
   */
  app_Chart4(fabsf(arg_lateralPlan_pathCof_C0) > 0.5F, 1.0F, 0.1F, 0.02F,
             &rtb_DFIn_is_AEBStsDsbl_bl, &app_DW.sf_Chart1_j);

  /* Chart: '<S1144>/Chart2' incorporates:
   *  Abs: '<S1144>/Abs2'
   *  Constant: '<S1144>/Constant5'
   *  Constant: '<S1144>/Constant6'
   *  Constant: '<S1144>/Constant7'
   *  Constant: '<S1194>/Constant'
   *  RelationalOperator: '<S1194>/Compare'
   */
  app_Chart4(fabsf(m_VehCP_T_DrvrStrgDlvrdToq_sg) < 1.0F, 1.0F, 0.1F, 0.02F,
             &rtb_DFIn_is_AEBPStsDsbl_bl, &app_DW.sf_Chart2_fb);

  /* Logic: '<S1144>/Logical Operator3' incorporates:
   *  Logic: '<S1144>/Logical Operator2'
   */
  LogicalOperator = ((LogicalOperator || rtb_DFIn_is_AEBStsDsbl_bl) &&
                     rtb_DFIn_is_AEBPStsDsbl_bl);

  /* Chart: '<S1144>/Chart' incorporates:
   *  Constant: '<S1144>/Constant10'
   *  Constant: '<S1144>/Constant9'
   *  RelationalOperator: '<S1196>/FixPt Relational Operator'
   *  UnitDelay: '<S1196>/Delay Input1'
   *
   * Block description for '<S1196>/Delay Input1':
   *
   *  Store in Global RAM
   */
  if ((uint32_T)app_DW.is_active_c149_app == 0U) {
    app_DW.is_active_c149_app = 1U;
    app_DW.local_time_f = 0.0F;
    rtb_DFIn_is_AEBStsDsbl_bl = true;
  } else if (((int32_T)LogicalOperator > (int32_T)app_DW.DelayInput1_DSTATE_o) ||
             ((app_DW.local_time_f > 0.1F) && LogicalOperator)) {
    app_DW.local_time_f = 0.0F;
    rtb_DFIn_is_AEBStsDsbl_bl = true;
  } else {
    rtb_DFIn_is_AEBStsDsbl_bl = false;
    if (LogicalOperator) {
      app_DW.local_time_f += 0.02F;
    } else {
      app_DW.local_time_f = 0.0F;
    }
  }

  /* End of Chart: '<S1144>/Chart' */

  /* Logic: '<S1144>/Logical Operator1' incorporates:
   *  Constant: '<S1191>/Constant'
   *  DataTypeConversion: '<S1065>/Data Type Conversion'
   *  Logic: '<S1144>/Logical Operator'
   *  RelationalOperator: '<S1191>/Compare'
   *  RelationalOperator: '<S1195>/FixPt Relational Operator'
   *  UnitDelay: '<S1195>/Delay Input1'
   *
   * Block description for '<S1195>/Delay Input1':
   *
   *  Store in Global RAM
   */
  rtb_DFIn_is_AEBStsDsbl_bl = (((Arb_is_LatCtrlActv_bl != (int32_T)
    app_DW.DelayInput1_DSTATE_i) || rtb_DFIn_is_AEBStsDsbl_bl) &&
    (rtb_a_Max_Modify >= 5.0F));

  /* Delay: '<S1142>/Delay' incorporates:
   *  Gain: '<S1142>/Gain3'
   *  Gain: '<S1142>/Gain4'
   *  Gain: '<S1142>/Gain5'
   *  Gain: '<S1142>/Gain6'
   *  Inport: '<Root>/lateralPlan_pathCof_C0'
   *  Inport: '<Root>/lateralPlan_pathCof_C1'
   *  Inport: '<Root>/lateralPlan_pathCof_C2'
   *  Product: '<S1142>/Product'
   *  Product: '<S1142>/Product1'
   *  Product: '<S1142>/Product2'
   *  Sum: '<S1142>/Subtract'
   */
  if (rtb_DFIn_is_AEBStsDsbl_bl && ((int32_T)app_PrevZCX.Delay_Reset_ZCE_p != 1))
  {
    app_DW.icLoad_je = 1U;
  }

  app_PrevZCX.Delay_Reset_ZCE_p = (ZCSigState)rtb_DFIn_is_AEBStsDsbl_bl;
  if ((int32_T)app_DW.icLoad_je != 0) {
    app_DW.Delay_DSTATE_cg[0] = -arg_lateralPlan_pathCof_C0;
    app_DW.Delay_DSTATE_cg[1] = -(arg_lateralPlan_pathCof_C1 * rtb_a_Max_Modify);
    app_DW.Delay_DSTATE_cg[2] = (0.0174532924F * m_VehCP_yr_VehDynYawRate_sg -
      2.0F * arg_lateralPlan_pathCof_C2 * rtb_a_Max_Modify) * rtb_a_Max_Modify;
  }

  /* End of Delay: '<S1142>/Delay' */

  /* Chart: '<S1137>/Planning_Scheduler' incorporates:
   *  Constant: '<S1137>/Constant'
   *  Constant: '<S1137>/Constant4'
   */
  if ((uint32_T)app_DW.is_active_c153_app == 0U) {
    app_DW.is_active_c153_app = 1U;
    app_B.plan_time = 0.0F;

    /* Outputs for Function Call SubSystem: '<S1137>/Planner' */
    app_Planner(app_DW.Delay_DSTATE_cg, app_B.cost_traj, &app_B.Planner,
                &app_ConstB.Planner);

    /* End of Outputs for SubSystem: '<S1137>/Planner' */
  } else {
    app_B.plan_time += 0.02F;
    if ((app_B.plan_time >= 0.1F) || rtb_DFIn_is_AEBStsDsbl_bl) {
      /* Outputs for Function Call SubSystem: '<S1137>/Planner' */
      app_Planner(app_DW.Delay_DSTATE_cg, app_B.cost_traj, &app_B.Planner,
                  &app_ConstB.Planner);

      /* End of Outputs for SubSystem: '<S1137>/Planner' */
      app_B.plan_time = 0.0F;
    }
  }

  /* End of Chart: '<S1137>/Planning_Scheduler' */

  /* Chart: '<S1138>/Chart' */
  i_0 = (int32_T)(uint32_T)((uint32_T)app_B.count + 1U);
  if ((uint32_T)((uint32_T)app_B.count + 1U) > 255U) {
    i_0 = 255;
  }

  app_B.count = (uint8_T)i_0;
  if ((int32_T)app_B.count > 2) {
    app_B.count = 0U;
  }

  /* End of Chart: '<S1138>/Chart' */

  /* Update for S-Function (sfix_udelay): '<S1060>/Tapped Delay' incorporates:
   *  UnitDelay: '<S1035>/Unit Delay'
   */
  for (i_0 = 0; i_0 < 9; i_0++) {
    app_DW.TappedDelay_X[i_0] = app_DW.TappedDelay_X[(int_T)(i_0 + 1)];
  }

  app_DW.TappedDelay_X[9] = app_DW.UnitDelay_DSTATE_o;

  /* End of Update for S-Function (sfix_udelay): '<S1060>/Tapped Delay' */

  /* Update for UnitDelay: '<S1060>/Unit Delay2' */
  app_DW.UnitDelay2_DSTATE = rtb_DFIn_v_VIDPEgoVehSpdAvgFilt_sg;

  /* Update for UnitDelay: '<S1037>/Unit Delay' incorporates:
   *  DataTypeConversion: '<S1060>/Data Type Conversion7'
   *  UnitDelay: '<S1060>/spdD3'
   */
  app_DW.UnitDelay_DSTATE_c = (real32_T)app_DW.spdD3_DSTATE;

  /* Update for UnitDelay: '<S93>/Unit Delay8' incorporates:
   *  Delay: '<S3>/Delay2'
   */
  app_DW.UnitDelay8_DSTATE = app_DW.Delay2_DSTATE_n;

  /* Update for UnitDelay: '<S93>/Unit Delay7' incorporates:
   *  Delay: '<S3>/Delay1'
   */
  app_DW.UnitDelay7_DSTATE = app_DW.Delay1_DSTATE_d;

  /* Update for UnitDelay: '<S1040>/Unit Delay' */
  app_DW.UnitDelay_DSTATE_d = rtb_Divide1;

  /* Update for UnitDelay: '<S1035>/Unit Delay1' */
  app_DW.UnitDelay1_DSTATE_f = rtb_LogicalOperator2_kx;

  /* Update for Delay: '<S74>/Delay9' */
  app_DW.icLoad = 0U;
  for (i_0 = 0; i_0 < 8; i_0++) {
    app_DW.Delay9_DSTATE[i_0] = app_DW.Delay9_DSTATE[(int_T)(i_0 + 1)];
  }

  app_DW.Delay9_DSTATE[8] = app_B.CANUnpack_o1;

  /* End of Update for Delay: '<S74>/Delay9' */

  /* Update for Delay: '<S74>/Delay8' */
  app_DW.icLoad_e = 0U;
  for (i_0 = 0; i_0 < 7; i_0++) {
    app_DW.Delay8_DSTATE[i_0] = app_DW.Delay8_DSTATE[(int_T)(i_0 + 1)];
  }

  app_DW.Delay8_DSTATE[7] = app_B.CANUnpack_o1;

  /* End of Update for Delay: '<S74>/Delay8' */

  /* Update for Delay: '<S74>/Delay7' */
  app_DW.icLoad_h = 0U;
  for (i_0 = 0; i_0 < 6; i_0++) {
    app_DW.Delay7_DSTATE[i_0] = app_DW.Delay7_DSTATE[(int_T)(i_0 + 1)];
  }

  app_DW.Delay7_DSTATE[6] = app_B.CANUnpack_o1;

  /* End of Update for Delay: '<S74>/Delay7' */

  /* Update for Delay: '<S74>/Delay6' */
  app_DW.icLoad_i = 0U;
  for (i_0 = 0; i_0 < 5; i_0++) {
    app_DW.Delay6_DSTATE[i_0] = app_DW.Delay6_DSTATE[(int_T)(i_0 + 1)];
  }

  app_DW.Delay6_DSTATE[5] = app_B.CANUnpack_o1;

  /* End of Update for Delay: '<S74>/Delay6' */

  /* Update for Delay: '<S74>/Delay5' */
  app_DW.icLoad_c = 0U;
  app_DW.Delay5_DSTATE[0] = app_DW.Delay5_DSTATE[1];
  app_DW.Delay5_DSTATE[1] = app_DW.Delay5_DSTATE[2];
  app_DW.Delay5_DSTATE[2] = app_DW.Delay5_DSTATE[3];
  app_DW.Delay5_DSTATE[3] = app_DW.Delay5_DSTATE[4];
  app_DW.Delay5_DSTATE[4] = app_B.CANUnpack_o1;

  /* Update for Delay: '<S74>/Delay' */
  app_DW.icLoad_if = 0U;
  app_DW.Delay_DSTATE[0] = app_DW.Delay_DSTATE[1];
  app_DW.Delay_DSTATE[1] = app_DW.Delay_DSTATE[2];
  app_DW.Delay_DSTATE[2] = app_DW.Delay_DSTATE[3];
  app_DW.Delay_DSTATE[3] = app_B.CANUnpack_o1;

  /* Update for Delay: '<S74>/Delay1' */
  app_DW.icLoad_ed = 0U;
  app_DW.Delay1_DSTATE[0] = app_DW.Delay1_DSTATE[1];
  app_DW.Delay1_DSTATE[1] = app_DW.Delay1_DSTATE[2];
  app_DW.Delay1_DSTATE[2] = app_B.CANUnpack_o1;

  /* Update for Delay: '<S74>/Delay2' */
  app_DW.icLoad_l = 0U;
  app_DW.Delay2_DSTATE[0] = app_DW.Delay2_DSTATE[1];
  app_DW.Delay2_DSTATE[1] = app_B.CANUnpack_o1;

  /* Update for Delay: '<S74>/Delay3' */
  app_DW.icLoad_ll = 0U;
  app_DW.Delay3_DSTATE = app_B.CANUnpack_o1;

  /* Update for Delay: '<S84>/Delay' */
  app_DW.icLoad_n = 0U;
  app_DW.Delay_DSTATE_j = m_VehCP_yr_VehDynYawRate_sg;

  /* Update for UnitDelay: '<S78>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion19'
   *
   * Block description for '<S78>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_k = (app_B.BCM_LDircnIO != 0.0);

  /* Update for UnitDelay: '<S79>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion23'
   *
   * Block description for '<S79>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_e = (app_B.BCM_RDircnIO != 0.0);

  /* Update for Delay: '<S81>/Delay' */
  app_DW.icLoad_j = 0U;
  app_DW.Delay_DSTATE_a = m_VehCP_angD_StrgWhlAng_sg;

  /* Update for Delay: '<S82>/Delay' */
  app_DW.icLoad_k = 0U;
  app_DW.Delay_DSTATE_jz = m_VehCP_V_VehSpdAvgDrvn_sg;

  /* Update for Delay: '<S85>/Delay' */
  app_DW.icLoad_e0 = 0U;
  app_DW.Delay_DSTATE_k = m_VehCP_W_StrgWhlAngGrd_sg;

  /* Update for UnitDelay: '<S115>/Delay Input1'
   *
   * Block description for '<S115>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_d = app_B.OR_e;

  /* Update for UnitDelay: '<S130>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S121>/Data Type Conversion'
   *
   * Block description for '<S130>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_m = (uint8_T)rtb_DataTypeConversion37;

  /* Update for Delay: '<S3>/Delay1' incorporates:
   *  Switch: '<S116>/Switch'
   */
  app_DW.Delay1_DSTATE_d = (uint8_T)rtb_DFIn_is_EPBAppcnStsApp_bl;

  /* Update for Delay: '<S3>/Delay2' incorporates:
   *  Logic: '<S117>/Logical Operator1'
   *  Logic: '<S117>/Logical Operator2'
   */
  app_DW.Delay2_DSTATE_n = (uint8_T)(longt_out_isCtrlEngage && (!rtb_Out_dl));

  /* Update for UnitDelay: '<S1035>/Unit Delay' */
  app_DW.UnitDelay_DSTATE_o = rtb_Switch_l5;

  /* Update for UnitDelay: '<S1118>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion46'
   *
   * Block description for '<S1118>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_ma = (app_B.IPK_CCSwStsSetSWA != 0.0);

  /* Update for UnitDelay: '<S1117>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S75>/Data Type Conversion45'
   *
   * Block description for '<S1117>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_n = (app_B.IPK_CCSwStsRsmSWA != 0.0);

  /* Update for Delay: '<S1119>/Delay' */
  app_DW.Delay_DSTATE_iq = Arb_is_LatCtrlActv_bl;

  /* Update for Delay: '<S1287>/Delay' */
  app_DW.icLoad_g = 0U;
  app_DW.Delay_DSTATE_g = rtb_uDLookupTable;

  /* Update for Delay: '<S1285>/Delay' */
  app_DW.icLoad_cb = 0U;

  /* Update for Delay: '<S1295>/Delay' */
  app_DW.icLoad_f = 0U;

  /* Update for Delay: '<S1315>/Delay' */
  app_DW.icLoad_a = 0U;
  app_DW.Delay_DSTATE_j1 = rtb_ACC_v_ACCSetSpd_sg;

  /* Update for Delay: '<S1253>/Delay' */
  app_DW.icLoad_b = 0U;
  app_DW.Delay_DSTATE_eg = rtb_MinMax1_p;

  /* Update for UnitDelay: '<S1259>/Unit Delay' */
  app_DW.UnitDelay_DSTATE_i = rtb_t_min;

  /* Update for Delay: '<S1265>/Delay' */
  app_DW.icLoad_nn = 0U;

  /* Update for Delay: '<S1278>/Delay' */
  app_DW.icLoad_jv = 0U;
  app_DW.Delay_DSTATE_lz = DataTypeConversion28;

  /* Update for UnitDelay: '<S1195>/Delay Input1' incorporates:
   *  DataTypeConversion: '<S1065>/Data Type Conversion'
   *
   * Block description for '<S1195>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_i = (uint8_T)Arb_is_LatCtrlActv_bl;

  /* Update for UnitDelay: '<S1196>/Delay Input1'
   *
   * Block description for '<S1196>/Delay Input1':
   *
   *  Store in Global RAM
   */
  app_DW.DelayInput1_DSTATE_o = LogicalOperator;

  /* Update for Delay: '<S1142>/Delay' incorporates:
   *  Gain: '<S1146>/Gain'
   *  Gain: '<S1146>/Gain1'
   *  Gain: '<S1146>/Gain2'
   *  Gain: '<S1146>/Gain3'
   *  Gain: '<S1146>/Gain5'
   *  Gain: '<S1146>/Gain6'
   *  Gain: '<S1146>/Gain8'
   *  Gain: '<S1146>/Gain9'
   *  Product: '<S1197>/Product'
   *  Product: '<S1197>/Product1'
   *  Product: '<S1197>/Product2'
   *  Product: '<S1197>/Product3'
   *  Product: '<S1197>/Product4'
   *  Product: '<S1198>/Product'
   *  Product: '<S1198>/Product1'
   *  Product: '<S1198>/Product2'
   *  Product: '<S1198>/Product3'
   *  Product: '<S1199>/Product'
   *  Product: '<S1199>/Product1'
   *  Product: '<S1199>/Product2'
   *  Sum: '<S1197>/Add'
   *  Sum: '<S1198>/Add'
   *  Sum: '<S1199>/Add'
   */
  app_DW.icLoad_je = 0U;
  app_DW.Delay_DSTATE_cg[0] = ((((app_B.cost_traj[2] * app_B.plan_time +
    app_B.cost_traj[1]) + app_B.cost_traj[3] * app_B.plan_time * app_B.plan_time)
    + app_B.cost_traj[4] * app_B.plan_time * app_B.plan_time * app_B.plan_time)
    + app_B.cost_traj[5] * app_B.plan_time * app_B.plan_time * app_B.plan_time *
    app_B.plan_time) + app_B.cost_traj[6] * app_B.plan_time * app_B.plan_time *
    app_B.plan_time * app_B.plan_time * app_B.plan_time;
  app_DW.Delay_DSTATE_cg[1] = (((2.0F * app_B.cost_traj[3] * app_B.plan_time +
    app_B.cost_traj[2]) + 3.0F * app_B.cost_traj[4] * app_B.plan_time *
    app_B.plan_time) + 4.0F * app_B.cost_traj[5] * app_B.plan_time *
    app_B.plan_time * app_B.plan_time) + 5.0F * app_B.cost_traj[6] *
    app_B.plan_time * app_B.plan_time * app_B.plan_time * app_B.plan_time;
  app_DW.Delay_DSTATE_cg[2] = ((6.0F * app_B.cost_traj[4] * app_B.plan_time +
    2.0F * app_B.cost_traj[3]) + 12.0F * app_B.cost_traj[5] * app_B.plan_time *
    app_B.plan_time) + 20.0F * app_B.cost_traj[6] * app_B.plan_time *
    app_B.plan_time * app_B.plan_time;
}

/* Model initialize function */
void app_initialize(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));

  {
    boolean_T rtb_Out;
    eCCR_ACCCancelReq rtb_DA_OUT_indx_ACCSysCanclReq_u8;
    eCDL_ACCDistLvl rtb_DA_OUT_indx_ACCDetObjDistLvl_u8;
    eRPL_RePlanLevel rtb_TRP_Replan_Level;

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack27' */

    /*-----------S-Function Block: <S6>/CAN Unpack27 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack' */

    /*-----------S-Function Block: <S6>/CAN Unpack -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack42' */

    /*-----------S-Function Block: <S6>/CAN Unpack42 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack41' */

    /*-----------S-Function Block: <S6>/CAN Unpack41 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack16' */

    /*-----------S-Function Block: <S6>/CAN Unpack16 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack39' */

    /*-----------S-Function Block: <S6>/CAN Unpack39 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack31' */

    /*-----------S-Function Block: <S6>/CAN Unpack31 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack44' */

    /*-----------S-Function Block: <S6>/CAN Unpack44 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack40' */

    /*-----------S-Function Block: <S6>/CAN Unpack40 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack4' */

    /*-----------S-Function Block: <S6>/CAN Unpack4 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack5' */

    /*-----------S-Function Block: <S6>/CAN Unpack5 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack12' */

    /*-----------S-Function Block: <S6>/CAN Unpack12 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack8' */

    /*-----------S-Function Block: <S6>/CAN Unpack8 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack13' */

    /*-----------S-Function Block: <S6>/CAN Unpack13 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack25' */

    /*-----------S-Function Block: <S6>/CAN Unpack25 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack35' */

    /*-----------S-Function Block: <S6>/CAN Unpack35 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack34' */

    /*-----------S-Function Block: <S6>/CAN Unpack34 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack33' */

    /*-----------S-Function Block: <S6>/CAN Unpack33 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack14' */

    /*-----------S-Function Block: <S6>/CAN Unpack14 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack37' */

    /*-----------S-Function Block: <S6>/CAN Unpack37 -----------------*/

    /* Start for S-Function (scanunpack): '<S6>/CAN Unpack30' */

    /*-----------S-Function Block: <S6>/CAN Unpack30 -----------------*/

    /* Start for S-Function (scanunpack): '<S73>/CAN Unpack1' */

    /*-----------S-Function Block: <S73>/CAN Unpack1 -----------------*/

    /* Start for S-Function (scanunpack): '<S72>/CAN Unpack' */

    /*-----------S-Function Block: <S72>/CAN Unpack -----------------*/
    app_PrevZCX.Delay_Reset_ZCE = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_n = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_b = UNINITIALIZED_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_j = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_b0 = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_l = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_p = POS_ZCSIG;
    app_PrevZCX.TriggeredSubsystem_Trig_ZCE = POS_ZCSIG;
    app_PrevZCX.ResettableDelay_Reset_ZCE = POS_ZCSIG;
    app_PrevZCX.Subsystem_Trig_ZCE = UNINITIALIZED_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_m = POS_ZCSIG;
    app_PrevZCX.Delay_Reset_ZCE_h = POS_ZCSIG;
    app_PrevZCX.EnDRL_d.ResettableDelay_Reset_ZCE_h = POS_ZCSIG;
    app_PrevZCX.EnDRL.ResettableDelay_Reset_ZCE_h = POS_ZCSIG;
    app_PrevZCX.EnDRL1.ResettableDelay_Reset_ZCE_h = POS_ZCSIG;

    /* InitializeConditions for Delay: '<S74>/Delay9' */
    app_DW.icLoad = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay8' */
    app_DW.icLoad_e = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay7' */
    app_DW.icLoad_h = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay6' */
    app_DW.icLoad_i = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay5' */
    app_DW.icLoad_c = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay' */
    app_DW.icLoad_if = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay1' */
    app_DW.icLoad_ed = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay2' */
    app_DW.icLoad_l = 1U;

    /* InitializeConditions for Delay: '<S74>/Delay3' */
    app_DW.icLoad_ll = 1U;

    /* InitializeConditions for Delay: '<S84>/Delay' */
    app_DW.icLoad_n = 1U;

    /* InitializeConditions for Delay: '<S81>/Delay' */
    app_DW.icLoad_j = 1U;

    /* InitializeConditions for Delay: '<S82>/Delay' */
    app_DW.icLoad_k = 1U;

    /* InitializeConditions for Delay: '<S85>/Delay' */
    app_DW.icLoad_e0 = 1U;

    /* InitializeConditions for UnitDelay: '<S121>/Unit Delay' */
    app_DW.UnitDelay_DSTATE_m = 10.0F;

    /* InitializeConditions for Delay: '<S1287>/Delay' */
    app_DW.icLoad_g = 1U;

    /* InitializeConditions for Delay: '<S1285>/Delay' */
    app_DW.icLoad_cb = 1U;

    /* InitializeConditions for Delay: '<S1295>/Delay' */
    app_DW.icLoad_f = 1U;

    /* InitializeConditions for Delay: '<S1315>/Delay' */
    app_DW.icLoad_a = 1U;

    /* InitializeConditions for Delay: '<S1253>/Delay' */
    app_DW.icLoad_b = 1U;

    /* InitializeConditions for Delay: '<S1265>/Delay' */
    app_DW.icLoad_nn = 1U;

    /* InitializeConditions for Delay: '<S1278>/Delay' */
    app_DW.icLoad_jv = 1U;

    /* InitializeConditions for Delay: '<S1142>/Delay' */
    app_DW.icLoad_je = 1U;

    /* SystemInitialize for Chart: '<S945>/DFIn_TmCntrSF_TRUE1'
     *
     * Block description for '<S945>/DFIn_TmCntrSF_TRUE1':
     *  /+This State machine is used as a time counter for measurement when the input is TRUE.
     *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
     */
    app_DFIn_TmCntrSF_TRUE1_Init(&app_B.OutPut_f);

    /* SystemInitialize for Chart: '<S945>/DFIn_TmCntrSF_TRUE2'
     *
     * Block description for '<S945>/DFIn_TmCntrSF_TRUE2':
     *  /+This State machine is used as a time counter for measurement when the input is TRUE.
     *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
     */
    app_DFIn_TmCntrSF_TRUE1_Init(&app_B.OutPut_n);

    /* SystemInitialize for Atomic SubSystem: '<S950>/Debounce_Module' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S950>/Debounce_Module' */

    /* SystemInitialize for Atomic SubSystem: '<S950>/Debounce_Module2' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S950>/Debounce_Module2' */

    /* SystemInitialize for Atomic SubSystem: '<S949>/Debounce_Module1' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S949>/Debounce_Module1' */

    /* SystemInitialize for Atomic SubSystem: '<S949>/Debounce_Module' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S949>/Debounce_Module' */

    /* SystemInitialize for Atomic SubSystem: '<S976>/Debounce_Module1' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S976>/Debounce_Module1' */

    /* SystemInitialize for Atomic SubSystem: '<S976>/Debounce_Module2' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S976>/Debounce_Module2' */

    /* SystemInitialize for Atomic SubSystem: '<S976>/Debounce_Module3' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S976>/Debounce_Module3' */

    /* SystemInitialize for Atomic SubSystem: '<S976>/Debounce_Module4' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S976>/Debounce_Module4' */

    /* SystemInitialize for Atomic SubSystem: '<S976>/Debounce_Module5' */
    app_Debounce_Module_d_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S976>/Debounce_Module5' */

    /* SystemInitialize for Atomic SubSystem: '<S1023>/EstdLongtAccel1' */
    app_EstdLongtAccel1_Init(&app_B.EstdLongtAccel1);

    /* End of SystemInitialize for SubSystem: '<S1023>/EstdLongtAccel1' */

    /* SystemInitialize for Atomic SubSystem: '<S1023>/EstdVSELongtAccel' */
    app_EstdVSELongtAccel_Init(&app_B.EstdVSELongtAccel);

    /* End of SystemInitialize for SubSystem: '<S1023>/EstdVSELongtAccel' */

    /* SystemInitialize for Chart: '<S909>/DFIn_TmCntrSF_TRUE'
     *
     * Block description for '<S909>/DFIn_TmCntrSF_TRUE':
     *  /+This State machine is used as a time counter for measurement when the input is TRUE.
     *  E.g. If ABS_Active Signal==TRUE and lasting for large enough counters, the output ==TRUE.+/
     */
    app_DFIn_TmCntrSF_TRUE1_Init(&app_B.OutPut_g);

    /* SystemInitialize for Chart: '<S909>/ACC_SSM' */
    m_FSM_sts_ACCSMRSts_en = eACCReqStsOff;

    /* SystemInitialize for Triggered SubSystem: '<S3>/Subsystem' */
    /* InitializeConditions for Delay: '<S150>/Resettable Delay' */
    app_DW.icLoad_bl = 1U;

    /* InitializeConditions for Delay: '<S144>/Resettable Delay1' */
    app_DW.icLoad_m = 1U;

    /* InitializeConditions for Delay: '<S185>/Resettable Delay2' */
    app_DW.icLoad_l4 = 1U;

    /* InitializeConditions for Delay: '<S200>/Resettable Delay' */
    app_DW.icLoad_ba = 1U;

    /* InitializeConditions for Delay: '<S202>/Resettable Delay' */
    app_DW.icLoad_en = 1U;

    /* InitializeConditions for Delay: '<S144>/Resettable Delay2' */
    app_DW.icLoad_g5 = 1U;

    /* InitializeConditions for Delay: '<S144>/Resettable Delay4' */
    app_DW.icLoad_cbj = 1U;

    /* InitializeConditions for Delay: '<S144>/Resettable Delay5' */
    app_DW.icLoad_cj = 1U;

    /* InitializeConditions for UnitDelay: '<S501>/Unit Delay3' */
    app_DW.UnitDelay3_DSTATE_o = true;

    /* InitializeConditions for Delay: '<S497>/Resettable Delay' */
    app_DW.icLoad_g53 = 1U;

    /* InitializeConditions for UnitDelay: '<S501>/Unit Delay' */
    app_DW.UnitDelay_DSTATE_f = 2.0F;

    /* InitializeConditions for UnitDelay: '<S501>/Unit Delay4' */
    app_DW.UnitDelay4_DSTATE = RPL_Init;

    /* InitializeConditions for UnitDelay: '<S501>/Unit Delay2' */
    app_DW.UnitDelay2_DSTATE_m = 2U;

    /* SystemInitialize for Atomic SubSystem: '<S497>/LowPass_Filter' */
    app_LowPass_Filter_Init(&app_DW.LowPass_Filter_k);

    /* End of SystemInitialize for SubSystem: '<S497>/LowPass_Filter' */

    /* SystemInitialize for Atomic SubSystem: '<S191>/EnDRL' */
    app_EnDRL_Init(&app_DW.EnDRL_d);

    /* End of SystemInitialize for SubSystem: '<S191>/EnDRL' */

    /* SystemInitialize for Atomic SubSystem: '<S190>/EnDRL' */
    app_EnDRL_Init(&app_DW.EnDRL);

    /* End of SystemInitialize for SubSystem: '<S190>/EnDRL' */

    /* SystemInitialize for Atomic SubSystem: '<S189>/EnDRL1' */
    app_EnDRL_Init(&app_DW.EnDRL1);

    /* End of SystemInitialize for SubSystem: '<S189>/EnDRL1' */

    /* SystemInitialize for Chart: '<S501>/Chart' */
    app_Chart_n_Init(&rtb_TRP_Replan_Level);

    /* SystemInitialize for Chart: '<S502>/TRP_Scheduling' incorporates:
     *  SubSystem: '<S502>/Trj_RePlan1'
     */
    app_Trj_RePlan1_Init(&app_DW.Trj_RePlan1);

    /* SystemInitialize for Chart: '<S238>/Chart' */
    app_Chart_n_Init(&rtb_TRP_Replan_Level);

    /* SystemInitialize for Atomic SubSystem: '<S187>/LowPass_Filter' */
    app_LowPass_Filter_Init(&app_DW.LowPass_Filter);

    /* End of SystemInitialize for SubSystem: '<S187>/LowPass_Filter' */

    /* SystemInitialize for Atomic SubSystem: '<S187>/LowPass_Filter1' */
    app_LowPass_Filter_Init(&app_DW.LowPass_Filter1);

    /* End of SystemInitialize for SubSystem: '<S187>/LowPass_Filter1' */

    /* SystemInitialize for Atomic SubSystem: '<S139>/LowPass_Filter' */
    app_LowPass_Filter_Init(&app_DW.LowPass_Filter_b);

    /* End of SystemInitialize for SubSystem: '<S139>/LowPass_Filter' */
    /* End of SystemInitialize for SubSystem: '<S3>/Subsystem' */

    /* SystemInitialize for Atomic SubSystem: '<S117>/Debounce_Module' */
    app_Debounce_Module_Init(&rtb_Out);

    /* End of SystemInitialize for SubSystem: '<S117>/Debounce_Module' */

    /* SystemInitialize for Atomic SubSystem: '<S951>/DownEdge_counter' */
    app_DownEdge_counter_Init(&app_B.OutPut_k);

    /* End of SystemInitialize for SubSystem: '<S951>/DownEdge_counter' */

    /* SystemInitialize for Atomic SubSystem: '<S997>/HMI_ACCDetObjDistLvl' */
    app_HMI_ACCDetObjDistLvl_Init(&rtb_DA_OUT_indx_ACCDetObjDistLvl_u8);

    /* End of SystemInitialize for SubSystem: '<S997>/HMI_ACCDetObjDistLvl' */

    /* SystemInitialize for Atomic SubSystem: '<S997>/HMI_ACCObjDetJud' */
    app_HMI_ACCObjDetJud_Init();

    /* End of SystemInitialize for SubSystem: '<S997>/HMI_ACCObjDetJud' */

    /* SystemInitialize for Atomic SubSystem: '<S997>/HMI_ACCSysCanclReq' */
    app_HMI_ACCSysCanclReq_Init(&rtb_DA_OUT_indx_ACCSysCanclReq_u8);

    /* End of SystemInitialize for SubSystem: '<S997>/HMI_ACCSysCanclReq' */

    /* SystemInitialize for Atomic SubSystem: '<S997>/HMI_ACCSysStsJud' */
    /* UnitDelay: '<S93>/Unit Delay34' */
    app_HMI_ACCSysStsJud_Init(&app_DW.UnitDelay34_DSTATE);

    /* End of SystemInitialize for SubSystem: '<S997>/HMI_ACCSysStsJud' */

    /* SystemInitialize for Atomic SubSystem: '<S1030>/Hyseresis_Keep' */
    app_Hyseresis_Keep_Init(&app_B.OutPut_j);

    /* End of SystemInitialize for SubSystem: '<S1030>/Hyseresis_Keep' */

    /* SystemInitialize for Atomic SubSystem: '<S1030>/Hyseresis_Keep1' */
    app_Hyseresis_Keep_Init(&app_B.OutPut);

    /* End of SystemInitialize for SubSystem: '<S1030>/Hyseresis_Keep1' */

    /* SystemInitialize for Chart: '<S1063>/Chart' */
    app_Chart_g_Init(&app_B.count_b);

    /* SystemInitialize for IfAction SubSystem: '<S1138>/Path_Tracking1' */
    /* Start for DataStoreMemory: '<S1236>/Data Store Memory' */
    app_DW.P[0] = 1.0F;
    app_DW.P[1] = 0.0F;
    app_DW.P[2] = 0.0F;
    app_DW.P[3] = 1.0F;

    /* InitializeConditions for Delay: '<S1235>/Delay' */
    app_DW.icLoad_bz = 1U;

    /* InitializeConditions for Delay: '<S1238>/Delay' */
    app_DW.icLoad_jw = 1U;

    /* InitializeConditions for Delay: '<S1237>/Delay' */
    app_DW.icLoad_o = 1U;

    /* InitializeConditions for Delay: '<S1219>/Delay' */
    app_DW.icLoad_ng = 1U;

    /* End of SystemInitialize for SubSystem: '<S1138>/Path_Tracking1' */

    /* SystemInitialize for Chart: '<S1098>/Chart' */
    app_Chart_i_Init(app_B.msg_n);

    /* SystemInitialize for Chart: '<S1102>/Chart' */
    app_Chart_l_Init(app_B.msg);

    /* SystemInitialize for Chart: '<S1100>/Chart' */
    app_Chart_l_Init(app_B.msg_f);

    /* SystemInitialize for Chart: '<S1101>/Chart' */
    app_Chart_l_Init(app_B.msg_c);

    /* SystemInitialize for Chart: '<S1068>/Chart' */
    app_Chart_g_Init(&app_B.count_f);

    /* SystemInitialize for Chart: '<S1084>/Chart' */
    app_Chart_i_Init(app_B.msg_a);

    /* SystemInitialize for Chart: '<S1085>/Chart' */
    app_Chart_l_Init(app_B.msg_m);

    /* SystemInitialize for Chart: '<S1086>/Chart' */
    app_Chart_l_Init(app_B.msg_g);

    /* SystemInitialize for Chart: '<S1087>/Chart' */
    app_Chart_l_Init(app_B.msg_i);
  }
}

/* Model terminate function */
void app_terminate(void)
{
  /* (no terminate code required) */
}

/*
 * File trailer for generated code.
 *
 * [EOF]
 */
